"""Make string uppercase"""
directive @upper on FIELD

"""Replace a substring with another substring"""
directive @replace(old: String!, new: String!) on FIELD

"""Make get stuff uppercase"""
directive @relation(on: String!) on FIELD

"""
A descendant of a comment. Descendend are used to render rich text in the frontend.
"""
interface Descendant {
  """
  Unsafe children are not typed and fall back to json. This is a workaround if queries get too complex.
  """
  unsafeChildren: [UnsafeChild!]
  kind: DescendantKind!
  children: [Descendant!]
}

"""
The `Identifier` scalasr typsse represents a reference to a store previously created by the user n a datalayer
"""
scalar UnsafeChild

"""The Kind of a Descendant"""
enum DescendantKind {
  LEAF
  MENTION
  PARAGRAPH
}

"""A mention of a user"""
type MentionDescendant implements Descendant {
  """
  Unsafe children are not typed and fall back to json. This is a workaround if queries get too complex.
  """
  unsafeChildren: [UnsafeChild!]
  kind: DescendantKind!
  children: [Descendant!]
  user: User
}

"\nA User is a person that can log in to the system. They are uniquely identified by their username.\nAnd can have an email address associated with them (but don't have to).\n\nA user can be assigned to groups and has a profile that can be used to display information about them.\nDetail information about a user can be found in the profile.\n\nAll users can have social accounts associated with them. These are used to authenticate the user with external services,\nsuch as ORCID or GitHub.\n\n"
type User {
  id: ID!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  firstName: String
  lastName: String
  email: String

  """
  The groups this user belongs to. A user will get all permissions granted to each of their groups.
  """
  groups(filters: GroupFilter, pagination: OffsetPaginationInput): [Group!]!
  avatar: String
  profile: Profile!
  managedClients: [DjangoModelType!]!
  socialAccounts: [SocialAccount!]!
}

"\nA Group is the base unit of Role Based Access Control. A Group can have many users and many permissions. A user can have many groups. A user with a group that has a permission can perform the action that the permission allows.\nGroups are propagated to the respecting subservices. Permissions are not. Each subservice has to define its own permissions and mappings to groups.\n"
type Group {
  id: ID!
  name: String!
  users(filters: UserFilter, pagination: OffsetPaginationInput): [User!]!
}

"""
A User of the System

Lok Users are the main users of the system. They can be assigned to groups and have profiles, that can be used to display information about them.
Each user is identifier by a unique username, and can have an email address associated with them.
"""
input UserFilter {
  search: String

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: StrFilterLookup
  ids: [ID!]
  socialAccounts: SocialAccountFilter
  AND: UserFilter
  OR: UserFilter
}

input StrFilterLookup {
  exact: String
  iExact: String
  contains: String
  iContains: String
  inList: [String!]
  gt: String
  gte: String
  lt: String
  lte: String
  startsWith: String
  iStartsWith: String
  endsWith: String
  iEndsWith: String
  range: [String!]
  isNull: Boolean
  regex: String
  iRegex: String
  nExact: String
  nIExact: String
  nContains: String
  nIContains: String
  nInList: [String!]
  nGt: String
  nGte: String
  nLt: String
  nLte: String
  nStartsWith: String
  nIStartsWith: String
  nEndsWith: String
  nIEndsWith: String
  nRange: [String!]
  nIsNull: Boolean
  nRegex: String
  nIRegex: String
}

"""
SocialAccount(id, user, provider, uid, last_login, date_joined, extra_data)
"""
input SocialAccountFilter {
  search: String
  provider: ProviderType
  ids: [ID!]
  AND: SocialAccountFilter
  OR: SocialAccountFilter
}

enum ProviderType {
  ORCID
}

input OffsetPaginationInput {
  offset: Int! = 0
  limit: Int! = -1
}

"""__doc__"""
input GroupFilter {
  search: String
  name: StrFilterLookup
  ids: [ID!]
  AND: GroupFilter
  OR: GroupFilter
}

"\nA Profile of a User. A Profile can be used to display personalied information about a user.\n\n\n\n\n"
type Profile {
  """A short bio of the user"""
  bio: String!

  """The name of the user"""
  name: String!
}

type DjangoModelType {
  pk: ID!
}

"\nA Social Account is an account that is associated with a user. It can be used to authenticate the user with external services. It\ncan be used to store extra data about the user that is specific to the provider. We provide typed access to the extra data for\nsome providers. For others we provide a generic json field that can be used to store arbitrary data. Generic accounts are\nalways available, but typed accounts are only available for some providers.\n"
interface SocialAccount {
  """
  The provider of the account. This can be used to determine the type of the account.
  """
  provider: ProviderType!

  """The unique identifier of the account. This is unique for the provider."""
  uid: String!

  """
  Extra data that is specific to the provider. This is a json field and can be used to store arbitrary data.
  """
  extraData: ExtraData!
}

"""
The `ArrayLike` scalasr typsse represents a reference to a store previously created by the user n a datalayer
"""
scalar ExtraData

"""A Paragraph of text"""
type ParagraphDescendant implements Descendant {
  """
  Unsafe children are not typed and fall back to json. This is a workaround if queries get too complex.
  """
  unsafeChildren: [UnsafeChild!]
  kind: DescendantKind!
  children: [Descendant!]
  size: String
}

"""
A leaf of text. This is the most basic descendant and always ends a tree.
"""
type LeafDescendant implements Descendant {
  """
  Unsafe children are not typed and fall back to json. This is a workaround if queries get too complex.
  """
  unsafeChildren: [UnsafeChild!]
  kind: DescendantKind!
  children: [Descendant!]
  bold: Boolean
  italic: Boolean
  underline: Boolean
  text: String
  code: String
}

"\nThe Generic Account is a Social Account that maps to a generic account. It provides information about the\nuser that is specific to the provider. This includes untyped extra data.\n\n"
type GenericAccount implements SocialAccount {
  """
  The provider of the account. This can be used to determine the type of the account.
  """
  provider: ProviderType!

  """The unique identifier of the account. This is unique for the provider."""
  uid: String!
  extraData: ExtraData!
}

"\nAn ORCID Account is a Social Account that maps to an ORCID Account. It provides information about the\nuser that is specific to the ORCID service. This includes the ORCID Identifier, the ORCID Preferences and\nthe ORCID Person. The ORCID Person contains information about the user that is specific to the ORCID service.\nThis includes the ORCID Activities, the ORCID Researcher URLs and the ORCID Addresses.\n\n"
type OrcidAccount implements SocialAccount {
  """
  The provider of the account. This can be used to determine the type of the account.
  """
  provider: ProviderType!

  """The unique identifier of the account. This is unique for the provider."""
  uid: String!

  """
  Extra data that is specific to the provider. This is a json field and can be used to store arbitrary data.
  """
  extraData: ExtraData!

  """
  The ORCID Identifier of the user. The UID of the account is the same as the path of the identifier.
  """
  identifier: OrcidIdentifier!

  """Information about the person that is specific to the ORCID service."""
  person: OrcidPerson
}

"""
The ORCID Identifier of a user. This is a unique identifier that is used to identify a user on the ORCID service. It is composed of a uri, a path and a host.
"""
type OrcidIdentifier {
  """The uri of the identifier"""
  uri: String!

  """The path of the identifier"""
  path: String!

  """The host of the identifier"""
  host: String!
}

type OrcidPerson {
  researcherUrls: [String!]!
  addresses: [String!]!
}

type Query {
  stashes(filters: StashFilter, pagination: OffsetPaginationInput): [Stash!]!
  stashItems(filters: StashItemFilter, pagination: OffsetPaginationInput): [StashItem!]!
  apps: [App!]!
  releases: [Release!]!
  clients(filters: ClientFilter, pagination: OffsetPaginationInput): [Client!]!
  compositions: [Composition!]!
  users(filters: UserFilter, pagination: OffsetPaginationInput): [User!]!
  groups(filters: GroupFilter, pagination: OffsetPaginationInput): [Group!]!
  comments: [Comment!]!
  rooms(filters: RoomFilter, pagination: OffsetPaginationInput): [Room!]!
  redeemTokens(filters: RedeemTokenFilter, pagination: OffsetPaginationInput): [RedeemToken!]!
  stash(id: ID!): Stash!
  stashItem(id: ID!): StashItem!
  myStashes: [Stash!]!
  user(id: ID!): User!
  me: User!
  group(id: ID!): Group!
  mygroups: [Group!]!
  room(id: ID!): Room!
  stream(id: ID!): Stream!
  app(id: ID = null, identifier: AppIdentifier = null, clientId: ID = null): App!
  release(id: ID, identifier: AppIdentifier, version: Version, clientId: ID): Release!
  client(id: ID = null, clientId: ID = null): Client!
  myManagedClients(kind: ClientKind!): Client!
  scopes: [Scope!]!
  comment(id: ID!): Comment!
  commentsFor(identifier: Identifier!, object: ID!): [Comment!]!
  myMentions: [Comment!]!
  myActiveMessages: [SystemMessage!]!
  message(id: ID!): SystemMessage!
  hallo: String!
}

"\nA Stash\n"
type Stash {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  isActive: Boolean!
  items(filters: StashItemFilter, pagination: OffsetPaginationInput): [StashItem!]!

  """The number of items in the stash"""
  owner: User!
}

"""Date with time (isoformat)"""
scalar DateTime

"\nA stashed item\n"
type StashItem {
  id: ID!
  identifier: String!
  description: String
  object: String!
  addedAt: DateTime!
  updatedAt: DateTime!
}

"""
StashItem(id, stash, identifier, object, added_by, added_at, updated_at)
"""
input StashItemFilter {
  search: String
  username: StrFilterLookup
  ids: [ID!]
  stashes: [ID!]
  AND: StashItemFilter
  OR: StashItemFilter
}

"""__doc__"""
input StashFilter {
  search: String
  ids: [ID!]
  AND: StashFilter
  OR: StashFilter
}

"""
An App is the Arkitekt equivalent of a Software Application. It is a collection of `Releases` that can be all part of the same application. E.g the App `Napari` could have the releases `0.1.0` and `0.2.0`.
"""
type App {
  id: ID!

  """The name of the app"""
  name: String!

  """
  The identifier of the app. This should be a globally unique string that identifies the app. We encourage you to use the reverse domain name notation. E.g. `com.example.myapp`
  """
  identifier: AppIdentifier!

  """
  The logo of the app. This should be a url to a logo that can be used to represent the app.
  """
  logo: String

  """
  The releases of the app. A release is a version of the app that can be installed by a user.
  """
  releases: [Release!]!
}

"""
The App identifier is a unique identifier for an app. It is used to identify the app in the database and in the code. We encourage you to use the reverse domain name notation. E.g. `com.example.myapp`
"""
scalar AppIdentifier

"""
A Release is a version of an app. Releases might change over time. E.g. a release might be updated to fix a bug, and the release might be updated to add a new feature. This is why they are the home for `scopes` and `requirements`, which might change over the release cycle.
"""
type Release {
  id: ID!

  """The app that this release belongs to."""
  app: App!

  """
  The version of the release. This should be a string that identifies the version of the release. We enforce semantic versioning notation. E.g. `0.1.0`. The version is unique per app.
  """
  version: Version!

  """
  The name of the release. This should be a string that identifies the release beyond the version number. E.g. `canary`.
  """
  name: String!

  """
  The logo of the release. This should be a url to a logo that can be used to represent the release.
  """
  logo: String

  """
  The scopes of the release. Scopes are used to limit the access of a client to a user's data. They represent app-level permissions.
  """
  scopes: [String!]!

  """
  The requirements of the release. Requirements are used to limit the access of a client to a user's data. They represent app-level permissions.
  """
  requirements: [String!]!

  """The clients of the release"""
  clients(filters: ClientFilter, pagination: OffsetPaginationInput): [Client!]!
}

"""The `Version` represents a semver version string"""
scalar Version

"""
A client is a way of authenticating users with a release.
 The strategy of authentication is defined by the kind of client. And allows for different authentication flow. 
 E.g a client can be a DESKTOP app, that might be used by multiple users, or a WEBSITE that wants to connect to a user's account, 
 but also a DEVELOPMENT client that is used by a developer to test the app. The client model thinly wraps the oauth2 client model, which is used to authenticate users.
"""
type Client {
  id: ID!

  """The release that this client belongs to."""
  release: Release!

  """The user that manages this release."""
  tenant: User!

  """
  The configuration of the client. This is the configuration that will be sent to the client. It should never contain sensitive information.
  """
  kind: ClientKind!

  """
  The real oauth2 client that is used to authenticate users with this client.
  """
  oauth2Client: Oauth2Client!

  """Is this client public? If a client is public """
  public: Boolean!

  """The composition of the client. """
  composition: Composition!

  """
  If the client is a DEVELOPMENT client, which requires no further authentication, this is the user that is authenticated with the client.
  """
  user: User

  """
  The configuration of the client. This is the configuration that will be sent to the client. It should never contain sensitive information.
  """
  token: String!
}

enum ClientKind {
  DEVELOPMENT
  WEBSITE
  DESKTOP
}

"""
Application(id, client_id, user, redirect_uris, post_logout_redirect_uris, client_type, authorization_grant_type, client_secret, name, skip_authorization, created, updated, algorithm)
"""
type Oauth2Client {
  id: ID!
  name: String!
  user: User!
  clientType: String!
  clientId: String!
  algorithm: String!
  authorizationGrantType: String!

  """Allowed URIs list, space separated"""
  redirectUris: String!
}

"""A template for a configuration"""
type Composition {
  id: ID!

  """The name of the composition"""
  name: String!

  """
  The template of the composition. This is a Jinja2 YAML template that will be rendered with the LinkingContext as context. The result of the rendering will be used to send to the client as a configuration. It should never contain sensitive information.
  """
  template: String!

  """
  The mappings of the composition. A mapping is a mapping of a service to a service instance. This is used to configure the composition.
  """
  mappings: [ServiceInstanceMapping!]!
}

"""
A ServiceInstance is a configured instance of a Service. It will be configured by a configuration backend and will be used to send to the client as a configuration. It should never contain sensitive information.
"""
type ServiceInstanceMapping {
  id: ID!

  """The service that this instance belongs to."""
  instance: ServiceInstance!

  """The composition that this instance belongs to."""
  composition: Composition!

  """
  The key of the instance. This is a unique string that identifies the instance. It is used to identify the instance in the code and in the database.
  """
  key: String!
}

"""
A ServiceInstance is a configured instance of a Service. It will be configured by a configuration backend and will be used to send to the client as a configuration. It should never contain sensitive information.
"""
type ServiceInstance {
  id: ID!

  """The service that this instance belongs to."""
  service: Service!

  """The backend that this instance belongs to."""
  backend: BackendType!

  """The composition that this instance belongs to."""
  composition: Composition!

  """
  The name of the instance. This is a human readable name of the instance.
  """
  name: String!

  """
  The identifier of the instance. This is a unique string that identifies the instance. It is used to identify the instance in the code and in the database.
  """
  identifier: String!
}

"""
A Service is a Webservice that a Client might want to access. It is not the configured instance of the service, but the service itself.
"""
type Service {
  """
  The key of the service. This is a unique string that identifies the service. It is used to identify the service in the code and in the database.
  """
  key: String!
  id: ID!

  """The name of the service"""
  name: String!

  """
  The identifier of the service. This should be a globally unique string that identifies the service. We encourage you to use the reverse domain name notation. E.g. `com.example.myservice`
  """
  identifier: ServiceIdentifier!

  """
  The logo of the service. This should be a url to a logo that can be used to represent the service.
  """
  logo: String!

  """
  The description of the service. This should be a human readable description of the service.
  """
  description: String!
}

"""
The Service identifier is a unique identifier for a service. It is used to identify the service in the database and in the code. We encourage you to use the reverse domain name notation. E.g. `com.example.myservice`
"""
scalar ServiceIdentifier

enum BackendType {
  DockerBackend
  ConfigBackend
}

"""
Client(id, composition, release, oauth2_client, kind, public, token, client_id, client_secret, tenant, user, created_at)
"""
input ClientFilter {
  search: String
  ids: [ID!]
  AND: ClientFilter
  OR: ClientFilter
}

"""
Comments represent the comments of a user on a specific data item 
tart are identified by the unique combination of `identifier` and `object`.
E.g a comment for an Image on the Mikro services would be serverd as
`@mikro/image:imageID`. 

Comments always belong to the user that created it. Comments in threads
get a parent attribute set, that points to the immediate parent.

Each comment contains multiple descendents, that make up a *rich* representation
of the underlying comment data including potential mentions, or links, or 
paragraphs.
"""
type Comment {
  id: ID!

  """The object id of the object, on its associated service"""
  object: String!

  """The identifier of the object. Consult the documentation for the format"""
  identifier: Identifier!

  """The children of this comment"""
  children: [Comment!]!

  """The parent of this comment. Think Thread"""
  parent: Comment

  """The time this comment got created"""
  createdAt: DateTime!

  """The users that got mentioned in this comment"""
  mentions(filters: UserFilter, pagination: OffsetPaginationInput): [User!]!

  """The user that resolved this comment"""
  resolvedBy: User

  """The user that created this comment"""
  user: User!

  """
  The immediate descendends of the comments. Think typed Rich Representation
  """
  descendants: [Descendant!]!
  resolved: Boolean!
}

"""
The `Identifier` scalasr typsse represents a reference to a store previously created by the user n a datalayer
"""
scalar Identifier

"""Room(id, title, description, creator)"""
type Room {
  id: ID!

  """The Title of the Room"""
  title: String!
  description: String!
  messages(filters: MessageFilter, pagination: OffsetPaginationInput): [Message!]!
  agents(pagination: OffsetPaginationInput): [Agent!]!
  streams: [Stream!]!
}

"""Message represent the message of an agent on a room"""
type Message {
  id: ID!
  title: String!

  """A clear text representation of the rich comment"""
  text: String!

  """The user that created this comment"""
  agent: Agent!
  attachedStructures(pagination: OffsetPaginationInput): [Structure!]!
}

"""Agent(id, room, name, app, user)"""
type Agent {
  id: ID!
  room: Room!
}

"""Structure(id, identifier, object)"""
type Structure {
  id: ID!

  """The object id of the object, on its associated service"""
  object: ID!

  """The identifier of the object. Consult the documentation for the format"""
  identifier: String!
}

"""Message represent the message of an agent on a room"""
input MessageFilter {
  ids: [ID!]
  search: String
  AND: MessageFilter
  OR: MessageFilter
}

"""Stream(id, agent, title, token)"""
type Stream {
  id: ID!

  """The agent that created this stream"""
  agent: Agent!

  """The Title of the Stream"""
  title: String!
  token: String!
}

"""Room(id, title, description, creator)"""
input RoomFilter {
  search: String
  ids: [ID!]
  AND: RoomFilter
  OR: RoomFilter
}

"""
A redeem token is a token that can be used to redeed the rights to create
a client. It is used to give the recipient the right to create a client.

If the token is not redeemed within the expires_at time, it will be invalid.
If the token has been redeemed, but the manifest has changed, the token will be invalid.
"""
type RedeemToken {
  id: ID!

  """The token of the redeem token"""
  token: String!

  """The client that this redeem token belongs to."""
  client: Client

  """The user that this redeem token belongs to."""
  user: User!
}

"""
A redeem token is a token that can be used to redeed the rights to create
a client. It is used to give the recipient the right to create a client.

If the token is not redeemed within the expires_at time, it will be invalid.
If the token has been redeemed, but the manifest has changed, the token will be invalid.
"""
input RedeemTokenFilter {
  search: String
  ids: [ID!]
  AND: RedeemTokenFilter
  OR: RedeemTokenFilter
}

"""
A scope that can be assigned to a client. Scopes are used to limit the access of a client to a user's data. They represent app-level permissions.
"""
type Scope {
  """The label of the scope. This is the human readable name of the scope."""
  label: String!

  """
  The description of the scope. This is a human readable description of the scope.
  """
  description: String!

  """
  The value of the scope. This is the value that is used in the OAuth2 flow.
  """
  value: String!
}

"\nA System Message is a message that is sent to a user. \nIt can be used to notify the user of important events or to request their attention.\nSystem messages can use Rekuest Hooks as actions to allow the user to interact with the message.\n\n\n"
type SystemMessage {
  id: ID!
  title: String!
  message: String!

  """The action to take (e.g. the node)"""
  action: String!
  user: User!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  createComment(input: CreateCommentInput!): Comment!
  createRoom(input: CreateRoomInput!): Room!
  send(input: SendMessageInput!): Message!
  replyTo(input: ReplyToCommentInput!): Comment!
  resolveComment(input: ResolveCommentInput!): Comment!
  createDevelopmentalClient(input: DevelopmentClientInput!): Client!
  scan(input: ScanBackendInput!): String!
  render(input: RenderInput!): Fakt!
  acknowledgeMessage(input: AcknowledgeMessageInput!): SystemMessage!

  """Create a new stash"""
  createStash(input: CreateStashInput!): Stash!

  """Update a stash"""
  updateStash(input: UpdateStashInput!): Stash!

  """Add items to a stash"""
  addItemsToStash(input: AddItemToStashInput!): [StashItem!]!

  """Delete items from a stash"""
  deleteStashItems(input: DeleteStashItems!): [ID!]!
  deleteStash(input: DeleteStashInput!): ID!
  createStream(input: CreateStreamInput!): Stream!
  leaveStream(input: LeaveStreamInput!): Stream!
  joinStream(input: JoinStreamInput!): Stream!
}

input CreateUserInput {
  name: String!
}

input CreateCommentInput {
  descendants: [DescendantInput!]!
  identifier: Identifier!
  object: ID!
  parent: ID = null
  notify: Boolean = false
}

input DescendantInput {
  kind: DescendantKind!
  children: [DescendantInput!] = null
  user: String = null
  bold: Boolean = null
  italic: Boolean = null
  code: Boolean = null
  text: String = null
}

input CreateRoomInput {
  description: String = null
  title: String = null
}

input SendMessageInput {
  room: ID!
  agentId: String!
  text: String!
  parent: ID = null
  notify: Boolean = null
  attachStructures: [StructureInput!] = null
}

input StructureInput {
  object: ID!
  identifier: String!
}

input ReplyToCommentInput {
  descendants: [DescendantInput!]!
  parent: ID
  notify: Boolean
}

input ResolveCommentInput {
  id: ID!
  notify: Boolean
}

input DevelopmentClientInput {
  manifest: ManifestInput!
  composition: ID = null
  requirements: [Requirement!]! = []
}

input ManifestInput {
  identifier: String!
  version: String!
  logo: String = null
  scopes: [String!]! = []
}

input Requirement {
  service: String!
  optional: Boolean! = false
  description: String = null
  key: String!
}

input ScanBackendInput {
  backend: String = null
}

"""The `Fakt` scalar type represents a reference to a fakt"""
scalar Fakt

input RenderInput {
  client: ID!
  composition: ID = null
  request: LinkingRequestInput = null
  manifest: ManifestInput = null
}

input LinkingRequestInput {
  host: String!
  port: String!
  isSecure: Boolean! = false
}

input AcknowledgeMessageInput {
  id: ID!
  acknowledged: Boolean!
}

input CreateStashInput {
  name: String = null
  description: String = null
}

input UpdateStashInput {
  stash: ID!
  name: String!
  description: String = null
}

input AddItemToStashInput {
  stash: ID!
  items: [StashItemInput!]!
}

input StashItemInput {
  identifier: String!
  description: String = null
  object: String!
}

input DeleteStashItems {
  items: [ID!]!
}

input DeleteStashInput {
  stash: ID!
}

input CreateStreamInput {
  room: ID!
  title: String = null
  agentId: String = null
}

input LeaveStreamInput {
  id: ID!
}

input JoinStreamInput {
  id: ID!
}

type Subscription {
  communications(channels: [ID!]!): Communication!
  mentions: Comment!
  room(room: ID!, agentId: ID!, filterOwn: Boolean! = true): RoomEvent!
}

"""A Communication"""
type Communication {
  channel: ID!
}

type RoomEvent {
  message: Message
  join: Agent
  leave: Agent
}
# Developer documentation

## Developer setup
To set up your development environment, you not only need to install the dependencies of the project's code itself but also some modules for testing and keeping the repo clean through pre-commit hooks.

- Clone the repository: `git clone https://gitlab.com/octopus-code/postopus.git` (https) or `git clone git@gitlab.com:octopus-code/postopus.git` (ssh)
- Switch to the directory: `cd postopus`
- Upgrade pip to the newest version: `python3 -m pip install --upgrade pip`
- Create a [virtual environment](https://docs.python.org/3/library/venv.html) (recommended): `python3 -m venv .venv && source .venv/bin/activate`
- Install the sources including development dependencies: `pip install -e '.[dev]'` (or `pip install -e .[dev,docs]` if you want to build the documentation)
- Setup [pre-commit](https://pre-commit.com/): `pre-commit install`


### Testing
Run `pytest` to execute the tests. The data to run the tests is generated by [pytest fixtures](https://docs.pytest.org/en/6.2.x/fixture.html#what-fixtures-are).
They are provided e.g. in [`tests.utils.common_runs`](tests/utils/common_runs.py) and use the input files in [`tests/data/`](tests/data/). Therefore `octopus` must be available in the `PATH`.
Note that `octopus` will not be invoked again if the data for a run already exists and the input files have not changed in the meantime.

### Release
Releasing to PyPI is integrated into the GitLab CI.

#### Preparing a new realease
There are a few TODOs **before** publishing a new Postopus release. When uploading to PyPI these files are used for the project description.

First, recheck which Octopus versions are supported in the upcoming release. E.g. Postopus 0.3.0 supports the Octopus versions 13, 14 and 15.
These versions must be added into the version support table in the [`README.md`](README.md) and into the stage `tests` in [`.gitlab-ci.yml`](.gitlab-ci.yml) (the tests should run at least once for every supported Octopus version).

Another file to update is the [`changelog`](CHANGELOG.rst). Simply add the new version (including the correct release date!) with a summary of changes.
The changelog is not uploaded to PyPI but used in the documentation. If the file is updated *after* the release is created the documentation for that release won't be complete.

#### Releasing
To do the actual release a new tag has to be created and pushed. The CI pipeline takes care of the rest.
```
git checkout main
git pull
git tag <version>  # replace with the version number, e.g. `git tag 0.3.0`
git push origin <version>
```

Note that everybody can create tags in git but the release pipeline is only enabled for a specific set of people.
This set can be viewed/modified in Settings -> CI/CD -> Protected environments.

#### Immediate changes post release
After the release is created future builds of the documentation should include the new version in the version picker.
Therefore the stage `build_older_docs` in [`.gitlab-ci.yml`](.gitlab-ci.yml) needs to be extended by the new version.

#### Summary
- [ ] Prepare release
    - [ ] Collect list which Octopus versions will be supported
    - [ ] Extend `tests` in `.gitlab-ci.yml`
    - [ ] Extend `Version support` in `README.md`
- [ ] Create and push tag
- [ ] Extend `build_older_docs` in `.gitlab-ci.yml`


## MPCDF Repository syncronization
The MPCDF Binder only works with repositories hostet at
[MPCDF Gitlab](https://gitlab.mpcdf.mpg.de/).
Therefore the main branch is pushed from gitlab.com to the MPCDF Gitlab.
The syncronization should happen automatically every time the main branch changes (within 5 minutes as described in the [Gitlab documentation](https://docs.gitlab.com/ee/user/project/repository/mirror/push.html)).


To achieve this the MPCDF Repository is added in Settings -> Repository -> Mirroring repositories.
This requires an access token which was created with "Developer" Role in the MPCDF Gitlab (Settings -> Access Tokens).

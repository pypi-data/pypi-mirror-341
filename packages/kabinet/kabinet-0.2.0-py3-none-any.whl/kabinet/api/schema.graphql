directive @unionElementOf(union: String!, discriminator: String!, key: String!) on INPUT_OBJECT

"""Make string uppercase"""
directive @upper on FIELD

directive @replace(old: String!, new: String!) on FIELD

"""Make get stuff uppercase"""
directive @relation(on: String!) on FIELD

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar AnyDefault

"""A user of the bridge server. Maps to an authentikate user"""
type App {
  id: ID!
  identifier: String!
}

"""Create a new Github repository input"""
input AppImageInput {
  flavourName: String = null
  manifest: ManifestInput!
  selectors: [SelectorInput!]!
  appImageId: String!
  inspection: InspectionInput!
  image: DockerImageInput!
}

interface AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
}

input AssignWidgetInput {
  asParagraph: Boolean = null
  kind: AssignWidgetKind!
  query: SearchQuery = null
  choices: [ChoiceInput!] = null
  stateChoices: String = null
  followValue: String = null
  min: Float = null
  max: Float = null
  step: Float = null
  placeholder: String = null
  hook: String = null
  ward: String = null
  fallback: AssignWidgetInput = null
  filters: [ChildPortInput!] = null
  dependencies: [String!] = null
}

enum AssignWidgetKind {
  SEARCH
  CHOICE
  SLIDER
  CUSTOM
  STRING
  STATE_CHOICE
}

"""A user of the bridge server. Maps to an authentikate user"""
type Backend {
  id: ID!
  user: User!
  client: Client!
  name: String!
  kind: String!
  pods(filters: PodFilter, pagination: OffsetPaginationInput): [Pod!]!
  resources(filters: ResourceFilter, pagination: OffsetPaginationInput): [Resource!]!
  instanceId: String!
  clientId: String!
}

"""Filter for Resources"""
input BackendFilter {
  ids: [ID!] = null
  search: String = null
  AND: BackendFilter
  OR: BackendFilter
  NOT: BackendFilter
}

input BindsInput {
  templates: [String!] = null
  clients: [String!] = null
  desiredInstances: Int! = 1
}

""" A selector is a way to select a release"""
type CPUSelector implements Selector {
  kind: String!
  required: Boolean!
  min: Int
  frequency: Float
}

type ChildPort {
  key: String!
  label: String
  scope: PortScope!
  kind: PortKind!
  description: String
  identifier: Identifier
  nullable: Boolean!
  default: AnyDefault
  children: [ChildPort!]
  assignWidget: AssignWidget
  returnWidget: ReturnWidget
}

input ChildPortInput {
  default: AnyDefault = null
  key: String!
  label: String = null
  kind: PortKind!
  scope: PortScope!
  description: String = null
  identifier: Identifier = null
  nullable: Boolean!
  children: [ChildPortInput!] = null
  effects: [EffectInput!] = null
  assignWidget: AssignWidgetInput = null
  returnWidget: ReturnWidgetInput = null
}

type Choice {
  label: String!
  value: String!
  image: String
  description: String
}

type ChoiceAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  choices: [Choice!]
}

input ChoiceInput {
  value: AnyDefault!
  label: String!
  image: String = null
  description: String = null
}

type ChoiceReturnWidget implements ReturnWidget {
  kind: ReturnWidgetKind!
  choices: [Choice!]
}

"""A user of the bridge server. Maps to an authentikate user"""
type Client {
  id: ID!
  identifier: String!
}

"""A user of the bridge server. Maps to an authentikate user"""
type Collection {
  id: ID!

  """The name of this Collection"""
  name: String!

  """A description for the Collection"""
  description: String!
  definedAt: DateTime!
}

"""The state of a dask cluster"""
enum ContainerType {
  APPTAINER
  DOCKER
}

input CpuSelectorInput {
  """The frequency in MHz"""
  frequency: Int

  """The memory in MB"""
  memory: Int
}

"""Create a new Github repository input"""
input CreateDeploymentInput {
  instanceId: String!
  localId: ID!
  flavour: ID!
  lastPulled: DateTime = null
  secretParams: UntypedParams = null
}

"""Create a new Github repository input"""
input CreateGithubRepoInput {
  name: String = null
  user: String = null
  branch: String = null
  repo: String = null
  identifier: String = null
  autoScan: Boolean = true
}

"""Create a new Github repository input"""
input CreatePodInput {
  deployment: ID!
  localId: ID!
  resource: ID = null
  instanceId: String!
  clientId: String = null
}

""" A selector is a way to select a release"""
type CudaSelector implements Selector {
  kind: String!
  required: Boolean!

  """The number of cuda cores"""
  cudaCores: Int

  """The minimum cuda version"""
  cudaVersion: String
}

input CudaSelectorInput {
  """The minimum cuda version"""
  cudaVersion: String = null

  """The cuda cores"""
  cudaCores: Int = null
}

type CustomAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  hook: String!
  ward: String!
}

type CustomEffect implements Effect {
  dependencies: [String!]!
  kind: EffectKind!
  function: ValidatorFunction!
  hook: String!
  ward: String!
}

type CustomReturnWidget implements ReturnWidget {
  kind: ReturnWidgetKind!
  hook: String!
  ward: String!
}

"""Date with time (isoformat)"""
scalar DateTime

"""Create a new Github repository input"""
input DeclareBackendInput {
  instanceId: String!
  name: String!
  kind: String!
}

"""Create a resource"""
input DeclareResourceInput {
  backend: ID!
  name: String
  localId: String!
  qualifiers: [QualifierInput!] = null
}

"""
Nodes are abstraction of RPC Tasks. They provide a common API to deal with creating tasks.

See online Documentation
"""
type Definition {
  id: ID!

  """The hash of the Node (completely unique)"""
  hash: NodeHash!

  """The cleartext name of this Node"""
  name: String!

  """The kind of this Node. e.g. is it a function or a generator?"""
  kind: NodeKind!

  """A description for the Node"""
  description: String

  """The collections this Node belongs to"""
  collections: [Collection!]!

  """The flavours this Definition belongs to"""
  flavours(filters: FlavourFilter, pagination: OffsetPaginationInput): [Flavour!]!

  """
  The scope of this Node. e.g. does the data it needs or produce live only in the scope of this Node or is it global or does it bridge data?
  """
  scope: NodeScope!

  """The users that have pinned the position"""
  isTestFor(filters: DefinitionFilter, order: DefinitionOrder, pagination: OffsetPaginationInput): [Definition!]!

  """The users that have pinned the position"""
  tests(filters: DefinitionFilter, order: DefinitionOrder, pagination: OffsetPaginationInput): [Definition!]!

  """The protocols this Node implements (e.g. Predicate)"""
  protocols: [Protocol!]!
  definedAt: DateTime!

  """Inputs for this Node"""
  args: [Port!]!

  """Outputs for this Node"""
  returns: [Port!]!
}

"""Filter for Dask Clusters"""
input DefinitionFilter {
  ids: [ID!] = null
  search: String = null
  demands: [PortDemandInput!]
  AND: DefinitionFilter
  OR: DefinitionFilter
  NOT: DefinitionFilter
}

input DefinitionInput {
  description: String = null
  collections: [String!]! = []
  name: String!
  stateful: Boolean! = false
  portGroups: [PortGroupInput!]! = []
  args: [PortInput!]! = []
  returns: [PortInput!]! = []
  kind: NodeKind!
  isTestFor: [String!]! = []
  interfaces: [String!]! = []
  isDev: Boolean! = false
}

input DefinitionOrder {
  definedAt: Ordering
}

input DeletePodInput {
  id: ID!
}

enum DemandKind {
  ARGS
  RETURNS
}

input DependencyInput {
  hash: NodeHash
  reference: String = null
  binds: BindsInput = null
  optional: Boolean! = false
  viableInstances: Int = null
}

"""A user of the bridge server. Maps to an authentikate user"""
type Deployment {
  id: ID!
  flavour: Flavour!
  apiToken: String!
  backend: Backend!
  localId: ID!
  name: String!
}

"""Filter for Dask Clusters"""
input DeploymentFilter {
  ids: [ID!] = null
  search: String = null
  AND: DeploymentFilter
  OR: DeploymentFilter
  NOT: DeploymentFilter
}

"""The Feature you are trying to match"""
input DeviceFeature {
  kind: String!
  cpuCount: String!
}

"""A docker image descriptor"""
type DockerImage {
  imageString: String!
  buildAt: DateTime!
}

input DockerImageInput {
  imageString: String!
  buildAt: DateTime!
}

"""Create a new Github repository input"""
input DumpLogsInput {
  pod: ID!
  logs: String!
}

interface Effect {
  dependencies: [String!]!
  kind: EffectKind!
  function: ValidatorFunction!
}

input EffectInput {
  function: ValidatorFunction!
  dependencies: [String!]! = []
  message: String = null
  kind: EffectKind!
  hook: String = null
  ward: String = null
}

enum EffectKind {
  MESSAGE
  HIDE
  CUSTOM
}

"""Which environment do you want to match against?"""
input EnvironmentInput {
  features: [DeviceFeature!]
  containerType: ContainerType!
}

"""A user of the bridge server. Maps to an authentikate user"""
type Flavour {
  id: ID!
  name: String!
  description: String!
  logo: String
  image: DockerImage!
  originalLogo: String
  entrypoint: CudaSelector!
  release: Release!
  deployments(filters: DeploymentFilter, pagination: OffsetPaginationInput): [Deployment!]!

  """The flavours this Definition belongs to"""
  definitions(filters: DefinitionFilter, order: DefinitionOrder, pagination: OffsetPaginationInput): [Definition!]!
  manifest: UntypedParams!
  selectors: [Selector!]!
  requirements: [Requirement!]!
}

"""Filter for Dask Clusters"""
input FlavourFilter {
  ids: [ID!] = null
  search: String = null
  AND: FlavourFilter
  OR: FlavourFilter
  NOT: FlavourFilter
}

"""A user of the bridge server. Maps to an authentikate user"""
type GithubRepo {
  id: ID!
  name: String!
  repo: String!
  branch: String!
  user: String!
  flavours(filters: FlavourFilter, pagination: OffsetPaginationInput): [Flavour!]!
}

"""Filter for Dask Clusters"""
input GithubRepoFilter {
  ids: [ID!] = null
  search: String = null
  AND: GithubRepoFilter
  OR: GithubRepoFilter
  NOT: GithubRepoFilter
}

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar Identifier

input InspectionInput {
  size: Int
  templates: [TemplateInput!]!
  requirements: [RequirementInput!]!
}

"""The logs of a pod"""
type LogDump {
  id: ID!
  pod: Pod!
  logs: String!
  createdAt: DateTime!
}

input ManifestInput {
  """The entrypoint of the app, defaults to 'app'"""
  entrypoint: String
  identifier: String!
  version: String!
  author: String! = "unknown"
  logo: String = null
  scopes: [String!]!
}

"""Create a new Github repository input"""
input MatchFlavoursInput {
  environment: EnvironmentInput = null
  release: ID = null
  nodes: [NodeHash!] = null
}

type MessageEffect implements Effect {
  dependencies: [String!]!
  kind: EffectKind!
  function: ValidatorFunction!
  message: String!
}

type Mutation {
  """Create a new dask cluster on a bridge server"""
  scanRepo(input: ScanRepoInput!): GithubRepo!

  """Rescan all repos"""
  rescanRepos: [GithubRepo!]!

  """Create a new release"""
  createAppImage(input: AppImageInput!): Release!

  """Create a new Github repository on a bridge server"""
  createGithubRepo(input: CreateGithubRepoInput!): GithubRepo!

  """Create a new dask cluster on a bridge server"""
  createDeployment(input: CreateDeploymentInput!): Deployment!

  """Create a new dask cluster on a bridge server"""
  updateDeployment(input: UpdateDeploymentInput!): Deployment!

  """Create a new dask cluster on a bridge server"""
  createPod(input: CreatePodInput!): Pod!

  """Create a new dask cluster on a bridge server"""
  updatePod(input: UpdatePodInput!): Pod!

  """Create a new dask cluster on a bridge server"""
  dumpLogs(input: DumpLogsInput!): LogDump!

  """Create a new dask cluster on a bridge server"""
  declareBackend(input: DeclareBackendInput!): Backend!

  """Create a new resource for your backend"""
  declareResource(input: DeclareResourceInput!): Resource!

  """Create a new dask cluster on a bridge server"""
  deletePod(input: DeletePodInput!): ID!
}

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar NodeHash

enum NodeKind {
  FUNCTION
  GENERATOR
}

enum NodeScope {
  GLOBAL
  LOCAL
  BRIDGE_GLOBAL_TO_LOCAL
  BRIDGE_LOCAL_TO_GLOBAL
}

input OffsetPaginationInput {
  offset: Int! = 0
  limit: Int! = -1
}

input OneApiSelectorInput {
  """The api versison of the selector"""
  oneapiVersion: String = null
}

enum Ordering {
  ASC
  DESC
}

"""A user of the bridge server. Maps to an authentikate user"""
type Pod {
  id: ID!
  resource: Resource
  backend: Backend!
  deployment: Deployment!
  latestLogDump: LogDump
  podId: String!
  clientId: String
  status: PodStatus!
  name: String!
}

"""Filter for Dask Clusters"""
input PodFilter {
  ids: [ID!] = null
  search: String = null
  backend: ID = null
  AND: PodFilter
  OR: PodFilter
  NOT: PodFilter
}

"""The state of a dask cluster"""
enum PodStatus {
  PENDING
  RUNNING
  STOPPING
  STOPPED
  FAILED
  UNKOWN
}

"""An update on a pod"""
type PodUpdateMessage {
  id: String!
  status: String!
  created: Boolean!
  progress: Int
}

type Port {
  key: String!
  scope: PortScope!
  label: String
  kind: PortKind!
  description: String
  identifier: Identifier
  nullable: Boolean!
  effects: [Effect!]
  default: AnyDefault
  children: [ChildPort!]
  assignWidget: AssignWidget
  returnWidget: ReturnWidget
  validators: [Validator!]
}

input PortDemandInput {
  kind: DemandKind!
  matches: [PortMatchInput!] = null
  forceLength: Int = null
  forceNonNullableLength: Int = null
}

input PortGroupInput {
  key: String!
  title: String
  description: String
  effects: [EffectInput!] = []
  ports: [String!] = []
}

input PortInput {
  validators: [ValidatorInput!] = null
  key: String!
  scope: PortScope!
  label: String = null
  kind: PortKind!
  description: String = null
  identifier: String = null
  nullable: Boolean! = false
  effects: [EffectInput!] = null
  default: AnyDefault = null
  children: [ChildPortInput!] = null
  assignWidget: AssignWidgetInput = null
  returnWidget: ReturnWidgetInput = null
}

enum PortKind {
  INT
  STRING
  STRUCTURE
  LIST
  BOOL
  DICT
  FLOAT
  DATE
  UNION
  MODEL
}

input PortMatchInput {
  at: Int = null
  key: String = null
  kind: PortKind = null
  identifier: String = null
  nullable: Boolean = null
  children: [PortMatchInput!] = null
}

enum PortScope {
  GLOBAL
  LOCAL
}

"""A user of the bridge server. Maps to an authentikate user"""
type Protocol {
  id: ID!

  """The name of this Protocol"""
  name: String!

  """A description for the Protocol"""
  description: String!
}

"""A qualifier that describes some property of the node"""
input QualifierInput {
  key: String!
  value: String!
}

type Query {
  """Return all dask clusters"""
  githubRepo(id: ID!): GithubRepo!

  """Return all dask clusters"""
  definition(id: ID = null, hash: NodeHash = null): Definition!

  """Return all dask clusters"""
  release(id: ID!): Release!

  """Return all dask clusters"""
  resource(id: ID!): Resource!

  """Return all dask clusters"""
  flavour(id: ID!): Flavour!

  """Return all dask clusters"""
  deployment(id: ID!): Deployment!

  """Return all dask clusters"""
  backend(id: ID!): Backend!

  """Return all dask clusters"""
  pod(id: ID!): Pod!

  """Return the currently logged in user"""
  me: User!

  """Return the currently logged in user"""
  matchFlavour(input: MatchFlavoursInput!): Flavour!
  flavours(filters: FlavourFilter, pagination: OffsetPaginationInput): [Flavour!]!
  releases(filters: ReleaseFilter, pagination: OffsetPaginationInput): [Release!]!
  resources(filters: ResourceFilter, pagination: OffsetPaginationInput): [Resource!]!
  deployments(filters: DeploymentFilter, pagination: OffsetPaginationInput): [Deployment!]!
  githubRepos(filters: GithubRepoFilter, pagination: OffsetPaginationInput): [GithubRepo!]!
  definitions(filters: DefinitionFilter, order: DefinitionOrder, pagination: OffsetPaginationInput): [Definition!]!
  pods(filters: PodFilter, pagination: OffsetPaginationInput): [Pod!]!
  backends(filters: BackendFilter, pagination: OffsetPaginationInput): [Backend!]!

  """Return the pod for an agent"""
  podForAgent(clientId: ID!, instanceId: ID!): Pod
}

"""A user of the bridge server. Maps to an authentikate user"""
type Release {
  id: ID!
  version: String!
  app: App!
  scopes: [String!]!
  logo: String

  """The original logo url"""
  originalLogo: String
  entrypoint: String!
  flavours(filters: FlavourFilter, pagination: OffsetPaginationInput): [Flavour!]!

  """Is this release deployed"""
  installed: Boolean!

  """Is this release deployed"""
  deployments: [Deployment!]!

  """Is this release deployed"""
  description: String!

  """Is this release deployed"""
  colour: String!

  """Is this release deployed"""
  name: String!
}

"""Filter for Dask Clusters"""
input ReleaseFilter {
  ids: [ID!] = null
  search: String = null
  AND: ReleaseFilter
  OR: ReleaseFilter
  NOT: ReleaseFilter
}

"""A requirement"""
type Requirement {
  key: String!
  service: String!
  description: String
  optional: Boolean!
}

input RequirementInput {
  key: String!
  service: String!
  optional: Boolean! = false
  description: String = null
}

"""
A resource on a backend. Resource define allocated resources on a backend. E.g a computational node
"""
type Resource {
  id: ID!
  backend: Backend!
  resourceId: String!
  name: String!
  pods(filters: PodFilter, pagination: OffsetPaginationInput): [Pod!]!
  qualifiers: UntypedParams
}

"""Filter for Resources"""
input ResourceFilter {
  ids: [ID!] = null
  search: String = null
  AND: ResourceFilter
  OR: ResourceFilter
  NOT: ResourceFilter
}

interface ReturnWidget {
  kind: ReturnWidgetKind!
}

input ReturnWidgetInput {
  kind: ReturnWidgetKind!
  query: SearchQuery = null
  choices: [ChoiceInput!] = null
  min: Int = null
  max: Int = null
  step: Int = null
  placeholder: String = null
  hook: String = null
  ward: String = null
}

enum ReturnWidgetKind {
  CHOICE
  CUSTOM
}

""" A selector is a way to select a release"""
type RocmSelector implements Selector {
  kind: String!
  required: Boolean!
  apiThing: String
  apiVersion: String
}

input RocmSelectorInput {
  """The api version of the selector"""
  apiVersion: String = null

  """The api thing of the selector"""
  apiThing: String = null
}

"""Create a dask cluster input"""
input ScanRepoInput {
  id: String!
}

type SearchAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  query: String!
  ward: String!
  filters: [ChildPort!]
  dependencies: [String!]
}

"""
The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
"""
scalar SearchQuery

""" A selector is a way to select a release"""
interface Selector {
  kind: String!
  required: Boolean!
}

input SelectorInput {
  """The kind of the selector"""
  kind: String!

  """The api version of the selector"""
  apiVersion: String = null

  """The api thing of the selector"""
  apiThing: String = null

  """The api version of the selector"""
  oneapiVersion: String = null

  """The cuda cores"""
  cudaCores: Int = null

  """The frequency in MHz"""
  frequency: Int = null

  """The memory in MB"""
  memory: Int = null
}

type SliderAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  min: Float
  max: Float
  step: Float
}

type StateChoiceAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  stateChoices: String!
}

type StringAssignWidget implements AssignWidget {
  kind: AssignWidgetKind!
  followValue: String
  placeholder: String!
  asParagraph: Boolean!
}

type Subscription {
  """Create a new dask cluster on a bridge server"""
  pod(podId: ID!): PodUpdateMessage!

  """Create a new dask cluster on a bridge server"""
  pods: PodUpdateMessage!
}

input TemplateInput {
  definition: DefinitionInput!
  dependencies: [DependencyInput!]!
  interface: String!
  params: AnyDefault = null
  dynamic: Boolean! = false
  logo: String = null
}

"""
UntypedParams represents an untyped options object returned by the Dask Gateway API.
"""
scalar UntypedParams

"""Create a new Github repository input"""
input UpdateDeploymentInput {
  deployment: ID!
  status: PodStatus!
}

"""Create a new Github repository input"""
input UpdatePodInput {
  pod: ID = null
  localId: ID = null
  status: PodStatus!
  instanceId: String!
}

"""A user of the bridge server. Maps to an authentikate user"""
type User {
  id: ID!
  sub: String!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  email: String!
  password: String!
}

type Validator {
  function: ValidatorFunction!
  dependencies: [String!]
  label: String
  errorMessage: String
}

"\n    The `Validator` scalar represents a javascript function that should execute on the client side (inside a shadow realm)\n      to validate a value (or a set of values) before it is sent to the server.  The function has two parameters (value, otherValues) and should return a string if the value is invalid and undefined if the value is valid.\n        The otherValues parameter is an object with the other values in the form {fieldName: value}."
scalar ValidatorFunction

input ValidatorInput {
  function: ValidatorFunction!
  dependencies: [String!] = []
  label: String = null
  errorMessage: String = null
}
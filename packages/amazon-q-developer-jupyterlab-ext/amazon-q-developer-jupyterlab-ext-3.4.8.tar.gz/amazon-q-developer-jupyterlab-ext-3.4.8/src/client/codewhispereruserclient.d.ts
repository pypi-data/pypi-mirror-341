
/**
 * THIS FILE IS AUTOGENERATED BY 'generateServiceClient.ts'.
 * DO NOT EDIT BY HAND.
 */

import {Request} from 'aws-sdk/lib/request';
import {Response} from 'aws-sdk/lib/response';
import {AWSError} from 'aws-sdk/lib/error';
import {Service} from 'aws-sdk/lib/service';
import {ServiceConfigurationOptions} from 'aws-sdk/lib/service';
import {ConfigBase as Config} from 'aws-sdk/lib/config-base';
interface Blob {}
declare class CodeWhispererUserClient extends Service {
  /**
   * Constructs a service object. This object has one method for each API operation.
   */
  constructor(options?: CodeWhispererUserClient.Types.ClientConfiguration)
  config: Config & CodeWhispererUserClient.Types.ClientConfiguration;
  /**
   * 
   */
  createArtifactUploadUrl(params: CodeWhispererUserClient.Types.CreateUploadUrlRequest, callback?: (err: AWSError, data: CodeWhispererUserClient.Types.CreateUploadUrlResponse) => void): Request<CodeWhispererUserClient.Types.CreateUploadUrlResponse, AWSError>;
  /**
   * 
   */
  createArtifactUploadUrl(callback?: (err: AWSError, data: CodeWhispererUserClient.Types.CreateUploadUrlResponse) => void): Request<CodeWhispererUserClient.Types.CreateUploadUrlResponse, AWSError>;
  /**
   * 
   */
  generateCompletions(params: CodeWhispererUserClient.Types.GenerateCompletionsRequest, callback?: (err: AWSError, data: CodeWhispererUserClient.Types.GenerateCompletionsResponse) => void): Request<CodeWhispererUserClient.Types.GenerateCompletionsResponse, AWSError>;
  /**
   * 
   */
  generateCompletions(callback?: (err: AWSError, data: CodeWhispererUserClient.Types.GenerateCompletionsResponse) => void): Request<CodeWhispererUserClient.Types.GenerateCompletionsResponse, AWSError>;
  /**
   * 
   */
  getCodeAnalysis(params: CodeWhispererUserClient.Types.GetCodeAnalysisRequest, callback?: (err: AWSError, data: CodeWhispererUserClient.Types.GetCodeAnalysisResponse) => void): Request<CodeWhispererUserClient.Types.GetCodeAnalysisResponse, AWSError>;
  /**
   * 
   */
  getCodeAnalysis(callback?: (err: AWSError, data: CodeWhispererUserClient.Types.GetCodeAnalysisResponse) => void): Request<CodeWhispererUserClient.Types.GetCodeAnalysisResponse, AWSError>;
  /**
   * 
   */
  listCodeAnalysisFindings(params: CodeWhispererUserClient.Types.ListCodeAnalysisFindingsRequest, callback?: (err: AWSError, data: CodeWhispererUserClient.Types.ListCodeAnalysisFindingsResponse) => void): Request<CodeWhispererUserClient.Types.ListCodeAnalysisFindingsResponse, AWSError>;
  /**
   * 
   */
  listCodeAnalysisFindings(callback?: (err: AWSError, data: CodeWhispererUserClient.Types.ListCodeAnalysisFindingsResponse) => void): Request<CodeWhispererUserClient.Types.ListCodeAnalysisFindingsResponse, AWSError>;
  /**
   * 
   */
  startCodeAnalysis(params: CodeWhispererUserClient.Types.StartCodeAnalysisRequest, callback?: (err: AWSError, data: CodeWhispererUserClient.Types.StartCodeAnalysisResponse) => void): Request<CodeWhispererUserClient.Types.StartCodeAnalysisResponse, AWSError>;
  /**
   * 
   */
  startCodeAnalysis(callback?: (err: AWSError, data: CodeWhispererUserClient.Types.StartCodeAnalysisResponse) => void): Request<CodeWhispererUserClient.Types.StartCodeAnalysisResponse, AWSError>;
}
declare namespace CodeWhispererUserClient {
  export type ArtifactMap = {[key: string]: UploadId};
  export type ArtifactType = "SourceCode"|"BuiltJars"|string;
  export type CodeAnalysisFindingsSchema = "codeanalysis/findings/1.0"|string;
  export type CodeAnalysisStatus = "Completed"|"Pending"|"Failed"|string;
  export interface Completion {
    content: CompletionContentString;
    references?: References;
  }
  export type CompletionContentString = string;
  export type Completions = Completion[];
  export interface CreateUploadUrlRequest {
    contentMd5: CreateUploadUrlRequestContentMd5String;
    artifactType: ArtifactType;
  }
  export type CreateUploadUrlRequestContentMd5String = string;
  export interface CreateUploadUrlResponse {
    uploadId: UploadId;
    uploadUrl: PreSignedUrl;
  }
  export interface FileContext {
    leftFileContent: FileContextLeftFileContentString;
    rightFileContent: FileContextRightFileContentString;
    filename: FileContextFilenameString;
    programmingLanguage: ProgrammingLanguage;
  }
  export type FileContextFilenameString = string;
  export type FileContextLeftFileContentString = string;
  export type FileContextRightFileContentString = string;
  export interface GenerateCompletionsRequest {
    fileContext: FileContext;
    maxResults?: GenerateCompletionsRequestMaxResultsInteger;
    nextToken?: GenerateCompletionsRequestNextTokenString;
    referenceTrackerConfiguration?: ReferenceTrackerConfiguration;
  }
  export type GenerateCompletionsRequestMaxResultsInteger = number;
  export type GenerateCompletionsRequestNextTokenString = string;
  export interface GenerateCompletionsResponse {
    completions?: Completions;
    nextToken?: String;
  }
  export interface GetCodeAnalysisRequest {
    jobId: GetCodeAnalysisRequestJobIdString;
  }
  export type GetCodeAnalysisRequestJobIdString = string;
  export interface GetCodeAnalysisResponse {
    status: CodeAnalysisStatus;
    errorMessage?: String;
  }
  export interface ListCodeAnalysisFindingsRequest {
    jobId: ListCodeAnalysisFindingsRequestJobIdString;
    nextToken?: PaginationToken;
    codeAnalysisFindingsSchema: CodeAnalysisFindingsSchema;
  }
  export type ListCodeAnalysisFindingsRequestJobIdString = string;
  export interface ListCodeAnalysisFindingsResponse {
    nextToken?: PaginationToken;
    codeAnalysisFindings: String;
  }
  export type PaginationToken = string;
  export type PreSignedUrl = string;
  export interface ProgrammingLanguage {
    languageName: ProgrammingLanguageLanguageNameString;
  }
  export type ProgrammingLanguageLanguageNameString = string;
  export type RecommendationsWithReferencesPreference = "BLOCK"|"ALLOW"|string;
  export interface Reference {
    licenseName?: ReferenceLicenseNameString;
    repository?: ReferenceRepositoryString;
    url?: ReferenceUrlString;
    recommendationContentSpan?: Span;
  }
  export type ReferenceLicenseNameString = string;
  export type ReferenceRepositoryString = string;
  export interface ReferenceTrackerConfiguration {
    recommendationsWithReferences: RecommendationsWithReferencesPreference;
  }
  export type ReferenceUrlString = string;
  export type References = Reference[];
  export interface Span {
    start?: SpanStartInteger;
    end?: SpanEndInteger;
  }
  export type SpanEndInteger = number;
  export type SpanStartInteger = number;
  export interface StartCodeAnalysisRequest {
    artifacts: ArtifactMap;
    programmingLanguage: ProgrammingLanguage;
    clientToken?: StartCodeAnalysisRequestClientTokenString;
  }
  export type StartCodeAnalysisRequestClientTokenString = string;
  export interface StartCodeAnalysisResponse {
    jobId: StartCodeAnalysisResponseJobIdString;
    status: CodeAnalysisStatus;
    errorMessage?: String;
  }
  export type StartCodeAnalysisResponseJobIdString = string;
  export type String = string;
  export type UploadId = string;
  /**
   * A string in YYYY-MM-DD format that represents the latest possible API version that can be used in this service. Specify 'latest' to use the latest possible version.
   */
  export type apiVersion = "2022-11-11"|"latest"|string;
  export interface ClientApiVersions {
    /**
     * A string in YYYY-MM-DD format that represents the latest possible API version that can be used in this service. Specify 'latest' to use the latest possible version.
     */
    apiVersion?: apiVersion;
  }
  export type ClientConfiguration = ServiceConfigurationOptions & ClientApiVersions;
  /**
   * Contains interfaces for use with the CodeWhispererUserClient client.
   */
  export import Types = CodeWhispererUserClient;
}
export = CodeWhispererUserClient;

    
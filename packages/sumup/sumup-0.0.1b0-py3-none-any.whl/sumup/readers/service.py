# Code generated by `py-sdk-gen`. DO NOT EDIT.
from .._service import Service, AsyncService
from .types import (
    ReaderId,
    Meta,
    ReaderName,
    Reader,
    ReaderPairingCode,
    CreateReaderCheckoutAmount,
    Affiliate,
)
import typing
import pydantic


class CreateReaderBody(pydantic.BaseModel):
    """
    CreateReaderBody is a schema definition.
    """

    pairing_code: ReaderPairingCode
    """
	The pairing code is a 8 or 9 character alphanumeric string that is displayed on a SumUp Device after initiatingthe pairing. It is used to link the physical device to the created pairing.
	Min length: 8
	Max length: 9
	"""

    meta: typing.Optional[Meta] = None
    """
	Set of user-defined key-value pairs attached to the object.
	Max properties: 50
	"""

    name: typing.Optional[ReaderName] = None
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""


type CreateReaderCheckoutBodyCardType = typing.Literal["credit", "debit"]


class CreateReaderCheckoutBody(pydantic.BaseModel):
    """
    CreateReaderCheckoutBody: Reader Checkout
    """

    total_amount: CreateReaderCheckoutAmount
    """
	Amount of the transaction.
	The amount is represented as an integer value altogether with the currency and the minor unit.
	For example, EUR 1.00 is represented as value 100 with minor unit of 2.
	"""

    affiliate: typing.Optional[Affiliate] = None
    """
	Affiliate metadata for the transaction.
	It is an optional field that allow for integrators to track the source of the transaction.
	"""

    card_type: typing.Optional[CreateReaderCheckoutBodyCardType] = None
    """
	The card type of the card used for the transaction.
	Is is required only for some countries (e.g: Brazil).
	"""

    description: typing.Optional[str] = None
    """
	Description of the checkout to be shown in the Merchant Sales
	"""

    installments: typing.Optional[int] = None
    """
	Number of installments for the transaction.
	It may vary according to the merchant country.
	For example, in Brazil, the maximum number of installments is 12.
	"""

    return_url: typing.Optional[str] = None
    """
	Webhook URL to which the payment result will be sent.
	It must be a HTTPS url.
	Format: uri
	"""

    tip_rates: typing.Optional[typing.List[float]] = None
    """
	List of tipping rates to be displayed to the cardholder.
	The rates are in percentage and should be between 0.01 and 0.99.
	The list should be sorted in ascending order.
	"""


class UpdateReaderBody(pydantic.BaseModel):
    """
    UpdateReaderBody is a schema definition.
    """

    meta: typing.Optional[Meta] = None
    """
	Set of user-defined key-value pairs attached to the object.
	Max properties: 50
	"""

    name: typing.Optional[ReaderName] = None
    """
	Custom human-readable, user-defined name for easier identification of the reader.
	Max length: 500
	"""


class ListReaders200Response(pydantic.BaseModel):
    """
    ListReaders200Response is a schema definition.
    """

    items: typing.List[Reader]


type CreateReaderTerminate422ResponseErrors = typing.Dict[typing.Any, typing.Any]
"""
CreateReaderTerminate422ResponseErrors is a schema definition.
"""


class CreateReaderTerminate422Response(pydantic.BaseModel):
    """
    CreateReaderTerminate422Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderTerminate422ResponseErrors] = None


class CreateReaderTerminate500ResponseErrors(pydantic.BaseModel):
    """
    CreateReaderTerminate500ResponseErrors is a schema definition.
    """

    detail: typing.Optional[str] = None


class CreateReaderTerminate500Response(pydantic.BaseModel):
    """
    CreateReaderTerminate500Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderTerminate500ResponseErrors] = None


class CreateReaderTerminate502ResponseErrors(pydantic.BaseModel):
    """
    CreateReaderTerminate502ResponseErrors is a schema definition.
    """

    detail: typing.Optional[str] = None


class CreateReaderTerminate502Response(pydantic.BaseModel):
    """
    CreateReaderTerminate502Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderTerminate502ResponseErrors] = None


class CreateReaderTerminate504ResponseErrors(pydantic.BaseModel):
    """
    CreateReaderTerminate504ResponseErrors is a schema definition.
    """

    detail: typing.Optional[str] = None


class CreateReaderTerminate504Response(pydantic.BaseModel):
    """
    CreateReaderTerminate504Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderTerminate504ResponseErrors] = None


class CreateReaderCheckout201ResponseData(pydantic.BaseModel):
    """
    CreateReaderCheckout201ResponseData is a schema definition.
    """

    client_transaction_id: typing.Optional[str] = None
    """
	The client transaction ID is a unique identifier for the transaction that is generated for the client.
	It can be used later to fetch the transaction details via the [Transactions API](https://developer.sumup.com/api/transactions/get).
	Format: uuid
	"""


class CreateReaderCheckout201Response(pydantic.BaseModel):
    """
    CreateReaderCheckout201Response is a schema definition.
    """

    data: typing.Optional[CreateReaderCheckout201ResponseData] = None


class CreateReaderCheckout400ResponseErrors(pydantic.BaseModel):
    """
    CreateReaderCheckout400ResponseErrors is a schema definition.
    """

    detail: typing.Optional[str] = None


class CreateReaderCheckout400Response(pydantic.BaseModel):
    """
    CreateReaderCheckout400Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderCheckout400ResponseErrors] = None


type CreateReaderCheckout422ResponseErrors = typing.Dict[typing.Any, typing.Any]
"""
CreateReaderCheckout422ResponseErrors is a schema definition.
"""


class CreateReaderCheckout422Response(pydantic.BaseModel):
    """
    CreateReaderCheckout422Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderCheckout422ResponseErrors] = None


class CreateReaderCheckout500ResponseErrors(pydantic.BaseModel):
    """
    CreateReaderCheckout500ResponseErrors is a schema definition.
    """

    detail: typing.Optional[str] = None


class CreateReaderCheckout500Response(pydantic.BaseModel):
    """
    CreateReaderCheckout500Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderCheckout500ResponseErrors] = None


class CreateReaderCheckout502ResponseErrors(pydantic.BaseModel):
    """
    CreateReaderCheckout502ResponseErrors is a schema definition.
    """

    detail: typing.Optional[str] = None


class CreateReaderCheckout502Response(pydantic.BaseModel):
    """
    CreateReaderCheckout502Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderCheckout502ResponseErrors] = None


class CreateReaderCheckout504ResponseErrors(pydantic.BaseModel):
    """
    CreateReaderCheckout504ResponseErrors is a schema definition.
    """

    detail: typing.Optional[str] = None


class CreateReaderCheckout504Response(pydantic.BaseModel):
    """
    CreateReaderCheckout504Response is a schema definition.
    """

    errors: typing.Optional[CreateReaderCheckout504ResponseErrors] = None


class ReadersService(Service):
    def __init__(self, client):
        super().__init__(client)

    def list(self, merchant_code: str) -> ListReaders200Response:
        """
        list: List Readers
        List all readers of the merchant.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
        )
        return ListReaders200Response(**resp.json())

    def create(self, merchant_code: str, body: CreateReaderBody) -> Reader:
        """
        create: Create a Reader
        Create a new Reader for the merchant account.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body,
        )
        return Reader(**resp.json())

    def terminate_checkout(self, merchant_code: str, id: str):
        """
        terminate_checkout: Create a Reader Terminate action
        Create a Terminate action for a Reader.

        It stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.

        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/terminate",
        )

    def create_checkout(
        self, merchant_code: str, id: str, body: CreateReaderCheckoutBody
    ) -> CreateReaderCheckout201Response:
        """
        create_checkout: Create a Reader Checkout
        Create a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.

        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/checkout",
            json=body,
        )
        return CreateReaderCheckout201Response(**resp.json())

    def delete_reader(self, merchant_code: str, id: ReaderId):
        """
        delete_reader: Delete a reader
        Delete a reader.
        """
        self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
        )

    def get(self, merchant_code: str, id: ReaderId) -> Reader:
        """
        get: Retrieve a Reader
        Retrieve a Reader.
        """
        resp = self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
        )
        return Reader(**resp.json())

    def update(self, merchant_code: str, id: ReaderId, body: UpdateReaderBody):
        """
        update: Update a Reader
        Update a Reader.
        """
        self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body,
        )


class AsyncReadersService(AsyncService):
    def __init__(self, client):
        super().__init__(client)

    async def list(self, merchant_code: str) -> ListReaders200Response:
        """
        list: List Readers
        List all readers of the merchant.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers",
        )
        return ListReaders200Response(**resp.json())

    async def create(self, merchant_code: str, body: CreateReaderBody) -> Reader:
        """
        create: Create a Reader
        Create a new Reader for the merchant account.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers",
            json=body,
        )
        return Reader(**resp.json())

    async def terminate_checkout(self, merchant_code: str, id: str):
        """
        terminate_checkout: Create a Reader Terminate action
        Create a Terminate action for a Reader.

        It stops the current transaction on the target device.

        This process is asynchronous and the actual termination may take some time to be performed on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise terminate won't be accepted
        * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting forPIN, etc.
        * There is no confirmation of the termination.

        If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status willbe sent as `failed` to the provided URL.

        **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
        """
        await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/terminate",
        )

    async def create_checkout(
        self, merchant_code: str, id: str, body: CreateReaderCheckoutBody
    ) -> CreateReaderCheckout201Response:
        """
        create_checkout: Create a Reader Checkout
        Create a Checkout for a Reader.

        This process is asynchronous and the actual transaction may take some time to be stared on the device.


        There are some caveats when using this endpoint:
        * The target device must be online, otherwise checkout won't be accepted
        * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. Duringthis time, any other checkout for the same device will be rejected.

        **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
        """
        resp = await self._client.post(
            f"/v0.1/merchants/{merchant_code}/readers/{id}/checkout",
            json=body,
        )
        return CreateReaderCheckout201Response(**resp.json())

    async def delete_reader(self, merchant_code: str, id: ReaderId):
        """
        delete_reader: Delete a reader
        Delete a reader.
        """
        await self._client.delete(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
        )

    async def get(self, merchant_code: str, id: ReaderId) -> Reader:
        """
        get: Retrieve a Reader
        Retrieve a Reader.
        """
        resp = await self._client.get(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
        )
        return Reader(**resp.json())

    async def update(self, merchant_code: str, id: ReaderId, body: UpdateReaderBody):
        """
        update: Update a Reader
        Update a Reader.
        """
        await self._client.patch(
            f"/v0.1/merchants/{merchant_code}/readers/{id}",
            json=body,
        )

"""Tests for task storage operations."""

import pytest
import uuid  # For generating IDs
from pm.models import Project, Task, Subtask, Note  # Remove MetadataValue import
from pm.storage import init_db
# Needed to create projects for tasks
from pm.storage.project import create_project
from pm.storage.task import create_task, get_task, get_task_by_slug, list_tasks, delete_task, add_task_dependency, update_task
from pm.storage.subtask import create_subtask  # Need subtask creation
from pm.storage.note import create_note  # Need note creation
from pm.storage.metadata import update_task_metadata  # Correct function name
from pm.core.types import TaskStatus  # Import TaskStatus for tests


@pytest.fixture
def db_connection(tmp_path):
    """Fixture providing a clean database connection for each test."""
    db_path = tmp_path / "test.db"
    conn = init_db(str(db_path))  # Ensure db_path is string
    yield conn
    conn.close()


def test_task_creation_storage(db_connection):
    """Test creating and retrieving a task via storage functions."""
    # Setup: Create a project first
    project_data = Project(id="test-project-for-task",
                           name="Test Project for Task")
    create_project(db_connection, project_data)

    # Create the task
    # Note: Slug is now optional in model, generated by create_task
    task_data = Task(
        id="test-task-storage",
        project_id="test-project-for-task",
        name="Test Task Storage"
    )
    created_task = create_task(db_connection, task_data)
    assert created_task.id == "test-task-storage"
    assert created_task.project_id == "test-project-for-task"
    assert created_task.slug == "test-task-storage"  # Verify generated slug

    # Retrieve and verify
    retrieved_task = get_task(db_connection, "test-task-storage")
    assert retrieved_task.id == "test-task-storage"
    assert retrieved_task.project_id == "test-project-for-task"
    assert retrieved_task.slug == "test-task-storage"  # Verify slug on retrieval


def test_task_slug_storage(db_connection):
    """Test task slug generation, uniqueness (within project), and retrieval via storage."""
    # Create two projects
    proj_a_data = Project(id="proj-a", name="Project A")
    create_project(db_connection, proj_a_data)
    proj_b_data = Project(id="proj-b", name="Project B")
    create_project(db_connection, proj_b_data)

    # Create task 1 in Project A
    task1a_data = Task(id="task-1a", project_id="proj-a", name="My Task")
    task1a = create_task(db_connection, task1a_data)
    expected_slug1a = "my-task"
    assert task1a.slug == expected_slug1a

    # Retrieve task 1a by ID and check slug
    retrieved1a_by_id = get_task(db_connection, "task-1a")
    assert retrieved1a_by_id.slug == expected_slug1a

    # Retrieve task 1a by slug
    retrieved1a_by_slug = get_task_by_slug(
        db_connection, "proj-a", expected_slug1a)
    assert retrieved1a_by_slug.id == "task-1a"
    assert retrieved1a_by_slug.slug == expected_slug1a

    # Create task 2 in Project A with the same name (collision)
    task2a_data = Task(id="task-2a", project_id="proj-a", name="My Task")
    task2a = create_task(db_connection, task2a_data)
    expected_slug2a = "my-task-1"  # Expect collision handling within project
    assert task2a.slug == expected_slug2a

    # Retrieve task 2a by slug
    retrieved2a_by_slug = get_task_by_slug(
        db_connection, "proj-a", expected_slug2a)
    assert retrieved2a_by_slug.id == "task-2a"
    assert retrieved2a_by_slug.slug == expected_slug2a

    # Create task 3 in Project B with the same name (no collision expected)
    task3b_data = Task(id="task-3b", project_id="proj-b", name="My Task")
    task3b = create_task(db_connection, task3b_data)
    expected_slug3b = "my-task"  # Same name, different project
    assert task3b.slug == expected_slug3b

    # Retrieve task 3b by slug
    retrieved3b_by_slug = get_task_by_slug(
        db_connection, "proj-b", expected_slug3b)
    assert retrieved3b_by_slug.id == "task-3b"
    assert retrieved3b_by_slug.slug == expected_slug3b

    # Test listing tasks for Project A includes slugs
    tasks_a = list_tasks(db_connection, project_id="proj-a")
    task_map_a = {t.id: t for t in tasks_a}
    assert task_map_a["task-1a"].slug == expected_slug1a
    assert task_map_a["task-2a"].slug == expected_slug2a

    # Test listing tasks for Project B includes slugs
    tasks_b = list_tasks(db_connection, project_id="proj-b")
    assert len(tasks_b) == 1
    assert tasks_b[0].id == "task-3b"
    assert tasks_b[0].slug == expected_slug3b

    # Test retrieval by non-existent slug
    assert get_task_by_slug(db_connection, "proj-a",
                            "non-existent-slug") is None
    # Test retrieval by valid slug but wrong project
    # Use expected_slug2a ('my-task-1') which only exists in project A
    assert get_task_by_slug(db_connection, "proj-b", expected_slug2a) is None


def test_task_deletion_cascades(db_connection):
    """Test that deleting a task deletes associated subtasks, notes, metadata, and dependencies."""
    # 1. Setup Project and Tasks
    project_id = str(uuid.uuid4())
    project_data = Project(id=project_id, name="Project For Task Deletion")
    create_project(db_connection, project_data)

    task_id_to_delete = str(uuid.uuid4())
    task_to_delete_data = Task(
        id=task_id_to_delete, project_id=project_id, name="Task To Delete")
    create_task(db_connection, task_to_delete_data)

    dependency_task_id = str(uuid.uuid4())
    dependency_task_data = Task(
        id=dependency_task_id, project_id=project_id, name="Dependency Task")
    create_task(db_connection, dependency_task_data)

    # 2. Create Associated Data
    # Subtask
    subtask_id = str(uuid.uuid4())
    subtask_data = Subtask(
        id=subtask_id, task_id=task_id_to_delete, name="Subtask To Delete")
    create_subtask(db_connection, subtask_data)

    # Note
    note_id = str(uuid.uuid4())
    note_data = Note(id=note_id, entity_type='task',
                     entity_id=task_id_to_delete, content="Task note")
    create_note(db_connection, note_data)

    # Metadata
    metadata_key = "test_key"
    metadata_value = "test_value"  # Pass the raw value
    update_task_metadata(db_connection, task_id_to_delete,  # Use correct function name
                         metadata_key, metadata_value)  # Call with raw value

    # Dependency (task_to_delete depends on dependency_task)
    add_task_dependency(db_connection, task_id_to_delete, dependency_task_id)
    # Dependency (dependency_task depends on task_to_delete) - REMOVED to avoid circular dependency error
    # add_task_dependency(db_connection, dependency_task_id, task_id_to_delete)

    # Verify initial state
    assert get_task(db_connection, task_id_to_delete) is not None
    assert db_connection.execute(
        "SELECT COUNT(*) FROM subtasks WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 1
    assert db_connection.execute(
        "SELECT COUNT(*) FROM notes WHERE entity_type = 'task' AND entity_id = ?", (task_id_to_delete,)).fetchone()[0] == 1
    assert db_connection.execute(
        "SELECT COUNT(*) FROM task_metadata WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 1
    assert db_connection.execute("SELECT COUNT(*) FROM task_dependencies WHERE task_id = ? OR dependency_id = ?",
                                 # Only one dependency link now
                                 (task_id_to_delete, task_id_to_delete)).fetchone()[0] == 1

    # 3. Delete Task
    deleted = delete_task(db_connection, task_id_to_delete)
    assert deleted is True

    # 4. Verify deletion
    assert get_task(db_connection, task_id_to_delete) is None
    assert db_connection.execute(
        "SELECT COUNT(*) FROM subtasks WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 0
    assert db_connection.execute(
        "SELECT COUNT(*) FROM notes WHERE entity_type = 'task' AND entity_id = ?", (task_id_to_delete,)).fetchone()[0] == 0
    assert db_connection.execute(
        "SELECT COUNT(*) FROM task_metadata WHERE task_id = ?", (task_id_to_delete,)).fetchone()[0] == 0
    # Check dependencies involving the deleted task are gone
    assert db_connection.execute("SELECT COUNT(*) FROM task_dependencies WHERE task_id = ? OR dependency_id = ?",
                                 (task_id_to_delete, task_id_to_delete)).fetchone()[0] == 0
    # Ensure the other task still exists
    assert get_task(db_connection, dependency_task_id) is not None


@pytest.fixture
def setup_task_for_abandon_test(db_connection):
    """Fixture to set up a project and a task for abandon status tests."""
    project_id = str(uuid.uuid4())
    project_data = Project(id=project_id, name="Project For Abandon Test")
    create_project(db_connection, project_data)
    task_id = str(uuid.uuid4())
    task_data = Task(id=task_id, project_id=project_id, name="Task To Abandon")
    create_task(db_connection, task_data)  # Starts as NOT_STARTED
    return db_connection, task_id


@pytest.mark.parametrize("start_status", [
    TaskStatus.IN_PROGRESS,
    TaskStatus.PAUSED,
    TaskStatus.BLOCKED,
])
def test_task_status_valid_transitions_to_abandoned(setup_task_for_abandon_test, start_status):
    """Test valid transitions TO ABANDONED status."""
    db_connection, task_id = setup_task_for_abandon_test

    # Set the task to the starting status (via IN_PROGRESS if needed)
    if start_status != TaskStatus.IN_PROGRESS:
        update_task(db_connection, task_id, status=TaskStatus.IN_PROGRESS)
    update_task(db_connection, task_id, status=start_status)

    # Perform the transition to ABANDONED
    updated_task = update_task(
        db_connection, task_id, status=TaskStatus.ABANDONED)
    assert updated_task.status == TaskStatus.ABANDONED


@pytest.mark.parametrize("start_status", [
    TaskStatus.NOT_STARTED,
    TaskStatus.COMPLETED,
])
def test_task_status_invalid_transitions_to_abandoned(setup_task_for_abandon_test, start_status):
    """Test invalid transitions TO ABANDONED status."""
    db_connection, task_id = setup_task_for_abandon_test

    # Set the task to the starting status (via IN_PROGRESS if needed for COMPLETED)
    if start_status == TaskStatus.COMPLETED:
        update_task(db_connection, task_id, status=TaskStatus.IN_PROGRESS)
    update_task(db_connection, task_id, status=start_status)

    # Attempt the invalid transition
    with pytest.raises(ValueError, match="Invalid status transition"):
        update_task(db_connection, task_id, status=TaskStatus.ABANDONED)


@pytest.mark.parametrize("target_status", [
    TaskStatus.NOT_STARTED,
    TaskStatus.IN_PROGRESS,
    TaskStatus.BLOCKED,
    TaskStatus.PAUSED,
    TaskStatus.COMPLETED,
])
def test_task_status_invalid_transitions_from_abandoned(setup_task_for_abandon_test, target_status):
    """Test invalid transitions FROM ABANDONED status."""
    db_connection, task_id = setup_task_for_abandon_test

    # Set the task to ABANDONED first (via a valid path)
    update_task(db_connection, task_id, status=TaskStatus.IN_PROGRESS)
    update_task(db_connection, task_id, status=TaskStatus.ABANDONED)
    assert get_task(db_connection, task_id).status == TaskStatus.ABANDONED


def test_list_tasks_includes_note_count(db_connection):
    """Test that list_tasks correctly includes the note_count."""
    # 1. Create project
    project_id = str(uuid.uuid4())
    project_data = Project(
        id=project_id, name="Project For Task Note Count Test")
    create_project(db_connection, project_data)

    # 2. Create task 1 (no notes)
    task1_id = str(uuid.uuid4())
    task1_data = Task(id=task1_id, project_id=project_id,
                      name="Task With No Notes")
    create_task(db_connection, task1_data)

    # 3. Create task 2 (with one note)
    task2_id = str(uuid.uuid4())
    task2_data = Task(id=task2_id, project_id=project_id,
                      name="Task With One Note")
    create_task(db_connection, task2_data)
    note_data = Note(id=str(uuid.uuid4()), entity_type='task',
                     entity_id=task2_id, content="A note for task 2")
    create_note(db_connection, note_data)

    # 4. List tasks for the project
    tasks = list_tasks(db_connection, project_id=project_id)

    # 5. Verify note counts
    task_map = {t.id: t for t in tasks}
    assert task1_id in task_map
    assert task_map[task1_id].note_count == 0, f"Expected 0 notes for {task1_id}, got {task_map[task1_id].note_count}"

    assert task2_id in task_map
    assert task_map[task2_id].note_count == 1, f"Expected 1 note for {task2_id}, got {task_map[task2_id].note_count}"

from pulsar.exceptions import *
import _pulsar
from _pulsar import BatchReceivePolicy as BatchReceivePolicy, BatchingType as BatchingType, CompressionType as CompressionType, ConsumerType as ConsumerType, DeadLetterPolicyBuilder as DeadLetterPolicyBuilder, InitialPosition as InitialPosition, KeySharedMode as KeySharedMode, KeySharedPolicy as KeySharedPolicy, LoggerLevel as LoggerLevel, PartitionsRoutingMode as PartitionsRoutingMode, ProducerAccessMode as ProducerAccessMode, RegexSubscriptionMode as RegexSubscriptionMode, Result as Result
from _typeshed import Incomplete
from pulsar import schema as schema
from pulsar.__about__ import __version__ as __version__
from pulsar.functions.context import Context as Context
from pulsar.functions.function import Function as Function
from pulsar.functions.serde import IdentitySerDe as IdentitySerDe, PickleSerDe as PickleSerDe, SerDe as SerDe

class MessageId:
    def __init__(self, partition: int = -1, ledger_id: int = -1, entry_id: int = -1, batch_index: int = -1) -> None: ...
    earliest: Incomplete
    latest: Incomplete
    def ledger_id(self): ...
    def entry_id(self): ...
    def batch_index(self): ...
    def partition(self): ...
    def serialize(self): ...
    @staticmethod
    def deserialize(message_id_bytes): ...

class Message:
    def data(self): ...
    def value(self): ...
    def properties(self): ...
    def partition_key(self): ...
    def ordering_key(self): ...
    def publish_timestamp(self): ...
    def event_timestamp(self): ...
    def message_id(self): ...
    def topic_name(self): ...
    def redelivery_count(self): ...
    def schema_version(self): ...

class MessageBatch:
    def __init__(self) -> None: ...
    def with_message_id(self, msg_id): ...
    def parse_from(self, data, size): ...

class Authentication:
    auth: Incomplete
    def __init__(self, dynamicLibPath, authParamsString) -> None: ...

class AuthenticationTLS(Authentication):
    auth: Incomplete
    def __init__(self, certificate_path, private_key_path) -> None: ...

class AuthenticationToken(Authentication):
    auth: Incomplete
    def __init__(self, token) -> None: ...

class AuthenticationAthenz(Authentication):
    auth: Incomplete
    def __init__(self, auth_params_string) -> None: ...

class AuthenticationOauth2(Authentication):
    auth: Incomplete
    def __init__(self, auth_params_string: str) -> None: ...

class AuthenticationBasic(Authentication):
    auth: Incomplete
    def __init__(self, username: Incomplete | None = None, password: Incomplete | None = None, method: str = 'basic', auth_params_string: Incomplete | None = None) -> None: ...

class ConsumerDeadLetterPolicy:
    def __init__(self, max_redeliver_count: int, dead_letter_topic: str = None, initial_subscription_name: str = None) -> None: ...
    @property
    def dead_letter_topic(self) -> str: ...
    @property
    def max_redeliver_count(self) -> int: ...
    @property
    def initial_subscription_name(self) -> str: ...
    def policy(self): ...

class CryptoKeyReader:
    cryptoKeyReader: Incomplete
    def __init__(self, public_key_path, private_key_path) -> None: ...

class Client:
    def __init__(self, service_url, authentication: Incomplete | None = None, operation_timeout_seconds: int = 30, io_threads: int = 1, message_listener_threads: int = 1, concurrent_lookup_requests: int = 50000, log_conf_file_path: Incomplete | None = None, use_tls: bool = False, tls_trust_certs_file_path: Incomplete | None = None, tls_allow_insecure_connection: bool = False, tls_validate_hostname: bool = False, logger: Incomplete | None = None, connection_timeout_ms: int = 10000, listener_name: Incomplete | None = None) -> None: ...
    def create_producer(self, topic, producer_name: Incomplete | None = None, schema=..., initial_sequence_id: Incomplete | None = None, send_timeout_millis: int = 30000, compression_type: CompressionType = ..., max_pending_messages: int = 1000, max_pending_messages_across_partitions: int = 50000, block_if_queue_full: bool = False, batching_enabled: bool = False, batching_max_messages: int = 1000, batching_max_allowed_size_in_bytes=..., batching_max_publish_delay_ms: int = 10, chunking_enabled: bool = False, message_routing_mode: PartitionsRoutingMode = ..., lazy_start_partitioned_producers: bool = False, properties: Incomplete | None = None, batching_type: BatchingType = ..., encryption_key: Incomplete | None = None, crypto_key_reader: None | CryptoKeyReader = None, access_mode: ProducerAccessMode = ...): ...
    def subscribe(self, topic, subscription_name, consumer_type: ConsumerType = ..., schema=..., message_listener: Incomplete | None = None, receiver_queue_size: int = 1000, max_total_receiver_queue_size_across_partitions: int = 50000, consumer_name: Incomplete | None = None, unacked_messages_timeout_ms: Incomplete | None = None, broker_consumer_stats_cache_time_ms: int = 30000, negative_ack_redelivery_delay_ms: int = 60000, is_read_compacted: bool = False, properties: Incomplete | None = None, pattern_auto_discovery_period: int = 60, initial_position: InitialPosition = ..., crypto_key_reader: None | CryptoKeyReader = None, replicate_subscription_state_enabled: bool = False, max_pending_chunked_message: int = 10, auto_ack_oldest_chunked_message_on_queue_full: bool = False, start_message_id_inclusive: bool = False, batch_receive_policy: Incomplete | None = None, key_shared_policy: Incomplete | None = None, batch_index_ack_enabled: bool = False, regex_subscription_mode: RegexSubscriptionMode = ..., dead_letter_policy: None | ConsumerDeadLetterPolicy = None): ...
    def create_reader(self, topic, start_message_id, schema=..., reader_listener: Incomplete | None = None, receiver_queue_size: int = 1000, reader_name: Incomplete | None = None, subscription_role_prefix: Incomplete | None = None, is_read_compacted: bool = False, crypto_key_reader: None | CryptoKeyReader = None, start_message_id_inclusive: bool = False): ...
    def get_topic_partitions(self, topic): ...
    def shutdown(self) -> None: ...
    def close(self) -> None: ...

class Producer:
    def topic(self): ...
    def producer_name(self): ...
    def last_sequence_id(self): ...
    def send(self, content, properties: Incomplete | None = None, partition_key: Incomplete | None = None, ordering_key: Incomplete | None = None, sequence_id: Incomplete | None = None, replication_clusters: Incomplete | None = None, disable_replication: bool = False, event_timestamp: Incomplete | None = None, deliver_at: Incomplete | None = None, deliver_after: Incomplete | None = None): ...
    def send_async(self, content, callback, properties: Incomplete | None = None, partition_key: Incomplete | None = None, ordering_key: Incomplete | None = None, sequence_id: Incomplete | None = None, replication_clusters: Incomplete | None = None, disable_replication: bool = False, event_timestamp: Incomplete | None = None, deliver_at: Incomplete | None = None, deliver_after: Incomplete | None = None) -> None: ...
    def flush(self) -> None: ...
    def close(self) -> None: ...
    def is_connected(self): ...

class Consumer:
    def topic(self): ...
    def subscription_name(self): ...
    def consumer_name(self): ...
    def unsubscribe(self): ...
    def receive(self, timeout_millis: Incomplete | None = None): ...
    def batch_receive(self): ...
    def acknowledge(self, message) -> None: ...
    def acknowledge_cumulative(self, message) -> None: ...
    def negative_acknowledge(self, message) -> None: ...
    def pause_message_listener(self) -> None: ...
    def resume_message_listener(self) -> None: ...
    def redeliver_unacknowledged_messages(self) -> None: ...
    def seek(self, messageid: MessageId | _pulsar.MessageId | int): ...
    def close(self) -> None: ...
    def is_connected(self): ...
    def get_last_message_id(self): ...

class ConsumerBatchReceivePolicy:
    def __init__(self, max_num_message, max_num_bytes, timeout_ms) -> None: ...
    def policy(self): ...

class ConsumerKeySharedPolicy:
    def __init__(self, key_shared_mode: KeySharedMode = ..., allow_out_of_order_delivery: bool = False, sticky_ranges: list[tuple[int, int]] | None = None) -> None: ...
    @property
    def key_shared_mode(self) -> KeySharedMode: ...
    @property
    def allow_out_of_order_delivery(self) -> bool: ...
    @property
    def sticky_ranges(self) -> list[tuple[int, int]]: ...
    def policy(self): ...

class Reader:
    def topic(self): ...
    def read_next(self, timeout_millis: Incomplete | None = None): ...
    def has_message_available(self): ...
    def seek(self, messageid: MessageId | _pulsar.MessageId | int): ...
    def close(self) -> None: ...
    def is_connected(self): ...

class ConsoleLogger:
    log_level: Incomplete
    def __init__(self, log_level=...) -> None: ...

class FileLogger:
    log_level: Incomplete
    log_file: Incomplete
    def __init__(self, log_level, log_file) -> None: ...

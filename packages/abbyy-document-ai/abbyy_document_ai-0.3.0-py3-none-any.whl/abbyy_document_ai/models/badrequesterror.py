"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from abbyy_document_ai import utils
from abbyy_document_ai.types import BaseModel
from enum import Enum
import pydantic
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class ElevenTypedDict(TypedDict):
    allowed_values: List[str]


class Eleven(BaseModel):
    allowed_values: Annotated[List[str], pydantic.Field(alias="allowedValues")]


class TenTypedDict(TypedDict):
    error: str
    tag: str
    tag_value: str


class Ten(BaseModel):
    error: str

    tag: str

    tag_value: Annotated[str, pydantic.Field(alias="tagValue")]


class NineTypedDict(TypedDict):
    property_name: str


class Nine(BaseModel):
    property_name: Annotated[str, pydantic.Field(alias="propertyName")]


class EightTypedDict(TypedDict):
    missing_property: str


class Eight(BaseModel):
    missing_property: Annotated[str, pydantic.Field(alias="missingProperty")]


class SevenTypedDict(TypedDict):
    pattern: str


class Seven(BaseModel):
    pattern: str


class SixTypedDict(TypedDict):
    multiple_of: float


class Six(BaseModel):
    multiple_of: Annotated[float, pydantic.Field(alias="multipleOf")]


class Comparison4(str, Enum):
    GREATER_THAN_ = ">"


class Comparison3(str, Enum):
    LESS_THAN_ = "<"


class Comparison2(str, Enum):
    GREATER_THAN_EQUAL_ = ">="


class Comparison1(str, Enum):
    LESS_THAN_EQUAL_ = "<="


ComparisonTypedDict = TypeAliasType(
    "ComparisonTypedDict", Union[Comparison1, Comparison2, Comparison3, Comparison4]
)


Comparison = TypeAliasType(
    "Comparison", Union[Comparison1, Comparison2, Comparison3, Comparison4]
)


class Params5TypedDict(TypedDict):
    limit: float
    comparison: ComparisonTypedDict


class Params5(BaseModel):
    limit: float

    comparison: Comparison


class Params4TypedDict(TypedDict):
    format_: str


class Params4(BaseModel):
    format_: Annotated[str, pydantic.Field(alias="format")]


class Params3TypedDict(TypedDict):
    property: str
    missing_property: str
    deps: str
    deps_count: float


class Params3(BaseModel):
    property: str

    missing_property: Annotated[str, pydantic.Field(alias="missingProperty")]

    deps: str

    deps_count: Annotated[float, pydantic.Field(alias="depsCount")]


class Params2TypedDict(TypedDict):
    additional_property: str


class Params2(BaseModel):
    additional_property: Annotated[str, pydantic.Field(alias="additionalProperty")]


class Params1TypedDict(TypedDict):
    limit: float


class Params1(BaseModel):
    limit: float


ParamsTypedDict = TypeAliasType(
    "ParamsTypedDict",
    Union[
        Params1TypedDict,
        Params2TypedDict,
        Params4TypedDict,
        SixTypedDict,
        SevenTypedDict,
        EightTypedDict,
        NineTypedDict,
        ElevenTypedDict,
        Params5TypedDict,
        TenTypedDict,
        Params3TypedDict,
    ],
)


Params = TypeAliasType(
    "Params",
    Union[
        Params1,
        Params2,
        Params4,
        Six,
        Seven,
        Eight,
        Nine,
        Eleven,
        Params5,
        Ten,
        Params3,
    ],
)


class ValidationTypedDict(TypedDict):
    keyword: str
    instance_path: str
    schema_path: str
    params: ParamsTypedDict
    property_name: NotRequired[str]
    message: NotRequired[str]
    schema_: NotRequired[Any]
    parent_schema: NotRequired[Any]
    data: NotRequired[Any]


class Validation(BaseModel):
    keyword: str

    instance_path: Annotated[str, pydantic.Field(alias="instancePath")]

    schema_path: Annotated[str, pydantic.Field(alias="schemaPath")]

    params: Params

    property_name: Annotated[Optional[str], pydantic.Field(alias="propertyName")] = None

    message: Optional[str] = None

    schema_: Annotated[Optional[Any], pydantic.Field(alias="schema")] = None

    parent_schema: Annotated[Optional[Any], pydantic.Field(alias="parentSchema")] = None

    data: Optional[Any] = None


class ValidationContext(str, Enum):
    BODY = "body"
    PARAMS = "params"
    QUERY = "query"
    HEADERS = "headers"
    QUERYSTRING = "querystring"


class BadRequestErrorData(BaseModel):
    type: str
    r"""A URI reference that identifies the problem type."""

    title: str
    r"""A short, human-readable summary of the problem type."""

    status: float
    r"""The HTTP status code generated by the origin server for this occurrence of the problem."""

    detail: str
    r"""A human-readable explanation specific to this occurrence of the problem."""

    instance: Optional[str] = None
    r"""The URI that identifies the specific occurrence of the problem."""

    validation: Optional[List[Validation]] = None

    validation_context: Annotated[
        Optional[ValidationContext], pydantic.Field(alias="validationContext")
    ] = None


class BadRequestError(Exception):
    r"""The error returned when there is a request validation error."""

    data: BadRequestErrorData

    def __init__(self, data: BadRequestErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(self.data, BadRequestErrorData)

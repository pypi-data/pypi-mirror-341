/**
 * @beta
 * Type representing a binary operator.
 */
export type BinaryOperator = '==' | '!=' | '>' | '>=' | '<' | '<=' | 'in' | 'not in' | 'regex' | 'like' | 'ilike';
/**
 * @beta
 * Type representing a comparator for a filter clause in a query object.
 */
export type Comparator = string | number | (string | number)[] | null;
/**
 * @beta
 * Represents a filter clause with binary operations in a query object.
 * It supports operations involving a column, a binary operator, and a comparator value.
 */
export declare interface BinaryObjectFilterClause {
    col: string;
    op: BinaryOperator;
    val: Comparator;
}
/**
 * @beta
 * Represents a filter clause with unary operations in a query object.
 * It supports operations for checking null or not-null conditions.
 */
export declare interface UnaryObjectFilterClause {
    col: string;
    op: 'IS NULL' | 'IS NOT NULL';
}
/**
 * @beta
 * A union type that represents all possible filter clauses in a query object.
 * It can be either a binary filter clause or a unary filter clause.
 */
export declare type QueryObjectFilterClause = BinaryObjectFilterClause | UnaryObjectFilterClause;
export default QueryObjectFilterClause;
export type ConceptName = string;
/**
 * Represents a property of a concept.
 * @beta
 */
export interface Property {
    /**
     * The concept to which the property belongs.
     */
    concept: ConceptName;
    /**
     * The name of the property.
     */
    property_name: string;
    /**
     * The type of the property.
     */
    property_type: string;
}
/**
 * Represents an inheritance relationship between concepts.
 * @beta
 */
export interface Inheritance {
    /**
     * The base concept in the inheritance.
     */
    base_concept: ConceptName;
    /**
     * The derived concept in the inheritance.
     */
    derived_concept: ConceptName;
    /**
     * The name will be displayed on ui
     */
    display_name: string;
}
/**
 * Represents a tag with a name and value.
 * @beta
 */
export type Tag = {
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * The value of the tag.
     */
    tag_value: string;
};
/**
 * Represents a concept with various properties and relationships.
 * @beta
 */
export interface Concept {
    /**
     * The name of the concept.
     */
    concept_name: string;
    /**
     * The parent concepts.
     */
    parents: string[];
    /**
     * The properties of the concept.
     */
    properties: Property[] | undefined;
    /**
     * All properties of the concept.
     */
    allProperties: Property[] | undefined;
    /**
     * The relationships of the concept.
     */
    relationships: Relationship[];
    /**
     * The columns associated with the concept.
     */
    columns: string[];
    /**
     * The archetype of the concept.
     */
    archetype: string;
    /**
     * The tags associated with the concept.
     */
    tags: Tag[];
    /**
     * The label keys for the concept.
     */
    labelKeys: string[];
    /**
     * All label keys for the concept.
     */
    allLabelKeys: string[];
}
/**
 * Represents a map of concepts.
 * @beta
 */
export type ConceptMap = Map<string, Concept>;
/**
 * Represents an entity without a label.
 * @beta
 */
export type EntityBase = {
    /**
     * The ID of the entity.
     */
    entity_id: string;
    /**
     * The type of the entity.
     */
    entity_type: string;
};
/**
 * Represents an entity with basic attributes.
 * @beta
 */
export type Entity = EntityBase & {
    /**
     * The label of the entity.
     */
    entity_label: string;
};
/**
 * Represents an entity with additional attributes for one-to-many relationships.
 * @beta
 */
export declare type EntityOTM = Entity & {
    /**
     * The UID of the source entity.
     */
    source_entity_uid: string;
    /**
     * The type of the source entity.
     */
    source_entity_type: string;
};
/**
 * Represents a connected entity with a concept name.
 * @beta
 */
export type ConnectedEntity = Entity & {
    /**
     * The name of the concept.
     */
    concept_name: string;
};
/**
 * Represents a relationship between concepts.
 * @beta
 */
export interface Relationship {
    /**
     * Unique identifier for the relationship.
     */
    key: string;
    /**
     * Source concept in the relationship.
     */
    concept: ConceptName;
    /**
     * Target concept in the relationship.
     */
    target_concept: ConceptName;
    /**
     * Name of the relationship.
     */
    relationship_name: string;
    /**
     * Inverse name of the relationship.
     */
    inverse_name: string;
    /**
     * Properties of the source concept.
     */
    source_properties: string;
    /**
     * Properties of the target concept.
     */
    target_properties: string;
    /**
     * Name of the mapping.
     */
    mapping_name: string;
    /**
     * Additional properties associated with the relationship.
     */
    additional_properties: string;
    /**
     * Query used for mapping the relationship.
     */
    mapping_query: string;
    /**
     * Tables involved in the relationship.
     */
    tables: string;
    /**
     * JSON representation of the mapping.
     */
    mapping_json: string;
    /**
     * Indicates if the relationship is inverse (1 for true, 0 for false).
     */
    is_inverse: number;
    /**
     * Indicates if the relationship is many-to-many (1 for true, 0 for false).
     */
    is_mtm: number;
    /**
     * Transitivity property of the relationship.
     */
    transitivity: number;
    /**
     * Identifier for the data source.
     */
    datasource_id: string;
    /**
     * Sort order for the relationship.
     */
    sort_order: number;
    /**
     * Description of the relationship (optional).
     */
    description?: string;
}
/**
 * Enum for sort order values.
 * @beta
 */
export declare enum SortOrder {
    PREFERRED = 21,
    OTHER = 10,
    HIDE = -1
}
/**
 * Represents a workspace record identifier.
 * @beta
 */
export interface WorkspaceRecordIdentifier {
    /**
     * The concept to which the record belongs.
     */
    entity_type: string;
    /**
     * The ID of the workspace record.
     */
    os_entity_uid: string;
    /**
     * The id of the workspace in which the record is stored.
     */
    os_workspace: string;
}
/**
 * Represents a workspace entity.
 * @beta
 */
export type OsWorkspaceEntity = Entity & WorkspaceRecordIdentifier;
/**
 * Represents a concept with parent concepts.
 * @beta
 */
export type ConceptWithParents = Concept & {
    parents: string[];
};
/**
 * Represents the configuration for a workspace item.
 * @beta
 */
export interface WorkspaceItemConfig {
    /**
     * The id the workspace item.
     */
    entity_id: string;
    /**
     * The concept to which the workspace item belongs.
     */
    entity_type: string;
    /**
     * The id of the workspace in which the workspace item is stored.
     */
    workspace_id: string;
    /**
     * Epoch time of the last update of the workspace item.
     */
    last_updated: number;
}
/**
 * Represents a filter applied to a concept.
 * @beta
 */
export type ConceptFilter = {
    /**
     * The name of the concept.
     */
    concept: ConceptName;
    /**
     * The filters to apply to the records of the concept.
     */
    filters: QueryObjectFilterClause[];
};
/**
 * Represents the model for a workspace item.
 * @beta
 */
export type WorkspaceItemModel = {
    /**
     * Ephemeral UI state in lieu of using complex redux logic.
     * It is not saved in persistence and can be mutated by components.
     */
    __uiState?: {
        /**
         * Indicates if the item is in rename mode.
         */
        rename?: boolean;
        /**
         * A filter applied to concepts.
         */
        query?: ConceptFilter;
        /**
         * Function to get the count of entities.
         * @returns A promise that resolves to the number of entities.
         */
        getEntitiesCount?: () => Promise<number>;
        /**
         * Function to get the entities.
         * @param limit - The maximum number of entities to retrieve.
         * @returns A promise that resolves to an array of entities.
         */
        getEntities?: (limit?: number) => Promise<Entity[]>;
        /**
         * Determines if the count is shown only when the item is closed.
         */
        showCountOnlyWhenClosed?: boolean;
        /**
         * The initial state of the item.
         */
        initialState?: any;
        /**
         * Indicates if the item should be highlighted.
         */
        highlight?: boolean;
        /**
         * Indicates if the item is in draft mode.
         */
        draft?: boolean;
        /**
         * Indicates if the item is auto open
         */
        autoOpen?: boolean;
        /**
         * Indicates if the item is hidden
         */
        isHidden?: boolean;
        /**
         * Indicates if the item is closable
         */
        isClosable?: boolean;
    };
    /**
     * Name of the workspace item.
     */
    os_item_name: string;
    /**
     * Type of the workspace item.
     */
    os_item_type: string;
};
/**
 * Represents the base attributes for a workspace item.
 * @beta
 */
export type WorkspaceItemBase = WorkspaceItemModel & {
    /**
     * The ID of the workspace item.
     */
    os_entity_uid: string;
    /**
     * The ID of the workspace in which the item is stored.
     */
    os_workspace: string;
};
/**
 * Represents audit fields for OS (Operational Support) records.
 * @beta
 */
export type OsAuditFields = {
    /**
     * User who created the record.
     */
    os_created_by?: string;
    /**
     * Timestamp when the record was created.
     */
    os_created_at?: string;
    /**
     * User who deleted the record.
     */
    os_deleted_by?: string;
    /**
     * Timestamp when the record was deleted.
     */
    os_deleted_at?: string;
    /**
     * User who hid the record.
     */
    os_hidden_by?: string;
    /**
     * Timestamp when the record was hidden.
     */
    os_hidden_at?: string;
    /**
     * User who last updated the record.
     */
    os_last_updated_by?: string;
    /**
     * Timestamp when the record was last updated.
     */
    os_last_updated_at?: string;
};
/**
 * Represents a comment workspace item with various attributes.
 * @beta
 */
export type CommentWorkspaceItem = WorkspaceItemBase & OsAuditFields & Entity & {
    /**
     * The content of the comment.
     */
    contents: string;
    /**
     * The short text of the comment.
     */
    slug?: string;
    /**
     * The id of the comment thread.
     */
    os_parent_uid?: string;
};
/**
 * Represents a workspace record with additional attributes.
 * @beta
 */
export type WorkspaceRecord = Entity & WorkspaceItemBase & OsAuditFields & {
    os_icon?: string;
};
/**
 * Interface for items that can have a color attribute.
 * @beta
 */
export interface Colorful {
    /**
     * The color of the item.
     */
    color?: string;
}
/**
 * Represents tag attributes with optional color and group.
 * @beta
 */
export interface TagAttributes extends Colorful {
    /**
     * The group to which the tag belongs.
     */
    group?: string;
    /**
     * The order of the tag in the group.
     * Lower values are displayed first.
     */
    order?: number;
    /**
     * The id of the workspace in which the tag is stored.
     */
    os_workspace: string;
    /**
     * The name of the tag.
     */
    os_item_name: string;
}
/**
 * Represents a tag in the workspace.
 * @beta
 */
export type OsTag = WorkspaceRecord & TagAttributes;
/**
 * Represents information about an image.
 * @beta
 */
export type ImageInfo = {
    /**
     * The blurhash of the image.
     */
    blurhash?: string;
    /**
     * The natural width of the image.
     */
    width: number;
    /**
     * The natural height of the image.
     */
    height: number;
};
/**
 * Represents a workspace item with optional content.
 * @beta
 */
export type WorkspaceItem<T = any> = WorkspaceRecord & {
    /**
     * The type-specific content of the workspace item.
     */
    os_item_content?: T & {
        image?: ImageInfo;
    };
    /**
     * The type of the content.
     */
    os_item_content_type?: string;
    /**
     * The id of the folder in which the item is stored.
     */
    os_parent_folder?: string;
    /**
     * Whether the item has an attachment file content.
     */
    os_has_attachment?: boolean;
    /**
     * Optional path from the os_parent_folder or os_workspace to the item.
     * Does not include the item name.
     * Used only when saving by POST to the /entity API.
     * eg. 'folder1/folder2'
     */
    '#os_path'?: string;
    /**
     * The size in bytes of the content.
     */
    os_content_size?: number;
    /**
     * Whether the item is readonly or not.
     */
    os_readonly?: boolean;
};
/**
 * Represents a relationship between workspace items.
 * @beta
 */
export type WorkspaceRelationship = WorkspaceItemBase & OsAuditFields & {
    /**
     * Unique identifier for the source entity in the relationship.
     */
    os_entity_uid_from: string;
    /**
     * Unique identifier for the target entity in the relationship.
     */
    os_entity_uid_to: string;
    /**
     * Type of the source entity in the relationship.
     */
    os_entity_type_from: string;
    /**
     * Type of the target entity in the relationship.
     */
    os_entity_type_to: string;
    /**
     * Name of the relationship.
     */
    os_relationship_name: string;
};
/**
 * Represents a draft workspace item.
 * @beta
 */
export type DraftWorkspaceItem = WorkspaceItem & {
    /**
     * Indicates if the item is a draft. The attribute is not saved in persistence.
     */
    os_draft_item: true;
};
/**
 * Represents an array of workspace items.
 * @beta
 */
export type WorkspaceItems = WorkspaceItem[];
/**
 * Interface for providing records.
 * @beta
 */
export interface RecordProvider {
    /**
     * Retrieves the total count of records.
     * @returns A promise that resolves to the number of records.
     */
    getCount: () => Promise<number>;
    /**
     * Retrieves a specific record by its index.
     * @param i - The index of the record to retrieve.
     * @returns A promise that resolves to the requested record.
     */
    getRecord: (i: number) => Promise<Entity>;
    /**
     * Optional method to handle deletion of a record.
     * @param entity - The entity to delete.
     * @returns A promise that resolves when the deletion is complete.
     */
    onDelete?: (entity: Entity) => Promise<void>;
    /**
     * Retrieves a message related to the records.
     * @returns A promise that resolves to the message, or undefined if no message is available.
     */
    getMessage(): Promise<string | undefined>;
}
/**
 * Represents a named group (set?) entities.
 * @beta
 */
export type NamedEntityGroup = {
    /**
     * The label for the entity group.
     */
    entity_label: string;
    /**
     * The query to provide the entites
     */
    query: ConceptFilter;
    /**
     * The count of entities in the group.
     */
    count: number;
    /**
     * The type of the entity group, always set to 'group'.
     */
    type: 'group';
};
/**
 * Represents an item in a focus list.
 * @beta
 */
export type FocusListItem = {
    entity: Entity;
    count: number;
    tabName?: string;
    type?: 'single';
} | NamedEntityGroup;
/**
 * Represents a boolean value with an optional reason.
 * @beta
 */
export type ReasonedBoolean = {
    value: true;
} | {
    value: false;
    reason: string;
};
/**
 * Possible statuses of a NiFi pipeline task.
 * @beta
 */
export declare enum ProcessingStatusCode {
    /** Queued and awaiting execution */
    QUEUED = "QUEUED",
    /** Currently running */
    RUNNING = "RUNNING",
    /** Stopped manually */
    STOPPED = "STOPPED",
    /** Paused and can be resumed */
    PAUSED = "PAUSED",
    /** Completed successfully */
    COMPLETED = "COMPLETED",
    /** Encountered a failure */
    FAILED = "FAILED",
    /** Scheduled to run */
    SCHEDULED = "SCHEDULED",
    /** Starting up */
    STARTING = "STARTING",
    /** Shutting down */
    STOPPING = "STOPPING",
    /** Disabled and cannot run */
    DISABLED = "DISABLED",
    /** Invalid configuration */
    INVALID = "INVALID",
    /** Waiting for an external event */
    WAITING = "WAITING",
    /** Retrying after failure */
    RETRYING = "RETRYING",
    /** Status is unknown */
    UNKNOWN = "UNKNOWN"
}
/**
 * Represents the status of a processing operation.
 * @beta
 */
export interface ProcessingStatus {
    /**
     * The id of the entity being processed.
     */
    entity_id: string;
    /**
     * The type of the entity being processed.
     */
    entity_type: string;
    /**
     * The status code of the processing operation.
     */
    status_code: ProcessingStatusCode;
    /**
     * The reason for the processing operation.
     */
    reason: string;
    /**
     * The timeout for the processing operation.
     */
    timeout: number;
}
//# sourceMappingURL=model.d.ts.map
type DependencyFactoryGeneral = (locator: unknown) => Promise<any>;
type DependencyFactory<T, S extends Record<string, DependencyFactoryGeneral>> = (locator: AsyncServiceLocator<S>) => Promise<T>;
type GetServiceResult<T> = Promise<T extends (...args: any) => infer R ? Awaited<R> : never>;
export type ReadOnlyAsyncServiceLocator<T, I = T extends AsyncServiceLocator<infer S> ? S : never> = {
    getService<K extends keyof I>(name: K): GetServiceResult<I[K]>;
};
type AsyncServiceLocatorOptions = {
    cache: boolean;
};
export declare class AsyncServiceLocator<S extends Record<string, DependencyFactory<any, Record<string, DependencyFactoryGeneral>>>> {
    private readonly services;
    private readonly cache;
    private readonly options;
    constructor(services: S, cache: Record<keyof S, any>, options: AsyncServiceLocatorOptions);
    static instances: Record<string, AsyncServiceLocator<{}>>;
    static getInstance(key: string, options: AsyncServiceLocatorOptions): AsyncServiceLocator<{}>;
    registerService<K extends string, V extends DependencyFactory<any, S>>(name: K, serviceFactory: V): AsyncServiceLocator<S & Record<K, V>>;
    getService<K extends keyof S>(name: K): GetServiceResult<S[K]>;
}
export {};
//# sourceMappingURL=AsyncServiceLocator.d.ts.map
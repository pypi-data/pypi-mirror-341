import { ButtonProps } from 'antd';
import { ItemType } from 'rc-menu/lib/interface';
import { ModalProps } from 'antd';
import { Properties } from 'csstype';
import { QueryDslQueryContainer } from '@elastic/elasticsearch/lib/api/types';
import { TabNode } from 'flexlayout-react';

/**
 * @beta
 * Interface representing the context for an action.
 */
export declare interface ActionContext {
    concept?: string;
    graph?: GraphSpec & any;
    item?: WorkspaceItem;
    items?: WorkspaceItem[];
    workspace?: Workspace;
    dataTransfer?: IDataTransfer;
    eventTopicPrefix?: string;
    selectedItems?: WorkspaceItem[];
    /**
     * Callback function to be executed with the result of the action.
     * @param result - The result object containing records and relationships.
     */
    then?: (result?: {
        records?: Entity[];
        relationships?: EdgeSpec[];
    }) => void;
}

/**
 * @beta
 * Interface for handling actions with optional close behavior.
 */
export declare type ActionHandler = {
    onClose?: AsyncFilter;
};

/**
 * Parameters for adding a comment.
 * @beta
 */
export declare type AddCommentParams = {
    /**
     * Parent UID for the comment.
     */
    os_parent_uid?: string;
    /**
     * Contents of the comment.
     */
    contents: string;
    /**
     * Slug for the comment.
     */
    slug?: string;
    /**
     * Workspace for the comment.
     */
    os_workspace?: string;
};

/**
 * @beta
 * Type representing a function to add a listener.
 * @template T - The type of the parameter for the callback function.
 * @param callback - The callback function to be invoked.
 * @returns A promise that resolves to an unsubscribe function.
 */
export declare type AddListener<T> = (callback: Callback<T>) => Promise<Unsubscribe>;

/**
 * The interface for the AI client.
 */
export declare interface AIClient {
    /**
     * Get the chat models.
     */
    getChatModels(): Promise<ChatModel[]>;
    /**
     * Prompt the AI.
     */
    prompt(prompt: string, options?: PromptOptions): Promise<string>;
}

/**
 * @beta
 * Type representing an error API result.
 */
export declare type ApiErrorResult = {
    /** The status of the API result, always 'error' for this type. */
    status: 'error';
    /** The error message or data. */
    data: string;
    /** The cause of the error, represented by a number. */
    cause: number;
};

/**
 * @beta
 * Type representing a general API result which can be either success or error.
 * @template T - The type of the data returned in case of success.
 */
export declare type ApiResult<T> = ApiSuccessResult<T> | ApiErrorResult;

/**
 * @beta
 * Type representing a successful API result.
 * @template T - The type of the data returned.
 */
export declare type ApiSuccessResult<T> = {
    /** The status of the API result, always 'success' for this type. */
    status: 'success';
    /** The data returned by the API. */
    data: T;
};

/**
 * @beta
 * Type representing an application with folder and optional manifest information.
 */
export declare type App = {
    /** The folder associated with the application. */
    folder: WorkspaceItem;
    /** Optional manifest entity associated with the application. */
    manifest_entity?: WorkspaceItem;
    /** Optional job manifest associated with the application. */
    manifest?: JobManifest;
    /** Optional files associated with the application. */
    files?: WorkspaceItem[];
};

/**
 * Interface for app registry.
 * @beta
 */
export declare type AppRegistry = {
    /**
     * Registers a tab component.
     */
    registerTabComponent: ({ component, factory, }: {
        component: string;
        factory: (node: TabNode) => ReactNode;
    }) => void;
    /**
     * Registers an action.
     */
    registerAction: (action: DesktopActionMenuItem) => void;
    /**
     * @beta
     * Registers a styler.
     */
    registerStyler: (styler: StylerConfig) => () => void;
};

/**
 * @beta
 * Options for an application service call.
 */
export declare type AppServiceCallOptions = {};

/**
 * @beta
 * Properties for making an application service call.
 */
export declare type AppServiceCallProps = {
    /** The name of the service to be called. */
    service: string;
    /** Optional options for the service call. */
    options?: AppServiceCallOptions;
    /** Contextual data for the service call. */
    context: {
        [key: string]: any;
    };
};

/**
 * @beta
 * Type representing an asynchronous filter function.
 */
export declare type AsyncFilter = () => Promise<boolean>;

/**
 * Response type for attachments.
 * @beta
 */
export declare type AttachmentResponseType = 'text' | 'blob' | 'arrayBuffer' | 'json' | 'url';

/**
 * Type for attachments.
 * @beta
 */
export declare type AttachmentType = string | Blob | ArrayBuffer | Record<string, any>;

/**
 * @beta
 * Type representing a set of behaviors with various methods for entity and graph operations.
 */
export declare type Behaviour = {
    /**
     * Gets the count of entities.
     * @returns A promise that resolves to the number of entities.
     */
    getEntitiesCount?: () => Promise<number>;
    /**
     * Gets a list of entities.
     * @param limit - Optional limit on the number of entities to retrieve.
     * @returns A promise that resolves to an array of entities.
     */
    getEntities?: (limit?: number) => Promise<Entity[]>;
    /**
     * Gets a single entity.
     * @returns A promise that resolves to an entity.
     */
    getEntity?: () => Promise<Entity>;
    /**
     * Gets the content associated with the behavior.
     * @returns A promise that resolves to the content.
     */
    getContent?: () => Promise<any>;
    /**
     * Gets the graph specification.
     * @returns A promise that resolves to the graph specification or undefined if not available.
     */
    getGraph?: () => Promise<GraphSpec | undefined>;
    /**
     * Opens the associated entity or content with the default action.
     * @returns A promise that resolves when the operation is complete.
     */
    open?: () => Promise<void>;
    /**
     * Edits the associated entity or content with the default edit action.
     * @returns A promise that resolves when the operation is complete.
     */
    edit?: () => Promise<void>;
};

declare type BigNumber = any;

/**
 * @beta
 * Represents a filter clause with binary operations in a query object.
 * It supports operations involving a column, a binary operator, and a comparator value.
 */
export declare interface BinaryObjectFilterClause {
    col: string;
    op: BinaryOperator;
    val: Comparator;
}

/**
 * @beta
 * Type representing a binary operator.
 */
export declare type BinaryOperator = '==' | '!=' | '>' | '>=' | '<' | '<=' | 'in' | 'not in' | 'regex' | 'like' | 'ilike';

/**
 * @beta
 * Type representing a callback function.
 * @template T - The type of the parameter for the callback function.
 * @param t - The parameter for the callback function.
 */
export declare type Callback<T> = (t: T) => void;

export declare interface ChartDataResponseResult {
    all_columns?: string[];
    annotation_data: Record<string, any> | null;
    cache_key: string | null;
    cache_timeout: number | null;
    cached_dttm: string | null;
    /**
     * Array of data records as dictionary
     */
    data: Record<any, any>[];
    /**
     * Name of each column, for retaining the order of the output columns.
     */
    colnames: string[];
    /**
     * Generic data types, based on the final output pandas dataframe.
     */
    coltypes: GenericDataType[];
    error: string | null;
    is_cached: boolean;
    query: string;
    rowcount: number;
    stacktrace: string | null;
    status: 'stopped' | 'failed' | 'pending' | 'running' | 'scheduled' | 'success' | 'timed_out';
    from_dttm: number | null;
    to_dttm: number | null;
}

export declare interface ChatMessage {
    /**
     * The id of the message. This is used to identify the message in the conversation.
     * It is generated by the chat agent, and is used to update the message in the conversation.
     * (It is repeated in each update, but this is ok because it is used to identify the message in the conversation.)
     */
    id: string;
    /**
     * The role of the message.
     */
    role: 'user' | 'assistant' | 'system';
    /**
     * The content of the message.
     * For `update` and `complete` messages, this is the partial or final response.
     * For `add_entities` and `remove_entities` messages, this is the json encoded list of entities.
     */
    content: string;
    /**
     * The type of the message.
     */
    type?: 'update' | 'complete' | 'add_entities' | 'remove_entities';
    /**
     * The timestamp of the message in ISO 8601 format.
     */
    timestamp?: string;
}

/**
 * The type for the chat model.
 */
export declare type ChatModel = {
    model_name: string;
    description: string;
};

/**
 * Interface for items that can have a color attribute.
 * @beta
 */
export declare interface Colorful {
    /**
     * The color of the item.
     */
    color?: string;
}

/**
 * Represents a comment workspace item with various attributes.
 * @beta
 */
export declare type CommentWorkspaceItem = WorkspaceItemBase & OsAuditFields & Entity & {
    /**
     * The content of the comment.
     */
    contents: string;
    /**
     * The short text of the comment.
     */
    slug?: string;
    /**
     * The id of the comment thread.
     */
    os_parent_uid?: string;
};

/**
 * @beta
 * Type representing a comparator for a filter clause in a query object.
 */
export declare type Comparator = string | number | (string | number)[] | null;

/**
 * Represents a concept with various properties and relationships.
 * @beta
 */
export declare interface Concept {
    /**
     * The name of the concept.
     */
    concept_name: string;
    /**
     * The parent concepts.
     */
    parents: string[];
    /**
     * The properties of the concept.
     */
    properties: Property[] | undefined;
    /**
     * All properties of the concept.
     */
    allProperties: Property[] | undefined;
    /**
     * The relationships of the concept.
     */
    relationships: Relationship[];
    /**
     * The columns associated with the concept.
     */
    columns: string[];
    /**
     * The archetype of the concept.
     */
    archetype: string;
    /**
     * The tags associated with the concept.
     */
    tags: Tag[];
    /**
     * The label keys for the concept.
     */
    labelKeys: string[];
    /**
     * All label keys for the concept.
     */
    allLabelKeys: string[];
}

/**
 * Represents a filter applied to a concept.
 * @beta
 */
export declare type ConceptFilter = {
    /**
     * The name of the concept.
     */
    concept: ConceptName;
    /**
     * The filters to apply to the records of the concept.
     */
    filters: QueryObjectFilterClause[];
};

/**
 * Represents a map of concepts.
 * @beta
 */
export declare type ConceptMap = Map<string, Concept>;

export declare type ConceptName = string;

/**
 * Represents a concept with parent concepts.
 * @beta
 */
export declare type ConceptWithParents = Concept & {
    parents: string[];
};

/**
 * Represents a connected entity with a concept name.
 * @beta
 */
export declare type ConnectedEntity = Entity & {
    /**
     * The name of the concept.
     */
    concept_name: string;
};

/**
 * @beta
 * Type representing the groups for a context menu.
 */
export declare type ContextMenuGroup = 'add' | 'addto' | 'copy' | 'edit' | 'transform' | 'general' | 'open' | 'danger' | 'tags' | 'relations' | 'search' | 'actions' | 'file' | 'settings';

/**
 * @beta
 * Type representing labels for context menu groups.
 */
export declare type ContextMenuLabels = {
    [group in ContextMenuGroup]?: string;
};

/**
 * @beta
 * Options for configuring a context menu.
 */
export declare type ContextMenuOptions = {
    mode?: 'edit' | 'default';
    groups?: ContextMenuGroup[];
    labels?: ContextMenuLabels;
    extras?: ItemType[];
    excludedKeys?: string[];
};

/**
 * @beta
 * Parameters for a context menu.
 */
export declare type ContextMenuParams = ActionContext & {
    children: any;
    trigger?: trigger[];
    onMenuToggle?: (isOpen: boolean) => void;
    options?: ContextMenuOptions;
    markdown?: boolean;
};

/**
 * @beta
 * Request object for opening or clearing a context menu.
 */
export declare type ContextMenuRequest = (ActionContext & {
    x: number;
    y: number;
    openContextMenu?: boolean;
    onCloseEmit?: string;
    menuType?: 'default' | 'tags';
    options?: ContextMenuOptions;
}) | {
    clearContextMenu: true;
};

/**
 * Options for copying items.
 * @beta
 */
export declare type CopyOptions = {
    /**
     * Name of the item to be copied.
     */
    os_item_name?: string;
};

/**
 * Properties for creating an entity form.
 * @beta
 */
export declare type CreateEntityFormProps = {
    /**
     * Entity for the form.
     */
    entity?: Entity;
    /**
     * Workspace for the form. Defaults to activeWorkspace (when set) if no os_workspace is passed
     */
    os_workspace?: string;
    /**
     * Fallback Workspace for the form in case there's no activeWorkspace or os_workspace
     */
    fallback_workspace?: string;
    /**
     * Concept related to the form.
     */
    concept?: string;
};

export declare type CreateLinkChartFn = (params: CreateLinkChartParams) => Promise<WorkspaceItem | undefined>;

export declare type CreateLinkChartParams = {
    path?: string;
    name: string;
    nodes?: Entity[];
    edges?: EdgeSpec[];
    draft?: boolean;
    os_workspace?: string;
};

/**
 * Properties for creating relations dialog.
 * @beta
 */
export declare type CreateRelationsDialogProps = {
    /**
     * Source entity for the relations.
     */
    source?: Entity;
    /**
     * Workspace for the relations.
     */
    os_workspace?: string;
    /**
     * Target item for the relations.
     */
    target?: FocusListItem;
    /**
     * Whether to create a new record.
     */
    createRecord?: boolean;
    /**
     * Name of the relation.
     */
    relationName?: string;
    /**
     * Default target concept for the relations.
     */
    defaultTargetConcept?: string;
};

/**
 * @beta
 * Type representing a custom event listener.
 * @template L - The type of the event payload.
 * @param payload - The payload of the event.
 */
export declare type CustomEventListener<L> = (payload: L) => void;

/**
 * @beta
 * Type representing a custom template, extending TemplateMetadata.
 */
export declare type CustomTemplate = TemplateMetadata & {
    /** The template content. */
    template: string;
};

/**
 * @beta
 * Type representing the properties for a custom template iframe.
 */
export declare type CustomTemplateIframeProps = {
    /** The template to be rendered in the iframe. */
    template: CustomTemplate | SavedTemplate | string;
    /** The context for the template. */
    context: any;
    /** Whether to enable debug mode. */
    debug?: boolean;
    /**
     * Callback function to be called on error.
     * @param err - The error object.
     */
    onError?: (err: {
        message: string;
    }) => void;
    /** The width of the iframe. */
    width?: number | string;
    /** The height of the iframe. */
    height?: number | string;
    /** Optional CSS properties for the iframe. */
    style?: ReactCssProperties;
    /** Whether the iframe should take the full width. */
    fullWidth?: boolean;
};

/**
 * DataContext is a container for abstract data of graph/selection/superselection. It serves like as a bridge between ontology data and linkchart.
 * Eg. linkchart uses *selection*, if it updates, it will cause linkchart to select elements with same ids to be selected on it.
 * Vice versa, if user clicks on linkchart, it will call setSelection and thus here via setEntities/setEdges from RightSidebarControllerContext anything what uses it (eg Rightsidebar or Superselect table) will be updated.
 * @param graph set of all items on graph
 * @param setGraph use to update (overwrite by replacement) what's on graph, converts EdgeSpec(s) to EntityEdge(s) (if possible), no edge discovery will be performed later, for that use addToGraph
 * @param selection set of all *selected* items on graph
 * @param setSelection use to update what's *selected* on graph
 * @param superSelection set of id of all *super selected (subselected)* items on graph
 * @param setSuperSelection use to update what's *super selected (subselected)* on graph
 * @param addToGraph add entities/relationships to graph, converts EdgeSpec(s) to EntityEdge(s) (if possible) and can also initialize discovery of all available relationships between new and existing entities
 * @param removeFromGraph remove entities/relationships from graph
 */
export declare type DataContextType = {
    graph: GraphDataSpec;
    setGraph: (newGraph: {
        entities: GraphDataSpec['entities'];
        relationships: (EntityEdge | EdgeSpec)[];
    }) => void;
    selection: GraphDataSpec;
    setSelection: React.Dispatch<React.SetStateAction<GraphDataSpec>>;
    superSelection: {
        entityIds: string[];
        relationshipIds: string[];
    };
    setSuperSelection: React.Dispatch<React.SetStateAction<{
        entityIds: string[];
        relationshipIds: string[];
    }>>;
    addToGraph: (graphUpdates: {
        entities: GraphDataSpec['entities'];
        relationships: (EntityEdge | EdgeSpec)[];
    }, getAllEdgesConnected?: boolean, forceUpdateEntities?: boolean) => void;
    removeFromGraph: (graph: GraphDataSpec) => void;
};

export declare type DataMask = {
    extraFormData?: Record<string, any>;
    filterState?: FilterState;
    ownState?: Record<string, any>;
};

/**
 * Interface for desktop actions.
 * @beta
 */
export declare interface Desktop extends DesktopSettings, WorkspaceChangeEmitter {
    /**
     * Refreshes the desktop.
     */
    refresh: () => Promise<void>;
    /**
     * Opens a workspace.
     */
    openWorkspace: (ws: WorkspaceIdentifier | WorkspaceIdentifier[] | string[], showTab?: boolean) => Promise<void>;
    /**
     * Gets the active workspace.
     */
    getActiveWorkspace: (prompt?: boolean) => Promise<string | undefined>;
    /**
     * Sets the active workspace.
     */
    setActiveWorkspace: (workspace: string | undefined) => Promise<void>;
    /**
     * Closes a workspace.
     */
    closeWorkspace: (ws: WorkspaceIdentifier) => Promise<void>;
    /**
     * Copies an item.
     */
    copy: (source: WorkspaceItem, target: WorkspaceItem, options?: CopyOptions) => Promise<WorkspaceItem[]>;
    /**
     * Lists all workspaces with optional permissions.
     */
    listAllWorkspaces: (permissions?: WorkspacePermissionValue) => Promise<WorkspaceItem[]>;
    /**
     * This might not be enough, add a listener to {@link WorkspaceChangeEmitter.onOpenWorkspacesChanged} to keep getting updated.
     * In react components, prefer useDesktopWorkspaces hook.
     */
    getOpenWorkspaces: () => Promise<Workspace[]>;
    /**
     * Gets the OntologyAPI.
     * @returns a promise that resolves to the current ontology
     */
    getOntology: () => Promise<Ontology>;
    /**
     * Fetches an attachment based on the provided workspace identifier and path or ID.
     *
     * @param entity - The entity to which the attachment belongs.
     * @param options - Additional parameters
     * @returns A promise that resolves to the attachment of type T.
     */
    getAttachment: <T extends AttachmentType>(entity: Entity, options?: GetAttachmentOptions<T>) => Promise<T>;
    /**
     * @beta
     * Gets options for stylers.
     */
    getStylerOptions: () => Promise<StylerOption[]>;
    /**
     * @beta
     * Gets a styler by name and context.
     */
    getStyler: (name: string, context: DesktopStylerContext) => Promise<Styler>;
    /**
     * Gets a workspace by identifier.
     */
    getWorkspace: (ws: WorkspaceIdentifier, options?: {
        shouldRetry?: boolean;
    }) => Promise<Workspace | undefined>;
    /**
     * Gets items in a workspace by name.
     */
    getWorkspaceItems(os_item_name: string): Promise<WorkspaceItem[]>;
    /**
     * Gets the OsAPIClient.
     */
    getOsAPIClient(): Promise<OsAPIClient>;
    /**
     * Gets the AI client.
     */
    getAIClient(): Promise<AIClient>;
    /**
     * Applies a tag to an entity.
     */
    applyTag: (os_workspace: string, tag: OsTag | TagAttributes, entity: Entity | Entity[]) => Promise<void>;
    /**
     * Removes a tag from an entity.
     */
    removeTag: (os_workspace: string, tag: OsTag | TagAttributes, entity: Entity | Entity[]) => Promise<void>;
    /**
     * Updates a tag.
     */
    updateTag: (tag: OsTag) => Promise<OsTag>;
    /**
     * Gets an item by workspace identifier.
     */
    getItem: <T>(ws: WorkspaceIdentifier<T>) => Promise<WorkspaceItem<T>>;
    /**
     * Gets items by workspace identifiers.
     */
    getItems: (ws: WorkspaceIdentifier[]) => Promise<WorkspaceItem[]>;
    /**
     * Gets tags for an entity.
     */
    getTags: (entity: Entity) => Promise<TagWithRelationship[]>;
    /**
     * Gets available tags for an entity in a workspace.
     */
    getAvailableTags: (entity: Entity, workspace?: string) => Promise<OsTag[]>;
    /**
     * Gets templates by layout or filter
     */
    getTemplates: (layout?: string | ((template: SavedTemplate) => boolean)) => Promise<SavedTemplate[]>;
    /**
     * Gets a template by name or entity or filter with an optional default template.
     */
    getTemplate: (name: string | Entity | ((template: SavedTemplate) => boolean), defaultTemplate?: string) => Promise<SavedTemplate>;
    /**
     * Gets the named app if it is on the desktop and in a running state.
     */
    getApp: (name: string) => Promise<WorkspaceItem | undefined>;
    /**
     * Gets schema items by content type.
     */
    getSchemaItems(os_item_content_type: string): Promise<WorkspaceItem[]>;
    /**
     * Creates a workspace by name.
     */
    createWorkspace: (name: string, config?: WorkspaceConfig) => Promise<WorkspaceItem>;
    /**
     * Creates a private workspace for user by name.
     */
    createPrivateWorkspace: (name: string, config?: WorkspaceConfig) => Promise<Workspace>;
    /**
     * Connects two entities with a relationship in a workspace.
     */
    connect: (relationship: Relationship | string, from: Entity, to: Entity, os_workspace?: string) => Promise<WorkspaceItem>;
    /**
     * Saves an item with optional save options.
     */
    save: (item: (Partial<WorkspaceItem> & WorkspaceItemModel) | WorkspaceRecordIdentifier | WorkspaceRecordWithRelationships, options?: SaveOptions) => Promise<WorkspaceItem>;
    /**
     * Saves a file to an item with optional save options.
     */
    saveFile: (item: WorkspaceItem, file: File | string, options?: SaveOptions) => Promise<WorkspaceItem>;
    /**
     * Imports items.
     */
    import: (items: any[]) => Promise<void>;
    /**
     * Imports a ZIP file with optional import options.
     */
    importZip: (file: File, options?: ImportZipOptions) => Promise<void>;
    /**
     * Exports an item or items with optional export options.
     */
    export: (item: WorkspaceItem | WorkspaceItem[], options?: ExportOptions) => Promise<void>;
    /**
     * Fetches an entity from the index, or from the ontology if not found in the index.
     */
    fetchEntity: (entity: EntityBase, options?: FetchEntityOptions) => Promise<Entity>;
    /**
     * Extracts entities from some text which may be json or a list of urls.
     */
    extractEntities: (text: string, options?: ExtractEntitiesOptions) => Promise<Entity[]>;
    /**
     * Gets a file tree for a workspace or folder with optional file tree options.
     */
    getFilesTree: (workspace_or_folder: WorkspaceItem, options?: FileTreeOptions) => Promise<WorkspaceItem[]>;
    /**
     * Show the search modal and return the selected results.
     */
    getSearchResults: (params: undefined | string | SearchProps, enableSelection?: boolean) => Promise<Entity[] | undefined>;
    /**
     * Opens records with default action or as specified in the optional desktop action options.
     */
    open(records: Entity | Entity[], options?: DesktopActionOptions): Promise<void>;
    /**
     * Deletes an item or items recursively.
     */
    delete: (item: WorkspaceRecordIdentifier | WorkspaceRecordIdentifier[], recurse?: boolean) => Promise<void>;
    /**
     * Deletes records in a workspace by ID.
     */
    delete_workspace_records: (workspace_id: string) => Promise<void>;
    /**
     * Deletes local concept records in a workspace by base concept.
     */
    delete_local_concept_records: (workspace_id: string, base_concept: string) => Promise<void>;
    /**
     * Searches the index using the query string
     * @param query OpenSearch qeuery string.
     * @param options query options
     * @returns a promise resolving to the found entities.
     */
    search: (query: string, options?: SearchOptions) => Promise<Entity[]>;
    /**
     * Searches experience with optional search options.
     */
    searchXperience: (options?: SearchXperienceProps) => Promise<Entity[]>;
    /**
     * Shows a tab with given properties.
     */
    showTab: (props: ShowTabProps) => Promise<void>;
    /**
     * Closes a tab with given properties.
     */
    closeTab: (props: ShowTabProps) => Promise<void>;
    /**
     * Calls an application service with given properties.
     */
    callAppService: (props: AppServiceCallProps) => Promise<any>;
    /**
     * Shows a context menu with given properties.
     */
    showContextMenu: (props: ContextMenuRequest) => Promise<void>;
    /**
     * Shows a toast notification.
     */
    showToast: (notification: OsNotification) => Promise<void>;
    /**
     * Clears a toast notification by ID.
     */
    clearToast: (id: string) => Promise<void>;
    /**
     * Shows a progress item.
     */
    showProgress: (progress: OsProgress) => Promise<void>;
    /**
     * Wraps a promise with a progress bar.
     */
    withProgressBar: <T>(promise: Promise<T>, options?: WithProgressBarOptions) => Promise<T>;
    /**
     * Shows a confirmation modal.
     */
    showConfirm: (props: OsConfirmProps) => Promise<OS_CONFIRM_MODAL_RESPONSE>;
    /**
     * Shows a file upload dialog.
     */
    showFileUpload: (folder: WorkspaceItem) => Promise<WorkspaceItem[]>;
    /**
     * Shows a form for creating an entity.
     */
    showCreateEntityForm: (props: CreateEntityFormProps) => Promise<OsWorkspaceEntity[]>;
    /**
     * Shows a dialog for creating relations.
     */
    showCreateRelationsDialog: (props: CreateRelationsDialogProps) => Promise<void>;
    /**
     * Shows a modal for saving as.
     */
    showSaveAsModal: (props: SaveAsModalProps) => Promise<WorkspaceItem | undefined>;
    /**
     * Gets a paste context with optional options.
     */
    getPasteContext: (options: PasteContextOptions) => Promise<Entity[]>;
    /**
     * Shows a modal template.
     */
    showModalTemplate: (props: ModalTemplateProps) => Promise<void>;
    /**
     * Adds a comment to an entity.
     */
    addComment: (about: Entity, comment: AddCommentParams) => Promise<Entity>;
    /**
     * Adds a watch intent to an entity.
     */
    addWatchIntent: (entity: Entity, watcher: Watcher) => Promise<Entity>;
    /**
     * Removes a watch intent by workspace and intent ID.
     */
    removeWatchIntent: (os_workspace: string, intent_id: string) => Promise<void>;
    /**
     * Gets workspace permissions by IDs.
     */
    getWorkspacePermission: (os_worpsaces: string[]) => Promise<{
        [os_workspace: string]: WorkspacePermission;
    }>;
    /**
     * Gets the user profile.
     */
    getUser: () => Promise<UserProfile>;
    /**
     * Deploys an application with optional initial secrets.
     */
    deployApp: (app: WorkspaceItem | App, initialSecrets?: {
        [key: string]: string;
    }) => Promise<WorkspaceItem>;
    /**
     * Undeploys an application.
     */
    undeployApp: (app: WorkspaceItem | App) => Promise<WorkspaceItem>;
    /**
     * Gets information about the current user.
     */
    whoami: () => Promise<Whoami>;
    /**
     * Gets the focus list.
     */
    getFocusList: () => Promise<FocusListItem[]>;
    /**
     * Adds entities to the focus list with optional type and tab name.
     */
    addToFocusList: (entities: Entity[], type?: 'single' | 'group', tabName?: string) => Promise<FocusListItem[]>;
    /**
     * Removes entities from the focus list with optional type and tab name.
     */
    removeFromFocusList: (entities: Entity[], type?: 'single' | 'group', tabName?: string) => Promise<FocusListItem[]>;
    /**
     * Gets the image URL for an entity.
     */
    getImageUrl: (entity: EntityBase) => Promise<string>;
    /**
     * Gets images for an entity.
     */
    getImages: (entity: Entity) => Promise<Entity[]>;
    /**
     * Gets icon code for an entity, concept, or string.
     */
    internalGetIconCode: (x: Entity | Concept | string, defaultIcon?: string) => Promise<string>;
    /**
     * Gets JSON schema for a concept.
     */
    getJSONSchema: (concept: string) => Promise<{
        schema: string;
        schemaUI: string;
    }>;
    /**
     * Connect an attachment to an entity as featured_in
     */
    addAttachment: (entity: WorkspaceItem, file?: WorkspaceItem) => void;
    /**
     * Trigger a modal to allow users to manage the unzipping and extraction process within the workspace.
     */
    unzipFiles: (entity: WorkspaceItem, file: File) => void;
    /**
     * Get config files
     */
    getConfigFiles: (name: string) => Promise<WorkspaceItem[]>;
    /**
     * "Cache" for workspaces, avoiding to return a modal error, if this workspace was fetched before
     */
    workspaceStore: {
        [os_workspace: string]: Workspace;
    };
    getWhitelabelingInfo(): Promise<{
        OCTOSTAR_MAIN_LOGO: string;
        OCTOSTAR_FAVICON: string;
        OCTOSTAR_SPINNER: string;
    }>;
}

/**
 * Function for desktop actions.
 * @beta
 */
export declare type DesktopAction = (context: DesktopActionContext) => any;

/**
 * Context for desktop actions.
 * @beta
 */
export declare interface DesktopActionContext extends ActionContext {
    /**
     * Event emitter type.
     */
    ee: EventEmitterType;
    /**
     * Prefix for event topics.
     */
    eventTopicPrefix?: string;
    /**
     * Options for the action.
     */
    options?: DesktopActionOptions;
}

/**
 * Filter for desktop actions.
 * @beta
 */
export declare type DesktopActionFilter = (context: DesktopActionContext) => boolean;

/**
 * Menu item for desktop actions.
 * @beta
 */
export declare type DesktopActionMenuItem = {
    /**
     * Label for the menu item.
     */
    label: ReactNode;
    /**
     * Key for the menu item.
     */
    key: string;
    /**
     * Icon for the menu item.
     */
    icon: Icon;
    /**
     * Service related to the menu item.
     */
    service?: string;
    /**
     * Additional options for the menu item.
     */
    with?: string;
    /**
     * Group for the menu item. Default is 'general'.
     */
    group?: DesktopActionMenuItemGroup;
    /**
     * Subgroup for the menu item.
     */
    subgroup?: string;
    /**
     * Order of the menu item.
     */
    order?: number;
    /**
     * Children menu items.
     */
    children?: DesktopActionMenuItem[] | ((props: DesktopActionContext) => DesktopActionMenuItem[]);
    /**
     * Filter for accepting the menu item.
     */
    accepts: DesktopActionFilter;
    /**
     * Function to invoke the action.
     */
    invoke: DesktopAction;
};

/**
 * Group for desktop action menu items.
 * @beta
 */
export declare type DesktopActionMenuItemGroup = ContextMenuGroup;

/**
 * Options for desktop actions.
 * @beta
 */
export declare type DesktopActionOptions = {
    /**
     * ID of the tab.
     */
    tabId?: string;
    /**
     * ID of the tab to place beside.
     */
    besideTabId?: string;
    /**
     * Whether to auto-select the tab.
     */
    autoSelectTab?: boolean;
    /**
     * Function to call on closing the tab.
     */
    onCloseTab?: () => void;
    /**
     * Additional options for the action.
     */
    with?: string;
    /**
     * Initial state for the action.
     */
    initialState?: any;
    /**
     * Whether to open in a new tab.
     */
    newTab?: boolean;
    /**
     * Whether to open in a modal window.
     */
    modal?: boolean;
    /**
     * Whether to preserve the state of the tab after action is finished. Used with modal.
     */
    preserve?: boolean;
    /**
     * Whether to raise the tab to the front.
     */
    raiseOnly?: boolean;
    /**
     * Open tab in a new tabset
     */
    newTabset?: boolean;
    /**
     * Wait for the tab to open
     */
    awaitShowTab?: boolean;
};

/**
 * Parameters for opening a desktop.
 * @beta
 */
export declare type DesktopOpenParams = {
    /**
     * Options for the desktop action.
     */
    options?: DesktopActionOptions;
    /**
     * Items to be opened.
     */
    items: Entity[];
};

/**
 * Interface for desktop settings.
 * @beta
 */
export declare interface DesktopSettings {
    /**
     * Gets the IDs of open workspaces.
     */
    getOpenWorkspaceIds: () => Promise<string[]>;
    /**
     * Sets the IDs of open workspaces.
     */
    setOpenWorkspaceIds: (ids: string[]) => Promise<void>;
    /**
     * Listener for changes in open workspace IDs list (list gets updated on eg close / open event)
     */
    onOpenWorkspaceIdsChanged: AddListener<string[]>;
}

/**
 * Context for desktop styler.
 * @beta
 */
export declare type DesktopStylerContext = {
    /**
     * Graph specification.
     */
    graph: GraphSpec;
    /**
     * Selected graph specification.
     */
    selected?: GraphSpec;
};

/**
 * Represents a draft workspace item.
 * @beta
 */
export declare type DraftWorkspaceItem = WorkspaceItem & {
    /**
     * Indicates if the item is a draft. The attribute is not saved in persistence.
     */
    os_draft_item: true;
};

/**
 * Parameters for drag end.
 * @beta
 */
export declare type DragEndParams = {
    /**
     * Record being dragged.
     */
    record: Entity;
    /**
     * Records being dragged.
     */
    records: Entity[];
    /**
     * X-coordinate of the drag end position.
     */
    x: number;
    /**
     * Y-coordinate of the drag end position.
     */
    y: number;
};

/**
 * Parameters for drag start.
 * @beta
 */
export declare type DragStartParams = {
    /**
     * Record being dragged.
     */
    record: Entity;
    /**
     * Records being dragged.
     */
    records: Entity[];
    /**
     * Topic for drag end event.
     */
    dragEndTopic: string;
};

export declare type DropZoneRequestFn = (args: any[]) => Promise<DropZoneRequestResult>;

export declare type DropZoneRequestResult = {
    to: any;
    data: any;
};

/**
 * @beta
 * Type representing a connection between two entities with a relationship.
 */
export declare type EConnection = {
    /** The first entity in the connection. */
    entity1: Entity;
    /** The second entity in the connection. */
    entity2: Entity;
    /** The relationship between the two entities. */
    relationship: Relationship;
};

/**
 * @beta
 * Type representing the specification of an edge in a graph.
 */
export declare type EdgeSpec = {
    /** The identifier of the starting node. */
    from: string;
    /** The identifier of the ending node. */
    to: string;
    /** The label for the edge. */
    label: string;
};

/**
 * @beta
 * Type representing a transform definition that emits an event.
 */
export declare type EmitEventTransformDefinition = {
    /** The type of the transform, always 'emit_event' for this type. */
    type: 'emit_event';
    /** The topic of the event to emit. */
    topic: string;
    /** The arguments for the event. */
    args: string[];
};

/**
 * Represents an entity with basic attributes.
 * @beta
 */
export declare type Entity = EntityBase & {
    /**
     * The label of the entity.
     */
    entity_label: string;
};

/**
 * Represents an entity without a label.
 * @beta
 */
export declare type EntityBase = {
    /**
     * The ID of the entity.
     */
    entity_id: string;
    /**
     * The type of the entity.
     */
    entity_type: string;
};

/**
 * @beta
 * Type representing an edge between two entities with a relationship.
 */
export declare type EntityEdge = {
    /** The starting entity of the edge. */
    from: Entity;
    /** The ending entity of the edge. */
    to: Entity;
    /** The relationship between the two entities. */
    relationship: Relationship;
};

/**
 * Represents an entity with additional attributes for one-to-many relationships.
 * @beta
 */
export declare type EntityOTM = Entity & {
    /**
     * The UID of the source entity.
     */
    source_entity_uid: string;
    /**
     * The type of the source entity.
     */
    source_entity_type: string;
};

/**
 * Context for pasting entities.
 * @beta
 */
export declare type EntityPasteContext = {
    /**
     * Counts the number of entities.
     */
    count: () => Promise<number>;
    /**
     * Fetches entities with a limit.
     */
    fetch: (limit?: number) => Promise<Entity[]>;
};

export declare type EvalContext = {
    variables: {
        [key: string]: any;
    };
    filters: {
        [key: string]: DesktopActionFilter;
    };
    transforms: {
        [key: string]: Function;
    };
};

/**
 * @beta
 * Type representing the event context, including methods to manage event publishing and subscription.
 */
export declare type EventContextType = {
    /** The event emitter instance. */
    EE: EventEmitterType;
    /** Function to publish events. */
    publish: EventPublisher;
    /** Function to subscribe to events. */
    subscribe: EventSubscriber;
    /** Function to unsubscribe from events. */
    unsubscribe: EventUnsubscriber;
};

/**
 * @beta
 * Type representing an event emitter with methods to manage events.
 */
export declare type EventEmitterType = {
    /**
     * Emits an event.
     * @param event - The name or symbol of the event.
     * @param args - The arguments to pass to the event listeners.
     */
    emit: (event: string | symbol, ...args: any[]) => void;
    /**
     * Registers an event listener.
     * @param event - The name or symbol of the event.
     * @param fn - The function to call when the event is emitted.
     */
    on: (event: string | symbol, fn: (...args: any[]) => void) => void;
    /**
     * Registers a one-time event listener.
     * @param event - The name or symbol of the event.
     * @param fn - The function to call when the event is emitted.
     */
    once: (event: string | symbol, fn: (...args: any[]) => void) => void;
    /**
     * Removes an event listener.
     * @param event - The name or symbol of the event.
     * @param fn - The function to remove from the event listeners.
     */
    off: (event: string | symbol, fn: (...args: any[]) => void) => void;
};

/**
 * @beta
 * Type representing an event name, which can be a string or symbol.
 */
export declare type EventName = string | symbol;

/**
 * @beta
 * Type representing a function that produces events.
 * @param eventName - The name of the event.
 * @param data - The data associated with the event.
 * @returns The result of the event production.
 */
export declare type EventProducer = (eventName: EventName, data: any) => any;

/**
 * @beta
 * Type representing a function that publishes events.
 * @template T - The type of the event data.
 * @param eventName - The name of the event.
 * @param data - The data associated with the event.
 */
export declare type EventPublisher = <T>(eventName: EventName, data: T) => void;

/**
 * @beta
 * Type representing a function that subscribes to events.
 * @template L - The type of the event listener payload.
 * @param eventName - The name of the event.
 * @param listener - The event listener to add.
 * @returns The function to unsubscribe the event listener.
 */
export declare type EventSubscriber = <L>(eventName: EventName, listener: CustomEventListener<L>) => EventUnsubscriber;

/**
 * @beta
 * Type representing a function that unsubscribes from events.
 * @template L - The type of the event listener payload.
 * @param eventName - The name of the event.
 * @param listener - The event listener to remove.
 */
export declare type EventUnsubscriber = <L>(eventName: EventName, listener: CustomEventListener<L>) => void;

/**
 * Options for exporting items.
 * @beta
 */
export declare type ExportOptions = {
    /**
     * Filename for the export.
     */
    filename?: string;
};

/**
 * Options for extracting entities.
 * @beta
 */
export declare type ExtractEntitiesOptions = {
    hydrate?: boolean;
};

export declare type ExtrasApi = {
    createLinkChart: CreateLinkChartFn;
};

/**
 * Options for fetching an entity.
 * @beta
 */
export declare type FetchEntityOptions = {};

/**
 * @beta
 * Options for fetching data from an API.
 */
export declare interface FetchOptions extends Omit<RequestInit, 'body'> {
    /**
     * The API endpoint to hit, starting with a slash.
     */
    endpoint: string;
    /** A BodyInit object, object or null to set request's body. */
    body?: BodyInit | object | null;
}

/**
 * @beta
 * File containing the code. Not yet supported.
 */
export declare type FileCode = {
    /** The file containing the code. */
    file: string;
};

/**
 * Options for file tree.
 * @beta
 */
export declare type FileTreeOptions = {
    /**
     * Whether to recurse in the file tree.
     */
    recurse?: boolean;
    /**
     * Whether to exclude the root from the file tree.
     */
    exclude_root?: boolean;
    /**
     * Whether to flatten the file tree.
     */
    flat?: boolean;
    /**
     * Whether to show minimal information in the file tree.
     */
    minimal?: boolean;
    /**
     * Whether to include structure in the file tree.
     */
    structure?: boolean;
};

export declare type Filter = {
    cascadeParentIds: string[];
    defaultDataMask: DataMask;
    id: string;
    name: string;
    scope: NativeFilterScope;
    filterType: string;
    targets: [Partial<NativeFilterTarget>];
    controlValues: {
        [key: string]: any;
    };
    sortMetric?: string | null;
    adhoc_filters?: Record<any, any>[];
    granularity_sqla?: string;
    granularity?: string;
    time_grain_sqla?: string;
    time_range?: string;
    requiredFirst?: boolean;
    tabsInScope?: string[];
    chartsInScope?: number[];
    type: 'NATIVE_FILTER';
    description: string;
};

/**
 * @beta
 * Type representing a filter definition, which can be one of several specific filter types.
 */
export declare type FilterDefinition = ProvidedFilterDefinition | JavascriptFilterDefinition | SemanticallyBoundFilterDefinition;

/**
 * @beta
 * Type representing a collection of filter definitions.
 */
export declare type FilterDefinitions = {
    [k: FilterName]: FilterDefinition;
};

/**
 * @beta
 * Type representing the name of a filter.
 */
export declare type FilterName = string;

/**
 * @beta
 * Type representing a reference to a filter, which can be a string or an object requiring all filters.
 */
export declare type FilterReference = string | {
    ['require_all']: FilterReference[];
};

export declare type FilterState = {
    value?: any;
    [key: string]: any;
};

/**
 * Represents an item in a focus list.
 * @beta
 */
export declare type FocusListItem = {
    entity: Entity;
    count: number;
    tabName?: string;
    type?: 'single';
} | NamedEntityGroup;

/**
 * Options for pasting folders.
 * @beta
 */
export declare type FolderPasteOptions = {
    /**
     * Whether to include folders in the paste.
     */
    folders?: boolean;
    /**
     * Whether to include files in the paste.
     */
    files?: boolean;
    /**
     * Whether to paste recursively.
     */
    recursive?: boolean;
};

declare enum GenericDataType {
    NUMERIC = 0,
    STRING = 1,
    TEMPORAL = 2,
    BOOLEAN = 3
}

/**
 * Options for getting attachments.
 * @beta
 */
export declare interface GetAttachmentOptions<T extends AttachmentType> {
    /**
     * Path to the attachment.
     */
    path?: string;
    /**
     * Default value for the attachment.
     */
    default?: T;
    /**
     * Response type for the attachment.
     */
    responseType?: AttachmentResponseType;
}

export declare type GraphDataSpec = {
    entities: Entity[];
    relationships: EntityEdge[];
};

/**
 * @beta
 * Type representing the specification of a graph.
 */
export declare type GraphSpec = {
    /** Optional workspace item associated with the graph. */
    workspace_item?: Entity;
    /** The nodes (entities) in the graph. */
    nodes: Entity[];
    /** The edges connecting the nodes in the graph. */
    edges: EdgeSpec[];
};

/**
 * @beta
 * Type representing an HTTP transform definition.
 */
export declare type HttpTransformDefinition = {
    /** The type of the transform, always 'http' for this type. */
    type: 'http';
    /** The HTTP method for the transform. */
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD';
    /** The URL for the HTTP request, can be relative to the url of the deployed app */
    url: string;
    /** Optional headers for the HTTP request. */
    headers?: {
        [k: string]: string;
    };
    /** Optional data for the HTTP request. */
    data?: string | {
        [k: string]: any;
    };
};

/**
 * Type for icons.
 * @beta
 */
export declare type Icon = IconProps | string;

/**
 * Represents properties for an icon.
 * @beta
 */
export declare type IconProps = {
    /**
     * Name of the icon.
     */
    icon: string;
    /**
     * Optional class name for styling.
     */
    className?: string;
    /**
     * Rotation angle for the icon.
     */
    rotate?: number;
    /**
     * Whether the icon should spin.
     */
    spin?: boolean;
    /**
     * CSS properties for the icon.
     */
    style?: ReactCssProperties;
    /**
     * Reference to the HTML span element.
     */
    iconRef?: ReactRef<HTMLSpanElement>;
};

/**
 * @beta
 * Interface for managing data transfer during drag and drop operations.
 */
export declare interface IDataTransfer {
    /**
     * Clears the data for the specified format or all formats if none is specified.
     * @param format - The format of the data to clear.
     */
    clearData(format?: string): void;
    /**
     * Sets the data for the specified format.
     * @param format - The format of the data.
     * @param data - The data to be set.
     */
    setData(format: string, data: string): void;
    /**
     * Retrieves the data for the specified format.
     * @param format - The format of the data to retrieve.
     * @returns The data for the specified format, or null if not found.
     */
    getData(format: string): string | null;
    /**
     * Sets the image to be used for dragging.
     * @param img - The image element to be used.
     * @param xOffset - The horizontal offset.
     * @param yOffset - The vertical offset.
     */
    setDragImage?(img: Element, xOffset: number, yOffset: number): void;
    /** The drop effect for the drag operation. */
    readonly dropEffect: string;
    /** The effect allowed for the drag operation. */
    readonly effectAllowed: string;
    /** The list of files being transferred. */
    readonly files: FileList;
    /** The types of data being transferred. */
    readonly types: string[];
    /** The items being transferred. */
    readonly items: DataTransferItemList;
}

/**
 * @beta
 * Type representing an iframe transform definition.
 */
export declare type IframeTransformDefinition = {
    /** The type of the transform, always 'iframe' for this type. */
    type: 'iframe';
    /** The URL to load in the iframe. */
    url: string;
    /** The title of the iframe. */
    title: string;
    /** The icon for the iframe. */
    icon: string;
    /** Whether to reuse the tab for the iframe. */
    reuse_tab?: boolean;
};

/**
 * Represents information about an image.
 * @beta
 */
export declare type ImageInfo = {
    /**
     * The blurhash of the image.
     */
    blurhash?: string;
    /**
     * The natural width of the image.
     */
    width: number;
    /**
     * The natural height of the image.
     */
    height: number;
};

/**
 * Options for importing ZIP files.
 * @beta
 */
export declare type ImportZipOptions = {
    /**
     * Whether to overwrite existing items.
     */
    overwrite?: boolean;
    /**
     * Target location for the import.
     */
    target?: string;
    /**
     * Whether to include content in the import.
     */
    include_content?: boolean;
    /**
     * Whether to include dashboards in the import.
     */
    include_dashboards?: boolean | 'if_missing';
};

/**
 * Represents an inheritance relationship between concepts.
 * @beta
 */
export declare interface Inheritance {
    /**
     * The base concept in the inheritance.
     */
    base_concept: ConceptName;
    /**
     * The derived concept in the inheritance.
     */
    derived_concept: ConceptName;
    /**
     * The name will be displayed on ui
     */
    display_name: string;
}

/**
 * @beta
 * Inline code.
 */
export declare type InlineCode = {
    /** The inline code. */
    code: string;
};

/**
 * @beta
 * Type representing a JavaScript file styler definition.
 */
export declare type JavascriptFileStylerDefinition = JavascriptType & FileCode;

/**
 * @beta
 * Type representing a JavaScript file transform definition. Not yet supported.
 */
export declare type JavascriptFileTransformDefinition = JavascriptType & FileCode;

/**
 * @beta
 * Type representing a JavaScript filter definition.
 */
export declare type JavascriptFilterDefinition = {
    /** The type of the filter, always 'javascript' for this type. */
    type: 'javascript';
    /** The JavaScript code defining the filter. */
    code: string;
};

/**
 * @beta
 * Type representing an inline JavaScript styler definition.
 */
export declare type JavascriptInlineStylerDefinition = JavascriptType & InlineCode;

/**
 * @beta
 * Type representing an inline JavaScript transform definition.
 */
export declare type JavascriptInlineTransformDefinition = JavascriptType & InlineCode;

/**
 * @beta
 * Type representing a JavaScript transform definition.
 */
export declare type JavascriptType = {
    /** The type of the transform or styler, always 'javascript' for this type. */
    type: 'javascript';
};

/**
 * @beta
 * Type representing a job manifest.
 */
export declare type JobManifest = {
    /** Name of the job. */
    name: string;
    /** Description of the job. */
    description: string;
    /** Icon for the job. */
    icon: string;
    /** Optional image for the job. */
    image?: string;
    /** Optional engine for the job. */
    engine?: 'k8s' | 's3' | 'reactlive';
    /** Optional template for the job. */
    template?: string;
    /** Optional variant for the job. */
    variant?: string;
    /** Optional instance type for the job. */
    instance_type?: string;
    /** Whether to skip archiving the job. */
    no_archive?: boolean;
    /** Whether to generate a URL from logs. */
    url_from_logs?: boolean;
    /** Reusable javascript functions */
    javascript?: string;
    /** How the app is semantically bound */
    semantic_bindings?: SemanticBindings;
    /** Optional collection of transforms for the job. */
    transforms?: TransformDefinitions;
    /** Optional collection of filters for the job. */
    filters?: FilterDefinitions;
    /** Optional collection of stylers for the job. */
    stylers?: StylerDefinitions;
    /** Optional collection of services for the job. */
    services?: ServiceDefinitions;
    secrets?: ManifestSecrets;
};

/**
 * @beta
 * Type representing known counts of relationships.
 */
export declare type KnownCounts = {
    [relationship_name: string]: number;
};

export declare type ManifestSecrets = {
    [key: string]: {
        description: string;
        default?: string;
        required?: boolean;
    };
};

/**
 * @beta
 * Type representing the properties for a modal template, extending CustomTemplateIframeProps.
 */
export declare type ModalTemplateProps = CustomTemplateIframeProps & {
    /** Optional properties for the modal. */
    modalProps?: ModalProps;
    /** Whether the modal is open. */
    isModalOpen: boolean;
    /**
     * Function to set the open state of the modal.
     * @param open - The new open state of the modal.
     */
    setIsModalOpen: (open: boolean) => void;
    /** Callback function to be called on completion. */
    onComplete?: () => void;
    /** Callback function to be called on cancel. */
    onCancel?: () => void;
    /** The task ID associated with the modal. */
    taskID?: string;
};

/**
 * Represents a named group (set?) entities.
 * @beta
 */
export declare type NamedEntityGroup = {
    /**
     * The label for the entity group.
     */
    entity_label: string;
    /**
     * The query to provide the entites
     */
    query: ConceptFilter;
    /**
     * The count of entities in the group.
     */
    count: number;
    /**
     * The type of the entity group, always set to 'group'.
     */
    type: 'group';
};

export declare interface NativeFilterColumn {
    name: string;
    displayName?: string;
}

export declare interface NativeFilterScope {
    rootPath: string[];
    excluded: number[];
}

export declare interface NativeFilterTarget {
    datasetId: number;
    column: NativeFilterColumn;
}

/**
 * @beta
 * Type representing a Nunjucks file transform definition. Not yet supported.
 */
export declare type NunjucksFileTransformDefinition = NunjucksType & FileCode;

/**
 * @beta
 * Type representing an inline Nunjucks transform definition.
 */
export declare type NunjucksInlineTransformDefinition = NunjucksType & {
    /** The Nunjucks template. */
    template: string;
};

/**
 * @beta
 * Type representing a Nunjucks transform definition.
 */
export declare type NunjucksType = {
    /** The type of the transform or styler, always 'nunjucks' for this type. */
    type: 'nunjucks';
};

/**
 * @beta
 * Interface representing ontology operations.
 */
export declare interface Ontology {
    /**
     * Cancels queries in the given context.
     * @param context - The context in which to cancel queries.
     * @returns A promise that resolves when the operation is complete.
     */
    cancelQueries: (context: string) => Promise<void>;
    /**
     * Gets the available ontologies.
     * @returns A promise that resolves to an array of available ontology names.
     */
    getAvailableOntologies: () => Promise<string[]>;
    /**
     * Gets workspace relationship records for a given entity and relationship.
     * @param entity - The entity for which to get relationship records.
     * @param rel - The relationship or relationship name.
     * @returns A promise that resolves to an array of workspace relationships.
     */
    getWorkspaceRelationshipRecords(entity: Entity, rel: string | Relationship): Promise<WorkspaceRelationship[]>;
    /**
     * Clears the relationship cache for a given entity and relationship.
     * @param entity - The entity for which to clear the cache.
     * @param relationship - The relationship or relationship name.
     * @param inverse - Whether to clear the inverse relationship cache.
     * @returns A promise that resolves when the operation is complete.
     */
    clearRelationshipCache: (entity: Entity, relationship: Relationship | string, inverse?: boolean) => Promise<void>;
    /**
     * Gets connected entities for a given entity and relationship.
     * @param entity - The entity for which to get connected entities.
     * @param relationship - The relationship or relationship name.
     * @param forceRefresh - Whether to force a refresh of the data.
     * @returns A promise that resolves to an array of connected entities.
     */
    getConnectedEntities: <T extends Entity>(entity: Entity, relationship: Relationship | string, forceRefresh?: boolean) => Promise<T[]>;
    /**
     * Gets connections by type for a given entity and concept.
     * @param entity - The entity for which to get connections.
     * @param concept - The concept for which to get connections.
     * @returns A promise that resolves to an array of connections.
     */
    getConnectionsByType: <T extends Entity>(entity: Entity, concept: string, handler?: (connections: EConnection[]) => Promise<void>) => Promise<EConnection[]>;
    /**
     * Gets the concept names.
     * @returns A promise that resolves to an array concept names.
     */
    getConceptNames: () => Promise<string[]>;
    /**
     * Gets a concept by its name.
     * @param conceptName - The name of the concept.
     * @returns A promise that resolves to the concept or undefined if not found.
     */
    getConceptByName: (conceptName: string) => Promise<Concept | undefined>;
    /**
     * Gets all concepts.
     * @returns A promise that resolves to a map of concept names to concepts.
     */
    getConcepts: () => Promise<Map<string, Concept>>;
    /**
     * Gets an entity.
     * @param e - The entity to get.
     * @param refresh - Whether to refresh the data.
     * @param skipSideEffects - Whether to skip side effects.
     * @returns A promise that resolves to the entity.
     */
    getEntity: <T extends Entity>(e: Entity, refresh?: boolean, skipSideEffects?: boolean) => Promise<T>;
    /**
     * Gets the name of the ontology.
     * @returns A promise that resolves to the name of the ontology.
     */
    getOntologyName: () => Promise<string>;
    /**
     * Gets the relationship count for a given entity and relationship.
     * @param entity - The entity for which to get the relationship count.
     * @param rel - The relationship or relationship name.
     * @param forceRefresh - Whether to force a refresh of the data.
     * @returns A promise that resolves to the relationship count result.
     */
    getRelationshipCount: (entity: Entity, rel: Relationship | string, forceRefresh?: boolean) => Promise<RelationshipCountResult>;
    /**
     * Gets the concept for a given entity.
     * @param entity - The entity for which to get the concept.
     * @returns A promise that resolves to the concept or undefined if not found.
     */
    getConceptForEntity: (entity: Entity) => Promise<Concept | undefined>;
    /**
     * Gets the relationships for a given entity.
     * @param entity - The entity for which to get relationships.
     * @returns A promise that resolves to an array of relationships.
     */
    getRelationshipsForEntity: (entity: Entity) => Promise<Relationship[]>;
    /**
     * Checks whether a concept exists.
     * @param conceptName - The name of the concept.
     * @returns A promise that resolves to a boolean indicating whether the concept exists.
     */
    isConcept: (conceptName: string) => Promise<boolean>;
    /**
     * Sends a query.
     * @param query - The query string.
     * @param options - Optional options for sending the query.
     * @returns A promise that resolves to the query response.
     */
    sendQuery: (query: string, options?: SendQueryOptions) => Promise<QueryResponse>;
    /**
     * Sends a query with a typed response.
     * @param query - The query string.
     * @param options - Optional options for sending the query.
     * @param force_refresh - Whether to force a refresh of the data.
     * @returns A promise that resolves to an array of results.
     */
    sendQueryT: <T>(query: string, options?: SendQueryOptions, force_refresh?: boolean) => Promise<T[]>;
    /**
     * Gets the system inheritance.
     * @returns A promise that resolves to an array of inheritances.
     */
    getSysInheritance(): Promise<Inheritance[]>;
    /**
     * Subscribes to changes for a given entity.
     * @param entity - The entity to subscribe to.
     * @param callback - The callback to invoke on changes.
     * @param skipInitialCallback - Whether to skip the initial callback.
     * @returns A promise that resolves to an unsubscribe function.
     */
    subscribe: <T>(entity: Entity, callback: Callback<T>, skipInitialCallback?: boolean) => Promise<Unsubscribe>;
    /**
     * Generates a consistent UUID.
     * @param name - The name for which to generate the UUID.
     * @param namespace - Optional namespace for the UUID.
     * @returns A promise that resolves to the UUID.
     */
    consistentUUID: (name: string, namespace?: string) => Promise<string>;
    /**
     * Updates the cache with the given entities.
     * @param entities - The entities to update in the cache.
     * @returns A promise that resolves to the updated entities.
     */
    updateCache: (entities: (Entity & WorkspaceItem)[]) => Promise<(Entity & WorkspaceItem)[]>;
}

/**
 * @beta
 * Type representing tags associated with an ontology.
 */
export declare type OntologyTags = {
    /** The target type of the tag. */
    target_type: string;
    /** The target name of the tag. */
    target_name: string;
    /** The name of the tag. */
    tag_name: string;
    /** The value of the tag. */
    tag_value: string;
};

/**
 * Option to get out of the confirmation modal.
 * @beta
 */
export declare const OS_CONFIRM_MODAL_CANCEL: undefined;

/**
 * Negative option for the confirmation modal.
 * @beta
 */
export declare const OS_CONFIRM_MODAL_NO = false;

/**
 * Response type for confirmation modal.
 * @beta
 */
export declare type OS_CONFIRM_MODAL_RESPONSE = typeof OS_CONFIRM_MODAL_YES | typeof OS_CONFIRM_MODAL_NO | typeof OS_CONFIRM_MODAL_CANCEL;

/**
 * Affirmative option for the confirmation modal.
 * @beta
 */
export declare const OS_CONFIRM_MODAL_YES = true;

/**
 * @beta
 * Interface representing a client for interacting with the OctoStar API.
 */
export declare interface OsAPIClient {
    /**
     * Fetch data from the API.
     * @param options - Configuration options for the fetch request.
     * @returns A promise that resolves with the fetched data of type T.
     */
    fetchData<T>(options: FetchOptions): Promise<T>;
    /**
     * Stream data from the API.
     * @param options - Configuration options for the stream request.
     * @returns A promise that resolves when the streaming is complete.
     */
    streamData(options: FetchOptions): Promise<ReadableStream<Uint8Array>>;
    /**
     * Streams text data from the API.
     * @param options - Configuration options for the stream request.
     * @returns A promise that resolves when the streaming is complete.
     */
    streamText(options: StreamTextOptions): Promise<void>;
    /**
     * Streams JSON line data from the API.
     * @param options - Configuration options for the stream request.
     * @returns A promise that resolves when the streaming is complete.
     */
    streamJson<T>(options: StreamJsonOptions<T>): Promise<void>;
}

/**
 * Represents audit fields for OS (Operational Support) records.
 * @beta
 */
export declare type OsAuditFields = {
    /**
     * User who created the record.
     */
    os_created_by?: string;
    /**
     * Timestamp when the record was created.
     */
    os_created_at?: string;
    /**
     * User who deleted the record.
     */
    os_deleted_by?: string;
    /**
     * Timestamp when the record was deleted.
     */
    os_deleted_at?: string;
    /**
     * User who hid the record.
     */
    os_hidden_by?: string;
    /**
     * Timestamp when the record was hidden.
     */
    os_hidden_at?: string;
    /**
     * User who last updated the record.
     */
    os_last_updated_by?: string;
    /**
     * Timestamp when the record was last updated.
     */
    os_last_updated_at?: string;
};

/**
 * Properties for confirmation modal.
 * @beta
 */
export declare type OsConfirmProps = string | {
    /**
     * Title of the confirmation modal.
     */
    title: string;
    /**
     * Icon for the confirmation modal.
     */
    icon?: string;
    /**
     * Content of the confirmation modal.
     */
    content?: string;
    /**
     * Text for the OK button.
     */
    okText?: string;
    /**
     * Properties for the OK button.
     */
    okButtonProps?: ButtonProps;
    /**
     * Text for the cancel button.
     */
    cancelText?: string;
    /**
     * Task ID related to the confirmation modal.
     */
    taskID?: string;
};

/**
 * Type for notifications.
 * @beta
 */
export declare type OsNotification = string | {
    /**
     * ID of the notification.
     */
    id?: string;
    /**
     * Message of the notification.
     */
    message: string | ReactNode;
    /**
     * Description of the notification.
     */
    description?: string;
    /**
     * Level of the notification.
     */
    level?: 'info' | 'success' | 'error' | 'warning';
    /**
     * Additional details for the notification.
     */
    detail?: {
        [key: string]: any;
    };
    /**
     * Placement of the notification.
     */
    placement?: 'top' | 'bottom' | 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
};

/**
 * Type for progress information.
 * @beta
 */
export declare type OsProgress = {
    /**
     * Key for the progress item.
     */
    key: string;
    /**
     * Label for the progress item.
     */
    label?: ReactNode;
    /**
     * Type of job for the progress item.
     */
    job_type?: string;
    /**
     * Status of the progress item.
     */
    status?: 'active' | 'success' | 'exception' | 'normal' | undefined;
};

/**
 * Represents a tag in the workspace.
 * @beta
 */
export declare type OsTag = WorkspaceRecord & TagAttributes;

/**
 * Represents a workspace entity.
 * @beta
 */
export declare type OsWorkspaceEntity = Entity & WorkspaceRecordIdentifier;

/**
 * @beta
 * Type representing a workspace item with its settings.
 */
export declare type OsWorkspacePickerProps = {
    onChange: (value: string) => void;
    desktop: any;
    openWorkspacesOnly?: boolean;
    defaultWorkspace?: string;
    checkActiveWorkspace?: boolean;
    permissions?: WorkspacePermissionValue;
    dashboardOptions?: {
        value: string;
        label: string;
    }[];
};

/**
 * Options for pasting context.
 * @beta
 */
export declare type PasteContextOptions = {
    /**
     * First limit for the context.
     */
    limit1?: number;
    /**
     * Second limit for the context.
     */
    limit2?: number;
    /**
     * Record for the context.
     */
    record?: Entity;
    /**
     * Records for the context.
     */
    records?: Entity[];
    /**
     * Query for the context.
     */
    query?: ConceptFilter;
    /**
     * Whether to return a SavedSet entity when a folder is dropped.
     */
    preferSavedSet?: boolean;
};

/**
 * @beta
 * Type representing a permission for a workspace item.
 */
export declare type Permission = WorkspaceItem & {
    /** The username associated with the permission. */
    os_username?: string;
    /** The permission value. */
    os_permission: number;
    /** The role associated with the permission. */
    os_role?: string;
    /** The flags associated with the permission */
    os_flags?: number;
};

/**
 * @beta
 * Type representing a point in 2D space.
 */
export declare type Point = {
    /** The x-coordinate of the point. */
    x: number;
    /** The y-coordinate of the point. */
    y: number;
};

/**
 * Represents the status of a processing operation.
 * @beta
 */
export declare interface ProcessingStatus {
    /**
     * The id of the entity being processed.
     */
    entity_id: string;
    /**
     * The type of the entity being processed.
     */
    entity_type: string;
    /**
     * The status code of the processing operation.
     */
    status_code: ProcessingStatusCode;
    /**
     * The reason for the processing operation.
     */
    reason: string;
    /**
     * The timeout for the processing operation.
     */
    timeout: number;
}

/**
 * Possible statuses of a NiFi pipeline task.
 * @beta
 */
export declare enum ProcessingStatusCode {
    /** Queued and awaiting execution */
    QUEUED = "QUEUED",
    /** Currently running */
    RUNNING = "RUNNING",
    /** Stopped manually */
    STOPPED = "STOPPED",
    /** Paused and can be resumed */
    PAUSED = "PAUSED",
    /** Completed successfully */
    COMPLETED = "COMPLETED",
    /** Encountered a failure */
    FAILED = "FAILED",
    /** Scheduled to run */
    SCHEDULED = "SCHEDULED",
    /** Starting up */
    STARTING = "STARTING",
    /** Shutting down */
    STOPPING = "STOPPING",
    /** Disabled and cannot run */
    DISABLED = "DISABLED",
    /** Invalid configuration */
    INVALID = "INVALID",
    /** Waiting for an external event */
    WAITING = "WAITING",
    /** Retrying after failure */
    RETRYING = "RETRYING",
    /** Status is unknown */
    UNKNOWN = "UNKNOWN"
}

/**
 * The options for the prompt.
 */
export declare type PromptOptions = {
    model?: string;
    apiKey?: string;
    stream?: boolean;
    enableRag?: boolean;
    cohereKey?: string;
};

/**
 * Represents a property of a concept.
 * @beta
 */
export declare interface Property {
    /**
     * The concept to which the property belongs.
     */
    concept: ConceptName;
    /**
     * The name of the property.
     */
    property_name: string;
    /**
     * The type of the property.
     */
    property_type: string;
}

/**
 * @beta
 * Type representing a filter definition that is provided.
 */
export declare type ProvidedFilterDefinition = {
    /** The type of the filter, always 'provided' for this type. */
    type: 'provided';
};

/**
 * @beta
 * Type representing a provided transform definition.
 */
export declare type ProvidedTransformDefinition = {
    /** The type of the transform, always 'provided' for this type. */
    type: 'provided';
};

/**
 * @beta
 * Type representing a query, which can be a string or a function returning a promise.
 */
export declare type Query = string | (() => Promise<string | string[] | undefined>);

/**
 * @beta
 * Type representing a batch query result, which includes a query ID.
 * @template T - The type of the data returned in case of success.
 */
export declare type QueryBatchResult<T> = (QuerySuccessResult<T> | QueryErrorResult) & {
    /** The ID of the query. */
    query_id: string;
};

/**
 * @beta
 * Type representing an error query result.
 */
export declare type QueryErrorResult = {
    /** The status of the query result, always 'error' for this type. */
    status: 'error';
    /** The error message or data. */
    data: string;
};

/**
 * @beta
 * Interface representing a query executor.
 */
export declare type QueryExecutor = {
    /**
     * Sends a query.
     * @param query - The query to send.
     * @param options - Optional options for sending the query.
     * @returns A promise that resolves to the query response.
     */
    sendQuery: (query: Query, options?: SendQueryOptions) => Promise<QueryResponse>;
};

/**
 * @beta
 * A union type that represents all possible filter clauses in a query object.
 * It can be either a binary filter clause or a unary filter clause.
 */
export declare type QueryObjectFilterClause = BinaryObjectFilterClause | UnaryObjectFilterClause;

/**
 * @beta
 * Type representing a query response, which is an array of any type.
 */
export declare type QueryResponse = any[];

/**
 * @beta
 * Type representing a query result, which is an API result containing an array of any type.
 */
export declare type QueryResult = ApiResult<any[]>;

declare type QueryResult_2 = {
    language: string;
    query: string;
};

/**
 * @beta
 * Type representing a successful query result.
 * @template T - The type of the data returned.
 */
export declare type QuerySuccessResult<T> = {
    /** The status of the query result, always 'success' for this type. */
    status: 'success';
    /** The data returned by the query. */
    data: T[];
};

/**
 * @beta
 * Type representing a React CSS properties object.
 */
export declare type ReactCssProperties = Properties<string | number>;

/**
 * Represents a React node.
 * @beta
 */
export declare type ReactNode = any;

/**
 * @beta
 * Type representing a React ref.
 */
export declare type ReactRef<T> = RefCallback<T> | RefObject<T> | null;

/**
 * Represents a boolean value with an optional reason.
 * @beta
 */
export declare type ReasonedBoolean = {
    value: true;
} | {
    value: false;
    reason: string;
};

export declare interface RecordData extends ChartDataResponseResult {
    data: Record<string, any>[];
}

export declare type RecordFetchOptions = {
    all_columns: string[];
    order_by_cols: string[];
    row_limit: number;
    server_page_length: number;
};

/**
 * Interface for providing records.
 * @beta
 */
export declare interface RecordProvider {
    /**
     * Retrieves the total count of records.
     * @returns A promise that resolves to the number of records.
     */
    getCount: () => Promise<number>;
    /**
     * Retrieves a specific record by its index.
     * @param i - The index of the record to retrieve.
     * @returns A promise that resolves to the requested record.
     */
    getRecord: (i: number) => Promise<Entity>;
    /**
     * Optional method to handle deletion of a record.
     * @param entity - The entity to delete.
     * @returns A promise that resolves when the deletion is complete.
     */
    onDelete?: (entity: Entity) => Promise<void>;
    /**
     * Retrieves a message related to the records.
     * @returns A promise that resolves to the message, or undefined if no message is available.
     */
    getMessage(): Promise<string | undefined>;
}

/**
 * @beta
 * Type representing a React ref callback.
 */
export declare type RefCallback<T> = {
    bivarianceHack(instance: T | null): void;
}['bivarianceHack'];

/**
 * @beta
 * Type representing a React component.
 */
export declare interface RefObject<T> {
    readonly current: T | null;
}

/**
 * Represents a relationship between concepts.
 * @beta
 */
export declare interface Relationship {
    /**
     * Unique identifier for the relationship.
     */
    key: string;
    /**
     * Source concept in the relationship.
     */
    concept: ConceptName;
    /**
     * Target concept in the relationship.
     */
    target_concept: ConceptName;
    /**
     * Name of the relationship.
     */
    relationship_name: string;
    /**
     * Inverse name of the relationship.
     */
    inverse_name: string;
    /**
     * Properties of the source concept.
     */
    source_properties: string;
    /**
     * Properties of the target concept.
     */
    target_properties: string;
    /**
     * Name of the mapping.
     */
    mapping_name: string;
    /**
     * Additional properties associated with the relationship.
     */
    additional_properties: string;
    /**
     * Query used for mapping the relationship.
     */
    mapping_query: string;
    /**
     * Tables involved in the relationship.
     */
    tables: string;
    /**
     * JSON representation of the mapping.
     */
    mapping_json: string;
    /**
     * Indicates if the relationship is inverse (1 for true, 0 for false).
     */
    is_inverse: number;
    /**
     * Indicates if the relationship is many-to-many (1 for true, 0 for false).
     */
    is_mtm: number;
    /**
     * Transitivity property of the relationship.
     */
    transitivity: number;
    /**
     * Identifier for the data source.
     */
    datasource_id: string;
    /**
     * Sort order for the relationship.
     */
    sort_order: number;
    /**
     * Description of the relationship (optional).
     */
    description?: string;
}

/**
 * @beta
 * Type representing the result of a relationship count operation.
 */
export declare type RelationshipCountResult = {
    /** The count of the relationships. */
    count: number;
    /** Whether the count is expired. */
    expired?: boolean;
};

export declare type RemoteAppApi = {
    subscribeToContext: SubscribeToContextFn;
    unsubscribeFromContext: UnsubscribeFromContextFn;
    subscribeToDragStart: SubscribeDragStartFn;
    unsubscribeFromDragStart: UnsubscribeFromDragStartFn;
    dropZoneRequest: DropZoneRequestFn;
    setTransformResult: SetTransformResultFn;
};

/**
 * Properties for saving as modal.
 * @beta
 */
export declare type SaveAsModalProps = {
    /**
     * Item to be saved.
     */
    item: WorkspaceItem;
    /**
     * Application related to the item.
     */
    app?: WorkspaceItem;
};

export declare const SAVED_SEARCH_MESSAGE_TYPES: Readonly<{
    getRecordsCount: "octostar:savedSearch:getRecordsCount";
    getRecordsCountQuery: "octostar:savedSearch:getRecordsCountQuery";
    getRecords: "octostar:savedSearch:getRecords";
    getRecordsQuery: "octostar:savedSearch:getRecordsQuery";
    getSavedSearchPasteContext: "octostar:savedSearch:getSavedSearchPasteContext";
}>;

export declare const SAVED_SEARCH_PREFIX = "octostar:savedSearch:";

export declare interface SavedDatasource {
    uid: string;
    id: number;
    name?: string;
    table_name: string;
    type: string;
    main_dttm_col: string;
}

export declare interface SavedSearchAPIInterface {
    getRecordsCount(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>): Promise<BigNumber | number | null>;
    getRecordsCountQuery(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>): Promise<number | null>;
    getRecords(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>, options?: Partial<RecordFetchOptions>): Promise<RecordData | null>;
    getRecordsQuery(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>, options?: RecordFetchOptions): Promise<QueryResult_2 | null>;
    getSavedSearchPasteContext(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>): Promise<EntityPasteContext>;
}

export declare interface SavedSearchContent {
    concept: string;
    dataset: true;
    filters: Filter[];
    crossFilters: DataMask[];
    datasourcesInScope: {
        [uid: string]: SavedDatasource;
    };
    initialCount?: number;
}

export declare interface SavedSetContent {
    lastFiredQuery: string;
    uiState: Record<string, any>;
}

/**
 * @beta
 * Type representing a saved template, extending CustomTemplate.
 */
export declare type SavedTemplate = CustomTemplate & {
    /** The unique identifier for the entity. */
    os_entity_uid: string;
    /** The workspace to which the template belongs. */
    os_workspace: string;
    /** The CSS content of the template. */
    css_content?: string;
};

/**
 * Options for saving a file.
 * @beta
 */
export declare type SaveFileOptions = {
    /**
     * Path to save the file.
     */
    path?: string | undefined;
};

/**
 * Options for saving an item.
 * @beta
 */
export declare type SaveOptions = SaveFileOptions & {
    /**
     * Whether to save as a draft.
     */
    draft?: boolean;
    /**
     * Whether to save as a new file.
     */
    saveAs?: boolean;
    /**
     * Application related to the item.
     */
    app?: WorkspaceItem;
};

/**
 * @beta
 * Type representing the search filter.
 */
export declare type SearchFilter = {
    label?: string;
    entity?: Entity;
    query?: QueryDslQueryContainer;
    imageUrl?: string;
};

/**
 * @beta
 * Interface representing the options given to search
 */
export declare interface SearchOptions {
    /**
     * The maximum number of entities returned.
     */
    limit?: number;
}

/**
 * @beta
 * Interface representing the properties for the Search component.
 */
export declare interface SearchProps {
    /**
     * the query string to search for.
     */
    q?: string;
    /**
     * the label for the submit button.
     */
    submitButtonLabel?: string;
    /**
     * the filters to apply to the search.
     */
    filters?: SearchFilter[];
    /**
     * the default image to use for the search.
     */
    image?: WorkspaceItem;
    /**
     * disable ask AI
     */
    disableAskAI?: boolean;
    /**
     * disable save search
     */
    disableSaveSearch?: boolean;
}

/**
 * @beta
 * Interface representing the properties for the SearchXperienceModal component, extending SearchXperienceProps.
 */
export declare interface SearchXperienceModalProps extends SearchXperienceProps {
    /** Whether the modal is open. */
    open?: boolean | undefined;
    /**
     * Callback function to be called when the modal is closed.
     * @param entities - The entities selected in the search experience.
     * @returns A void or undefined.
     */
    onClose: (entities: Entity[]) => void | undefined;
}

/**
 * @beta
 * Interface representing the properties for the SearchXperience component.
 */
export declare interface SearchXperienceProps {
    /** The title of the search experience. */
    title?: string | undefined;
    /** The default concepts for the search experience. */
    defaultConcept?: string[] | undefined;
    /** Whether to disable the concept selector. */
    disableConceptSelector?: boolean | undefined;
    /** The task ID associated with the search experience. */
    taskID?: string;
    /** The default search fields for the search experience. */
    defaultSearchFields?: {
        entity_label?: string;
        os_textsearchfield?: string;
    };
}

/**
 * @beta
 * Type representing an application with semantic bindings.
 */
export declare type SemanticallyBoundApp = App & {
    /** The semantic bindings associated with the application. */
    bindings: SemanticBindingProps[];
};

/**
 * @beta
 * Type representing a semantically bound filter definition.
 */
export declare type SemanticallyBoundFilterDefinition = {
    /** The type of the filter, always 'semantically_bound' for this type. */
    type: 'semantically_bound';
    /** The concepts that the filter is bound to. */
    concepts: string[];
};

/**
 * @beta
 * Type representing a template binding.
 */
export declare type SemanticBinding = {
    /** The concept to which the binding applies */
    concept: ConceptName;
    /** the role for which the binding applies */
    role?: SemanticBindingType;
    /** The actual binding properties */
    props?: SemanticBindingProps;
};

/**
 * @beta
 * Type representing the properties for a template binding.
 */
export declare interface SemanticBindingProps {
    /** The concept to which the binding applies */
    concept: string;
    /** The priority for the template, lower value means higher priority */
    priority?: number;
    /** Whether the result should be shown in large mode by default */
    maximized?: boolean;
    /** Other properties */
    [key: string]: any;
}

/**
 * @beta
 * Type representing multiple semantic bindings.
 */
export declare type SemanticBindings = {
    [k in SemanticBindingType]: (ConceptName | SemanticBinding)[];
};

/**
 * @beta
 * Type representing a semantic binding type.
 */
export declare type SemanticBindingType = 'record_viewer' | string;

/**
 * @beta
 * Options for sending a query.
 */
export declare type SendQueryOptions = {
    /** The context in which to send the query. */
    context?: string;
    /** Whether to send the query with low priority. */
    lowPriority?: boolean;
};

/**
 * @beta
 * Type representing a service definition.
 */
export declare type ServiceDefinition = {
    /** Description of the service. */
    description: string;
    /** Label of the service. */
    label: string;
    /** Icon for the service. */
    icon: string;
    /** Optional group for the service. */
    group?: DesktopActionMenuItemGroup;
    /** Optional subgroup for the service. */
    subgroup?: string;
    /** Optional order for the service. */
    order?: number;
    /** Optional parameters for the service. */
    params?: {
        [k: string]: any;
    };
    /** Optional roles for the service. */
    role?: ServiceRole[] | ServiceRole;
    /** Filters accepted by the service. */
    accepts: FilterReference[];
    /** Transforms applied by the service. */
    transforms: string[];
    /**
     * Whether to show a progress bar when invoking this service.
     * Default is true.
     */
    show_progress?: boolean;
};

/**
 * @beta
 * Type representing a collection of service definitions.
 */
export declare type ServiceDefinitions = {
    [serviceName: string]: ServiceDefinition;
};

/**
 * @beta
 * Type representing a service role.
 */
export declare type ServiceRole = 'context_menu' | 'record_view' | 'set_view';

export declare type SetTransformResultFn = (args: any[]) => Promise<void>;

/**
 * @beta
 * Type representing the details of an ontology to be shown.
 */
export declare type ShowOntology = {
    /** The concept of the ontology. */
    concept: string;
    /** The properties of the ontology. */
    properties: string | undefined;
    /** The primary keys of the ontology. */
    primary_keys: string | undefined;
    /** The label keys of the ontology. */
    label_keys: string | undefined;
    /** The inheritance of the ontology. */
    inheritance: string | undefined;
    /** The inheritance level of the ontology. */
    inheritance_level: number;
    /** The query associated with the ontology. */
    query: string | undefined;
    /** The description of the ontology. */
    description: string | undefined;
    /** The JSON representation of the query. */
    query_json: string | undefined;
};

/**
 * Properties for showing a tab.
 * @beta
 */
export declare type ShowTabProps = {
    /**
     * Application related to the tab.
     */
    app: WorkspaceItem;
    /**
     * Item related to the tab.
     */
    item?: WorkspaceItem;
    /**
     * Options for showing the tab.
     */
    options?: DesktopActionOptions;
};

/**
 * Enum for sort order values.
 * @beta
 */
export declare enum SortOrder {
    PREFERRED = 21,
    OTHER = 10,
    HIDE = -1
}

/**
 * @beta
 * Options for streaming JSON line data from an API.
 */
export declare interface StreamJsonOptions<T> extends FetchOptions {
    /**
     * The asynchronous function to process each JSON object.
     */
    jsonHandler: (value: T) => Promise<void>;
}

/**
 * @beta
 * Options for streaming text data from an API.
 */
export declare interface StreamTextOptions extends FetchOptions {
    /**
     * The asynchronous function to process each line of text.
     */
    handler: (line: string) => Promise<void>;
}

/**
 * @beta
 * Type representing a styler with methods for getting G6 node and edge styles.
 * See ColorByType.ts for an example
 */
export declare type Styler = {
    /**
     * Use this function to modify style of a node from outside the graph.
     * You can overwrite the style, but DO NOT merge currentStyle or originStyle when returning new styling (or rather styling patch).
     * This can lead do recursive clone error later on.
     * Merging with actual style will be handled automatically!
     * Use them just as a reference:
     * - @param originStyle for eg original node radius (if its a circural node), so you want to eg multiply it by amount of connections.
     * - @param currentStyle for eg current node radius (if its a circural node), so you want to eg apply a holor like a heatmap by amount of connections.
     * @param entity - The entity for which to get the node style.
     * @param originStyle - The original style (the one passed to node during it's initialization). See '@antv/graphin' -> NodeStyle
     * @param currentStyle - The current style. See '@antv/graphin' -> NodeStyle
     * @returns A promise that resolves to the style patch. See '@antv/graphin' -> NodeStyle
     */
    getG6NodeStyle?: (entity: Entity, originStyle: TODO, currentStyle: TODO) => Promise<TODO>;
    /**
     * Use this function to modify style of a edge from outside the graph.
     * You can overwrite the style, but DO NOT merge currentStyle or originStyle when returning new styling (or rather styling patch).
     * This can lead do recursive clone error later on.
     * Merging with actual style will be handled automatically!
     * Use them just as a reference, eg edge width to multiply.
     * @param edge - The edge specification for which to get the edge style.
     * @param originStyle - The original style (the one passed to edge during it's initialization). See '@antv/graphin' -> EdgeStyle
     * @param currentStyle - The current style. See '@antv/graphin' -> EdgeStyle
     * @returns A promise that resolves to the style patch. See '@antv/graphin' -> EdgeStyle
     */
    getG6EdgeStyle?: (edge: EdgeSpec, originStyle: TODO, currentStyle: TODO) => Promise<TODO>;
};

/**
 * @beta
 * Type representing the configuration for a styler.
 */
export declare type StylerConfig = StylerOption & {
    /** The name of the styler configuration. */
    name: string;
    /** The description of the styler configuration. */
    description: string;
    /** The initialization function for the styler. */
    init: StylerProducer;
    /** The optional destroy function for the styler. */
    destroy?: () => Promise<void>;
};

/**
 * @beta
 * Interface representing the context for a styler.
 */
export declare interface StylerContext {
    /** The graph specification. */
    graph: GraphSpec;
    /** The selected graph specification. */
    selected: GraphSpec;
    /** The ontology API instance. */
    OntologyAPI: Ontology;
    /** The desktop API instance. */
    DesktopAPI: Desktop;
    /** The event emitter instance. */
    ee: EventEmitterType;
    /** The event topic prefix. */
    eventTopicPrefix: string;
    /**
     * @beta
     * Callback function to be called when the task is complete.
     * @param x - The styler instance.
     */
    onTaskComplete?: (x: Styler) => void;
    /** Callback function to be called when the task is canceled. */
    onTaskCanceled?: () => void;
    /** The task ID associated with the styler. */
    taskID?: string;
}

/**
 * @beta
 * Type representing a styler definition, which can be one of several specific types.
 */
export declare type StylerDefinition = JavascriptFileStylerDefinition | JavascriptInlineStylerDefinition;

/**
 * @beta
 * Type representing a collection of styler definitions.
 */
export declare type StylerDefinitions = {
    [stylerName: string]: StylerDefinition;
};

/**
 * @beta
 * Type representing an option for a styler.
 */
export declare type StylerOption = {
    /** The name of the styler option. */
    name: string;
    /** The description of the styler option. */
    description: string;
};

/**
 * @beta
 * Type representing a function that produces a styler.
 * @param context - The context for the styler.
 * @returns A promise that resolves to the styler.
 */
export declare type StylerProducer = (context: StylerContext) => Promise<Styler>;

export declare type SubscribeDragStartFn = (id: string, callback: Callback<unknown>) => void;

export declare type SubscribeToContextFn = (id: string, callback: Callback<unknown>) => void;

/**
 * Represents a tag with a name and value.
 * @beta
 */
export declare type Tag = {
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * The value of the tag.
     */
    tag_value: string;
};

/**
 * Represents tag attributes with optional color and group.
 * @beta
 */
export declare interface TagAttributes extends Colorful {
    /**
     * The group to which the tag belongs.
     */
    group?: string;
    /**
     * The order of the tag in the group.
     * Lower values are displayed first.
     */
    order?: number;
    /**
     * The id of the workspace in which the tag is stored.
     */
    os_workspace: string;
    /**
     * The name of the tag.
     */
    os_item_name: string;
}

/**
 * @beta
 * Type representing information about a tag.
 */
export declare type TagInfo = {
    /** The tag string. */
    tag: string;
    /** The workspace associated with the tag. */
    os_workspace: string;
    /** The count of entities associated with the tag. */
    count: number;
    /** A sample of entities associated with the tag. */
    sample: Entity[];
    /** The entity representing the tag. */
    entity: OsTag;
};

/**
 * @beta
 * Type representing a tag with its associated relationship.
 */
export declare type TagWithRelationship = {
    /** The workspace relationship associated with the tag. */
    os_workspace_relationship: WorkspaceRelationship;
    /** The tag entity. */
    os_tag: OsTag;
};

/**
 * Reasons for task cleanup.
 * @beta
 */
export declare type TaskCleanupReason = 'canceled' | 'completed';

/**
 * @beta
 * Type representing the metadata for a template.
 */
export declare type TemplateMetadata = {
    /** The name of the template. */
    name: string;
    /** The description of the template. */
    description: string;
    /** The concepts associated with the template. */
    concepts: string[];
    /** The priority of the template. Default is 100, lower is higher priority. */
    priority?: number;
    /** The type of the template. */
    type: TemplateType;
    /** The layout of the template. */
    layout: string;
    /** The variant of the template. */
    variant: TemplateVariant;
    /** Optional blurhash for the template. */
    blurhash?: string;
    /** The parameter names required by the template. */
    parameterNames: string[];
    /** Optional CSS properties for the template. */
    style?: ReactCssProperties;
    /** Whether the template renders multiple records. */
    rendersMultipleRecords?: boolean;
    /** Whether the template is an app. */
    isApp?: boolean;
    /** details for semantic bindings. These can be app-specific */
    bindings?: SemanticBinding[];
};

/**
 * @beta
 * Type representing the possible template types.
 */
export declare type TemplateType = 'nunjucks' | 'javascript';

/**
 * @beta
 * Type representing the possible template variants.
 */
export declare type TemplateVariant = 'antd';

declare type TODO = any;

/**
 * @beta
 * Type representing a transformation action.
 * @param context - The context for the transformation action.
 * @returns The result of the transformation action.
 */
export declare type TransformAction = (context: TransformActionContext) => any;

/**
 * @beta
 * Context for a transformation action within the desktop environment.
 */
export declare type TransformActionContext = DesktopActionContext & {
    /** The task ID associated with the transformation. */
    taskID: string;
    /** Function to be called when the task is canceled. */
    onTaskCanceled: () => Promise<void>;
    /** Function to be called when the task is completed. */
    onTaskComplete: (result: any) => Promise<void>;
    /** Function to call a transformation with additional context. */
    callTransform: (transform: string, extraContext: any) => Promise<any>;
};

/**
 * @beta
 * Type representing a transform definition, which can be one of several specific types.
 */
export declare type TransformDefinition = ProvidedTransformDefinition | HttpTransformDefinition | IframeTransformDefinition | JavascriptFileTransformDefinition | JavascriptInlineTransformDefinition | NunjucksFileTransformDefinition | NunjucksInlineTransformDefinition | EmitEventTransformDefinition;

/**
 * @beta
 * Type representing a collection of transform definitions.
 */
export declare type TransformDefinitions = {
    [transformName: string]: TransformDefinition;
};

/**
 * @beta
 * Type representing the possible triggers for a context menu.
 */
export declare type trigger = 'hover' | 'contextMenu' | 'click';

/**
 * @beta
 * Represents a filter clause with unary operations in a query object.
 * It supports operations for checking null or not-null conditions.
 */
export declare interface UnaryObjectFilterClause {
    col: string;
    op: 'IS NULL' | 'IS NOT NULL';
}

/**
 * @beta
 * Type representing an unsubscribe function.
 * @returns A promise that resolves when the unsubscribe operation is complete.
 */
export declare type Unsubscribe = () => Promise<void>;

export declare type UnsubscribeFn = (id: string) => void;

export declare type UnsubscribeFromContextFn = UnsubscribeFn;

export declare type UnsubscribeFromDragStartFn = UnsubscribeFn;

/**
 * @beta
 * Type representing a user profile.
 */
export declare type UserProfile = {
    /** The first name of the user. */
    firstName: string;
    /** The last name of the user. */
    lastName: string;
    /** The email address of the user. */
    email: string;
    /** The username of the user. */
    username: string;
};

/**
 * @beta
 * Type representing a UUID.
 */
export declare type uuid = string;

/**
 * Represents a watcher.
 * @beta
 */
export declare type Watcher = {
    /**
     * Application ID.
     */
    app_id: string;
    /**
     * Application name.
     */
    app_name: string;
    /**
     * Watcher name.
     */
    watcher_name: string;
    /**
     * Constants for the watcher.
     */
    const: [key: string, value: any][];
    /**
     * Description of the watcher.
     */
    description: string;
    /**
     * File associated with the watcher.
     */
    file: string;
    /**
     * Interval for the watcher.
     */
    interval: string;
    /**
     * Name of the watcher.
     */
    name: string;
    /**
     * Parameters for the watcher.
     */
    params: [key: string, value: any][];
    /**
     * Semantically bound items.
     */
    semantically_bound: string[];
};

/**
 * Represents information about the current user.
 * @beta
 */
export declare type Whoami = {
    /**
     * Asynchronous channel for the user.
     */
    async_channel: string;
    /**
     * Email of the user.
     */
    email: string | null;
    /**
     * JWT token for the user.
     */
    os_jwt: string;
    /**
     * Username of the user.
     */
    username: string;
    /**
     * Roles of the user.
     */
    timbr_roles: string[];
    /**
     * Whether the user is a superuser (having the ADMIN_ALL_WORKSPACES username or role)
     */
    is_superuser: boolean;
};

/**
 * Options for displaying a progress bar.
 * @beta
 */
export declare type WithProgressBarOptions = {
    /**
     * Type of job for the progress bar.
     */
    job_type: string;
    /**
     * Label for the progress bar.
     */
    label?: string | JSX.Element;
    /**
     * Prefix for event topics.
     */
    eventTopicPrefix?: string;
    /**
     * Error message for the progress bar.
     */
    errorToast?: string | boolean;
};

/**
 * @beta
 * Type representing a workspace.
 */
export declare type Workspace = {
    /** The workspace item. */
    workspace: WorkspaceItem;
    /** The items in the workspace. */
    items: WorkspaceItems;
    /** Optional records in the workspace. */
    workspace_records?: WorkspaceRecords;
    /** Optional tags in the workspace. */
    tags?: TagInfo[];
    /** Optional permission for the workspace. */
    permission?: WorkspacePermission;
    /** Whether the workspace is active. */
    isActive?: boolean;
    os_flags?: number;
};

/**
 * @beta
 * Interface representing a workspace change emitter.
 */
export declare interface WorkspaceChangeEmitter {
    /**
     * Subscribes to changes for a given workspace.
     * @param ws - The workspace identifier.
     * @param callback - The callback to invoke on changes.
     * @returns A promise that resolves to an unsubscribe function.
     */
    onWorkspaceChanged: (ws: WorkspaceIdentifier, callback: Callback<Workspace>) => Promise<Unsubscribe>;
    /**
     * Subscribes to changes for a given workspace item.
     * @param item - The workspace item identifier.
     * @param callback - The callback to invoke on changes.
     * @returns A promise that resolves to an unsubscribe function.
     */
    onWorkspaceItemChanged: (item: WorkspaceItemIdentifier, callback: Callback<WorkspaceItem>) => Promise<Unsubscribe>;
    /**
     * Subscribes to changes for the currently open workspaces.
     * @param callback - The callback to invoke with the current open workspaces.
     * @returns A promise that resolves to an unsubscribe function.
     */
    onOpenWorkspacesChanged: AddListener<Workspace[]>;
}

export declare type WorkspaceConfig = Partial<{
    description: string;
    os_icon: string;
    color: string;
    id?: string;
}>;

/**
 *
 * @beta
 * Type representing a workspace flags.
 */
export declare type WorkspaceFlags = {
    autoOpen?: boolean;
    isHidden?: boolean;
};

/**
 * @beta
 * Type representing a workspace identifier, which can be a UUID or a workspace item.
 * @template T - The type of the workspace item.
 */
export declare type WorkspaceIdentifier<T = any> = uuid | WorkspaceItem<T>;

/**
 * Represents a workspace item with optional content.
 * @beta
 */
export declare type WorkspaceItem<T = any> = WorkspaceRecord & {
    /**
     * The type-specific content of the workspace item.
     */
    os_item_content?: T & {
        image?: ImageInfo;
    };
    /**
     * The type of the content.
     */
    os_item_content_type?: string;
    /**
     * The id of the folder in which the item is stored.
     */
    os_parent_folder?: string;
    /**
     * Whether the item has an attachment file content.
     */
    os_has_attachment?: boolean;
    /**
     * Optional path from the os_parent_folder or os_workspace to the item.
     * Does not include the item name.
     * Used only when saving by POST to the /entity API.
     * eg. 'folder1/folder2'
     */
    '#os_path'?: string;
    /**
     * The size in bytes of the content.
     */
    os_content_size?: number;
    /**
     * Whether the item is readonly or not.
     */
    os_readonly?: boolean;
};

/**
 * Represents the base attributes for a workspace item.
 * @beta
 */
export declare type WorkspaceItemBase = WorkspaceItemModel & {
    /**
     * The ID of the workspace item.
     */
    os_entity_uid: string;
    /**
     * The ID of the workspace in which the item is stored.
     */
    os_workspace: string;
};

/**
 * Represents the configuration for a workspace item.
 * @beta
 */
export declare interface WorkspaceItemConfig {
    /**
     * The id the workspace item.
     */
    entity_id: string;
    /**
     * The concept to which the workspace item belongs.
     */
    entity_type: string;
    /**
     * The id of the workspace in which the workspace item is stored.
     */
    workspace_id: string;
    /**
     * Epoch time of the last update of the workspace item.
     */
    last_updated: number;
}

/**
 * @beta
 * Type representing a workspace item identifier, which is the same as a workspace identifier.
 * @template T - The type of the workspace item.
 */
export declare type WorkspaceItemIdentifier<T = any> = WorkspaceIdentifier<T>;

/**
 * Represents the model for a workspace item.
 * @beta
 */
export declare type WorkspaceItemModel = {
    /**
     * Ephemeral UI state in lieu of using complex redux logic.
     * It is not saved in persistence and can be mutated by components.
     */
    __uiState?: {
        /**
         * Indicates if the item is in rename mode.
         */
        rename?: boolean;
        /**
         * A filter applied to concepts.
         */
        query?: ConceptFilter;
        /**
         * Function to get the count of entities.
         * @returns A promise that resolves to the number of entities.
         */
        getEntitiesCount?: () => Promise<number>;
        /**
         * Function to get the entities.
         * @param limit - The maximum number of entities to retrieve.
         * @returns A promise that resolves to an array of entities.
         */
        getEntities?: (limit?: number) => Promise<Entity[]>;
        /**
         * Determines if the count is shown only when the item is closed.
         */
        showCountOnlyWhenClosed?: boolean;
        /**
         * The initial state of the item.
         */
        initialState?: any;
        /**
         * Indicates if the item should be highlighted.
         */
        highlight?: boolean;
        /**
         * Indicates if the item is in draft mode.
         */
        draft?: boolean;
        /**
         * Indicates if the item is auto open
         */
        autoOpen?: boolean;
        /**
         * Indicates if the item is hidden
         */
        isHidden?: boolean;
        /**
         * Indicates if the item is closable
         */
        isClosable?: boolean;
    };
    /**
     * Name of the workspace item.
     */
    os_item_name: string;
    /**
     * Type of the workspace item.
     */
    os_item_type: string;
};

/**
 * Represents an array of workspace items.
 * @beta
 */
export declare type WorkspaceItems = WorkspaceItem[];

/**
 * Properties for workspace item title.
 * @beta
 */
export declare type WorkspaceItemTitleProps = DesktopActionContext & {
    /**
     * Whether to show hidden children in the workspace.
     */
    showHiddenChildren?: 'workspace' | boolean;
    /**
     * Menu options with extra action items.
     */
    menuOptions?: ContextMenuOptions & {
        extraActionItems?: DesktopActionMenuItem[];
    };
    /**
     * Whether the item is expanded.
     */
    expanded?: boolean;
    /**
     * Selected items in left sidebar
     */
    selectedItems: WorkspaceItem[];
    /**
     * If the component it is being used inside a Markdown component
     */
    markdown?: boolean;
};

/**
 * @beta
 * Type representing a workspace permission.
 */
export declare type WorkspacePermission = {
    /** The value of the permission. */
    value: WorkspacePermissionValue;
    /** The label for the permission. */
    label: string;
};

/**
 * @beta
 * Enum representing the possible values for workspace permissions.
 */
export declare enum WorkspacePermissionValue {
    None = 0,
    Read = 1,
    Write = 2,
    Admin = 4
}

/**
 * Represents a workspace record with additional attributes.
 * @beta
 */
export declare type WorkspaceRecord = Entity & WorkspaceItemBase & OsAuditFields & {
    os_icon?: string;
};

/**
 * Represents a workspace record identifier.
 * @beta
 */
export declare interface WorkspaceRecordIdentifier {
    /**
     * The concept to which the record belongs.
     */
    entity_type: string;
    /**
     * The ID of the workspace record.
     */
    os_entity_uid: string;
    /**
     * The id of the workspace in which the record is stored.
     */
    os_workspace: string;
}

/**
 * @beta
 * Type representing information about records in a workspace.
 */
export declare type WorkspaceRecordInfo = {
    /** The concept associated with the records. */
    concept: string;
    /** The count of records. */
    count: number;
    /** The last updated timestamp for the records. */
    max_last_updated: string;
    /** The entities associated with the records. */
    entities: Entity[];
};

/**
 * @beta
 * Type representing a collection of workspace records.
 */
export declare type WorkspaceRecords = {
    [key: string]: WorkspaceRecordInfo;
};

/**
 * @beta
 * Type representing a workspace record with its relationships.
 */
export declare type WorkspaceRecordWithRelationships = {
    /** The workspace item. */
    entity: WorkspaceItem;
    /** The name of the relationship. */
    relationship_name?: string;
    /** The relationships associated with the workspace record. */
    relationships?: [WorkspaceRecordWithRelationships];
};

/**
 * Represents a relationship between workspace items.
 * @beta
 */
export declare type WorkspaceRelationship = WorkspaceItemBase & OsAuditFields & {
    /**
     * Unique identifier for the source entity in the relationship.
     */
    os_entity_uid_from: string;
    /**
     * Unique identifier for the target entity in the relationship.
     */
    os_entity_uid_to: string;
    /**
     * Type of the source entity in the relationship.
     */
    os_entity_type_from: string;
    /**
     * Type of the target entity in the relationship.
     */
    os_entity_type_to: string;
    /**
     * Name of the relationship.
     */
    os_relationship_name: string;
};

/**
 * @beta
 * Type representing settings for a workspace.
 */
export declare type WorkspaceSettings = {
    /** Whether the workspace is the master workspace. */
    isMaster?: boolean;
    /** The icon for the workspace. */
    os_icon?: string;
};

export { }

import postRobot from 'post-robot';
import { retry } from './utils';
import { getPostMessageNames } from './constants';
const hasParent = (window) => window.parent !== window;
function getOctostarWindow(channelId, currentWindow = window, depth = 0) {
    // Check all iframes in the current window
    let iframes;
    try {
        iframes = currentWindow.document.querySelectorAll('iframe');
    }
    catch (e) {
        // assuming cross-origin iframe
        return currentWindow;
    }
    for (let i = 0; i < iframes.length; i += 1) {
        const iframe = iframes[i];
        if (iframe.getAttribute('data-octostar-iframe') === 'true' &&
            iframe.getAttribute('data-octostar-iframe-channel') === channelId) {
            return currentWindow;
        }
    }
    // Check if we've reached the top window
    if (!hasParent(currentWindow)) {
        console.error('Top window reached without finding the Octostar window. You are trying to view the app from outside Octostar?');
        // could be an old version of Octostar?
        return currentWindow;
    }
    // Prevent infinite loops or excessive searching
    if (depth > 25) {
        throw new Error('Max depth reached. Octostar window not found.');
    }
    // If not found, continue searching in the parent window
    return getOctostarWindow(channelId, currentWindow.parent, depth + 1);
}
const handlePostResponse = (response) => {
    if (response.data.error) {
        throw new Error(response.data.error.message);
    }
    return response.data.data;
};
const createObjectProxy = (value, options) => new Proxy(value, {
    get: (target, prop) => {
        // This construction does not support nested objects
        if (typeof target[prop] === 'function') {
            return new Proxy(target[prop], {
                apply: (methodTarget, _, args) => {
                    const callResult = methodTarget(...args);
                    const isPromise = callResult instanceof Promise;
                    const isPromiseLike = typeof callResult?.then === 'function' &&
                        typeof callResult?.catch === 'function';
                    if (isPromise || isPromiseLike) {
                        return callResult.catch((e) => {
                            const methodFullPath = `${options.name}.${prop}()`;
                            const error = new Error(`Error calling ${methodFullPath}: ${e.message}`);
                            error.stack = `at ${methodFullPath}: ${e.stack}`;
                            error.originalError = e;
                            throw error;
                        });
                    }
                    return callResult;
                },
            });
        }
        return target[prop];
    },
});
function tryFetchingFomAttributes(currentWindow) {
    try {
        const iframes = currentWindow.parent.document.getElementsByTagName('iframe');
        // eslint-disable-next-line no-restricted-syntax
        for (const iframe of iframes) {
            if (iframe.contentWindow === currentWindow) {
                const channelId = iframe.getAttribute('data-octostar-iframe-channel');
                if (channelId) {
                    console.log(`PostRobot: Setting channelId from iframe attribute ${channelId}`);
                    window.octostarChannelId = channelId;
                    return channelId;
                }
            }
        }
        return undefined;
    }
    catch (e) {
        // Ignore errors, maybe cross-origin iframes
        return undefined;
    }
}
function traverseForChannelId(currentWindow = window, depth = 0) {
    // Prevent infinite loops or excessive searching
    if (depth > 25) {
        throw new Error('PostRobot: Max depth reached. octostarChannelId not found.');
    }
    if (currentWindow.octostarChannelId) {
        return currentWindow.octostarChannelId;
    }
    try {
        if (currentWindow.location.search) {
            const urlParams = new URLSearchParams(currentWindow.location.search);
            const channelId = urlParams.get('octostarChannelId');
            if (channelId) {
                console.log(`PostRobot: Setting channelId from queryParams ${channelId}`);
                window.octostarChannelId = channelId;
                return channelId;
            }
        }
        else {
            const channelId = tryFetchingFomAttributes(currentWindow);
            if (channelId) {
                return channelId;
            }
        }
        return traverseForChannelId(currentWindow.parent, depth + 1);
    }
    catch (e) {
        console.error(e);
        return undefined;
    }
}
window.addEventListener('message', event => {
    if (event.data?.type === 'SET_CHANNEL_ID') {
        window.octostarChannelId = event.data.channelId;
        console.log('PostRobot: received channelId', event.data.channelId);
    }
});
export const createRemoteApiHandle = async (params) => {
    const channelId = traverseForChannelId();
    const octostarWindow = getOctostarWindow(channelId);
    if (!channelId) {
        console.error('PostRobot: No channelId found', channelId);
    }
    console.log(`PostRobot: Trying to get handle ${channelId}`);
    const topic = getPostMessageNames(channelId).get_api;
    try {
        const response = await retry(() => postRobot.send(octostarWindow, topic, params), {
            maxAttempts: 5,
            retryInterval: 2000,
        });
        console.log(`PostRobot: Got remote api handle for ${params.name} on ${channelId}`);
        const api = handlePostResponse(response);
        return createObjectProxy(api, {
            name: params.name,
        });
    }
    catch (e) {
        console.log(`PostRobot: Error while trying to create remote API handle on ${topic}`, e);
        throw e;
    }
};
export const forwardCallsToFutureObject = (chain) => new Proxy({}, {
    get: (target, prop) => new Proxy(() => { }, {
        apply: (__, _, args) => chain.then((obj) => obj[prop](...args)),
    }),
});
//# sourceMappingURL=factory.js.map
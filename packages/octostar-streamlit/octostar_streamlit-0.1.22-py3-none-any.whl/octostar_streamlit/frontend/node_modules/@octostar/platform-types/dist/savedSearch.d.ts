import { EntityPasteContext } from './desktop';
import { WorkspaceItemIdentifier } from './workspace';
export type FilterState = {
    value?: any;
    [key: string]: any;
};
export type DataMask = {
    extraFormData?: Record<string, any>;
    filterState?: FilterState;
    ownState?: Record<string, any>;
};
export interface SavedDatasource {
    uid: string;
    id: number;
    name?: string;
    table_name: string;
    type: string;
    main_dttm_col: string;
}
export interface SavedSearchContent {
    concept: string;
    dataset: true;
    filters: Filter[];
    crossFilters: DataMask[];
    datasourcesInScope: {
        [uid: string]: SavedDatasource;
    };
    initialCount?: number;
}
export interface SavedSetContent {
    lastFiredQuery: string;
    uiState: Record<string, any>;
}
export interface NativeFilterColumn {
    name: string;
    displayName?: string;
}
export interface NativeFilterTarget {
    datasetId: number;
    column: NativeFilterColumn;
}
export interface NativeFilterScope {
    rootPath: string[];
    excluded: number[];
}
export type Filter = {
    cascadeParentIds: string[];
    defaultDataMask: DataMask;
    id: string;
    name: string;
    scope: NativeFilterScope;
    filterType: string;
    targets: [Partial<NativeFilterTarget>];
    controlValues: {
        [key: string]: any;
    };
    sortMetric?: string | null;
    adhoc_filters?: Record<any, any>[];
    granularity_sqla?: string;
    granularity?: string;
    time_grain_sqla?: string;
    time_range?: string;
    requiredFirst?: boolean;
    tabsInScope?: string[];
    chartsInScope?: number[];
    type: 'NATIVE_FILTER';
    description: string;
};
export type RecordFetchOptions = {
    all_columns: string[];
    order_by_cols: string[];
    row_limit: number;
    server_page_length: number;
};
type BigNumber = any;
declare enum GenericDataType {
    NUMERIC = 0,
    STRING = 1,
    TEMPORAL = 2,
    BOOLEAN = 3
}
export interface ChartDataResponseResult {
    all_columns?: string[];
    annotation_data: Record<string, any> | null;
    cache_key: string | null;
    cache_timeout: number | null;
    cached_dttm: string | null;
    /**
     * Array of data records as dictionary
     */
    data: Record<any, any>[];
    /**
     * Name of each column, for retaining the order of the output columns.
     */
    colnames: string[];
    /**
     * Generic data types, based on the final output pandas dataframe.
     */
    coltypes: GenericDataType[];
    error: string | null;
    is_cached: boolean;
    query: string;
    rowcount: number;
    stacktrace: string | null;
    status: 'stopped' | 'failed' | 'pending' | 'running' | 'scheduled' | 'success' | 'timed_out';
    from_dttm: number | null;
    to_dttm: number | null;
}
export interface RecordData extends ChartDataResponseResult {
    data: Record<string, any>[];
}
type QueryResult = {
    language: string;
    query: string;
};
export declare const SAVED_SEARCH_PREFIX = "octostar:savedSearch:";
export declare const SAVED_SEARCH_MESSAGE_TYPES: Readonly<{
    getRecordsCount: "octostar:savedSearch:getRecordsCount";
    getRecordsCountQuery: "octostar:savedSearch:getRecordsCountQuery";
    getRecords: "octostar:savedSearch:getRecords";
    getRecordsQuery: "octostar:savedSearch:getRecordsQuery";
    getSavedSearchPasteContext: "octostar:savedSearch:getSavedSearchPasteContext";
}>;
export interface SavedSearchAPIInterface {
    getRecordsCount(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>): Promise<BigNumber | number | null>;
    getRecordsCountQuery(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>): Promise<number | null>;
    getRecords(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>, options?: Partial<RecordFetchOptions>): Promise<RecordData | null>;
    getRecordsQuery(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>, options?: RecordFetchOptions): Promise<QueryResult | null>;
    getSavedSearchPasteContext(savedSearchIdn: WorkspaceItemIdentifier<SavedSearchContent>): Promise<EntityPasteContext>;
}
export {};
//# sourceMappingURL=savedSearch.d.ts.map
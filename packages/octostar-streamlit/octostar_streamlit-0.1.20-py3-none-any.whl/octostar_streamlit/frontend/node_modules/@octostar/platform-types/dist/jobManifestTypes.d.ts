import { FilterDefinition, FilterName } from './filters';
import { DesktopActionFilter, DesktopActionMenuItemGroup } from './desktop';
import { SemanticBindings } from './semantic';
/**
 * @beta
 * Type representing a collection of filter definitions.
 */
export type FilterDefinitions = {
    [k: FilterName]: FilterDefinition;
};
/**
 * @beta
 * Type representing a reference to a filter, which can be a string or an object requiring all filters.
 */
export type FilterReference = string | {
    ['require_all']: FilterReference[];
};
/**
 * @beta
 * Type representing a provided transform definition.
 */
export type ProvidedTransformDefinition = {
    /** The type of the transform, always 'provided' for this type. */
    type: 'provided';
};
/**
 * @beta
 * Type representing a transform definition that emits an event.
 */
export type EmitEventTransformDefinition = {
    /** The type of the transform, always 'emit_event' for this type. */
    type: 'emit_event';
    /** The topic of the event to emit. */
    topic: string;
    /** The arguments for the event. */
    args: string[];
};
/**
 * @beta
 * Type representing an iframe transform definition.
 */
export type IframeTransformDefinition = {
    /** The type of the transform, always 'iframe' for this type. */
    type: 'iframe';
    /** The URL to load in the iframe. */
    url: string;
    /** The title of the iframe. */
    title: string;
    /** The icon for the iframe. */
    icon: string;
    /** Whether to reuse the tab for the iframe. */
    reuse_tab?: boolean;
};
/**
 * @beta
 * Type representing an HTTP transform definition.
 */
export type HttpTransformDefinition = {
    /** The type of the transform, always 'http' for this type. */
    type: 'http';
    /** The HTTP method for the transform. */
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD';
    /** The URL for the HTTP request, can be relative to the url of the deployed app */
    url: string;
    /** Optional headers for the HTTP request. */
    headers?: {
        [k: string]: string;
    };
    /** Optional data for the HTTP request. */
    data?: string | {
        [k: string]: any;
    };
};
/**
 * @beta
 * File containing the code. Not yet supported.
 */
export type FileCode = {
    /** The file containing the code. */
    file: string;
};
/**
 * @beta
 * Inline code.
 */
export type InlineCode = {
    /** The inline code. */
    code: string;
};
/**
 * @beta
 * Type representing a JavaScript transform definition.
 */
export type JavascriptType = {
    /** The type of the transform or styler, always 'javascript' for this type. */
    type: 'javascript';
};
/**
 * @beta
 * Type representing a Nunjucks transform definition.
 */
export type NunjucksType = {
    /** The type of the transform or styler, always 'nunjucks' for this type. */
    type: 'nunjucks';
};
export type EvalContext = {
    variables: {
        [key: string]: any;
    };
    filters: {
        [key: string]: DesktopActionFilter;
    };
    transforms: {
        [key: string]: Function;
    };
};
/**
 * @beta
 * Type representing a JavaScript file transform definition. Not yet supported.
 */
export type JavascriptFileTransformDefinition = JavascriptType & FileCode;
/**
 * @beta
 * Type representing an inline JavaScript transform definition.
 */
export type JavascriptInlineTransformDefinition = JavascriptType & InlineCode;
/**
 * @beta
 * Type representing a Nunjucks file transform definition. Not yet supported.
 */
export type NunjucksFileTransformDefinition = NunjucksType & FileCode;
/**
 * @beta
 * Type representing an inline Nunjucks transform definition.
 */
export type NunjucksInlineTransformDefinition = NunjucksType & {
    /** The Nunjucks template. */
    template: string;
};
/**
 * @beta
 * Type representing a transform definition, which can be one of several specific types.
 */
export type TransformDefinition = ProvidedTransformDefinition | HttpTransformDefinition | IframeTransformDefinition | JavascriptFileTransformDefinition | JavascriptInlineTransformDefinition | NunjucksFileTransformDefinition | NunjucksInlineTransformDefinition | EmitEventTransformDefinition;
/**
 * @beta
 * Type representing a collection of transform definitions.
 */
export type TransformDefinitions = {
    [transformName: string]: TransformDefinition;
};
/**
 * @beta
 * Type representing a JavaScript file styler definition.
 */
export type JavascriptFileStylerDefinition = JavascriptType & FileCode;
/**
 * @beta
 * Type representing an inline JavaScript styler definition.
 */
export type JavascriptInlineStylerDefinition = JavascriptType & InlineCode;
/**
 * @beta
 * Type representing a styler definition, which can be one of several specific types.
 */
export type StylerDefinition = JavascriptFileStylerDefinition | JavascriptInlineStylerDefinition;
/**
 * @beta
 * Type representing a collection of styler definitions.
 */
export type StylerDefinitions = {
    [stylerName: string]: StylerDefinition;
};
/**
 * @beta
 * Type representing a service role.
 */
export type ServiceRole = 'context_menu' | 'record_view' | 'set_view';
/**
 * @beta
 * Type representing a service definition.
 */
export type ServiceDefinition = {
    /** Description of the service. */
    description: string;
    /** Label of the service. */
    label: string;
    /** Icon for the service. */
    icon: string;
    /** Optional group for the service. */
    group?: DesktopActionMenuItemGroup;
    /** Optional subgroup for the service. */
    subgroup?: string;
    /** Optional order for the service. */
    order?: number;
    /** Optional parameters for the service. */
    params?: {
        [k: string]: any;
    };
    /** Optional roles for the service. */
    role?: ServiceRole[] | ServiceRole;
    /** Filters accepted by the service. */
    accepts: FilterReference[];
    /** Transforms applied by the service. */
    transforms: string[];
    /**
     * Whether to show a progress bar when invoking this service.
     * Default is true.
     */
    show_progress?: boolean;
};
/**
 * @beta
 * Type representing a collection of service definitions.
 */
export type ServiceDefinitions = {
    [serviceName: string]: ServiceDefinition;
};
export type ManifestSecrets = {
    [key: string]: {
        description: string;
        default?: string;
        required?: boolean;
    };
};
/**
 * @beta
 * Type representing a job manifest.
 */
export type JobManifest = {
    /** Name of the job. */
    name: string;
    /** Description of the job. */
    description: string;
    /** Icon for the job. */
    icon: string;
    /** Optional image for the job. */
    image?: string;
    /** Optional engine for the job. */
    engine?: 'k8s' | 's3' | 'reactlive';
    /** Optional template for the job. */
    template?: string;
    /** Optional variant for the job. */
    variant?: string;
    /** Optional instance type for the job. */
    instance_type?: string;
    /** Whether to skip archiving the job. */
    no_archive?: boolean;
    /** Whether to generate a URL from logs. */
    url_from_logs?: boolean;
    /** Reusable javascript functions */
    javascript?: string;
    /** How the app is semantically bound */
    semantic_bindings?: SemanticBindings;
    /** Optional collection of transforms for the job. */
    transforms?: TransformDefinitions;
    /** Optional collection of filters for the job. */
    filters?: FilterDefinitions;
    /** Optional collection of stylers for the job. */
    stylers?: StylerDefinitions;
    /** Optional collection of services for the job. */
    services?: ServiceDefinitions;
    secrets?: ManifestSecrets;
};
//# sourceMappingURL=jobManifestTypes.d.ts.map
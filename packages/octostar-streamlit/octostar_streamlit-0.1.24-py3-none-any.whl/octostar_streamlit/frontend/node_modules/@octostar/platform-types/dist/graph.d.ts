import { Entity, Relationship } from './model';
/**
 * @beta
 * Type representing a connection between two entities with a relationship.
 */
export type EConnection = {
    /** The first entity in the connection. */
    entity1: Entity;
    /** The second entity in the connection. */
    entity2: Entity;
    /** The relationship between the two entities. */
    relationship: Relationship;
};
/**
 * @beta
 * Type representing the specification of an edge in a graph.
 */
export type EdgeSpec = {
    /** The identifier of the starting node. */
    from: string;
    /** The identifier of the ending node. */
    to: string;
    /** The label for the edge. */
    label: string;
};
/**
 * @beta
 * Type representing the specification of a graph.
 */
export type GraphSpec = {
    /** Optional workspace item associated with the graph. */
    workspace_item?: Entity;
    /** The nodes (entities) in the graph. */
    nodes: Entity[];
    /** The edges connecting the nodes in the graph. */
    edges: EdgeSpec[];
};
/**
 * @beta
 * Type representing known counts of relationships.
 */
export type KnownCounts = {
    [relationship_name: string]: number;
};
/**
 * @beta
 * Type representing an edge between two entities with a relationship.
 */
export type EntityEdge = {
    /** The starting entity of the edge. */
    from: Entity;
    /** The ending entity of the edge. */
    to: Entity;
    /** The relationship between the two entities. */
    relationship: Relationship;
};
/**
 * @beta
 * Type representing a point in 2D space.
 */
export type Point = {
    /** The x-coordinate of the point. */
    x: number;
    /** The y-coordinate of the point. */
    y: number;
};
export type GraphDataSpec = {
    entities: Entity[];
    relationships: EntityEdge[];
};
/**
 * DataContext is a container for abstract data of graph/selection/superselection. It serves like as a bridge between ontology data and linkchart.
 * Eg. linkchart uses *selection*, if it updates, it will cause linkchart to select elements with same ids to be selected on it.
 * Vice versa, if user clicks on linkchart, it will call setSelection and thus here via setEntities/setEdges from RightSidebarControllerContext anything what uses it (eg Rightsidebar or Superselect table) will be updated.
 * @param graph set of all items on graph
 * @param setGraph use to update (overwrite by replacement) what's on graph, converts EdgeSpec(s) to EntityEdge(s) (if possible), no edge discovery will be performed later, for that use addToGraph
 * @param selection set of all *selected* items on graph
 * @param setSelection use to update what's *selected* on graph
 * @param superSelection set of id of all *super selected (subselected)* items on graph
 * @param setSuperSelection use to update what's *super selected (subselected)* on graph
 * @param addToGraph add entities/relationships to graph, converts EdgeSpec(s) to EntityEdge(s) (if possible) and can also initialize discovery of all available relationships between new and existing entities
 * @param removeFromGraph remove entities/relationships from graph
 */
export type DataContextType = {
    graph: GraphDataSpec;
    setGraph: (newGraph: {
        entities: GraphDataSpec['entities'];
        relationships: (EntityEdge | EdgeSpec)[];
    }) => void;
    selection: GraphDataSpec;
    setSelection: React.Dispatch<React.SetStateAction<GraphDataSpec>>;
    superSelection: {
        entityIds: string[];
        relationshipIds: string[];
    };
    setSuperSelection: React.Dispatch<React.SetStateAction<{
        entityIds: string[];
        relationshipIds: string[];
    }>>;
    addToGraph: (graphUpdates: {
        entities: GraphDataSpec['entities'];
        relationships: (EntityEdge | EdgeSpec)[];
    }, getAllEdgesConnected?: boolean, forceUpdateEntities?: boolean) => void;
    removeFromGraph: (graph: GraphDataSpec) => void;
};
//# sourceMappingURL=graph.d.ts.map
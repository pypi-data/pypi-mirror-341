import datetime
import nanoid # type: ignore
from typing import Literal, Any
from uiform.types.documents.extractions import DocumentExtractRequest
from uiform.types.chat import ChatCompletionUiformMessage
from pydantic import BaseModel, Field,computed_field
from openai.types.chat import ChatCompletion
from uiform.types.documents.extractions import UiParsedChatCompletion
from .image_settings import ImageSettings
from .modalities import Modality
from .ai_models import Amount
from typing import Optional
from .._utils.usage.usage import compute_cost_from_model
from openai.types.chat.chat_completion_reasoning_effort import ChatCompletionReasoningEffort

ValidationsState = Literal["pending", "validated", "invalid"]

class ExtractionSource(BaseModel):
    type: Literal["api","annotation","automation.link","automation.email","automation.cron","automation.outlook","automation.endpoint", "schema.extract"] = Field( description="Type of extraction")
    id: str|None = Field( default=None,description="ID the trigger of the extraction")

class Extraction(BaseModel):
    id: str = Field(default_factory=lambda: "extr_" + nanoid.generate(), description="Unique identifier of the analysis")
    messages: list[ChatCompletionUiformMessage] = Field(default_factory=list)
    messages_gcs: str = Field(..., description="GCS path to the messages")
    file_gcs: str   = Field(..., description="GCS path to the file")
    file_id: str = Field(..., description="ID of the file")
    status: Literal["success", "failed"] = Field(..., description="Whether the analysis was successful")
    completion: UiParsedChatCompletion | ChatCompletion = Field(..., description="Response generated by the analysis")
    json_schema: Any = Field(..., description="Response format (JSON Schema or pydantic_v2.BaseModel)")
    model: str = Field(..., description="Model used for the analysis")
    temperature: float = Field(default=0.0, description="Temperature used for the analysis")
    source: ExtractionSource = Field(..., description="Source of the extraction")
    image_settings : ImageSettings = Field(default=ImageSettings(), description="Preprocessing operations applied to image before sending them to the llm")
    modality: Modality = Field(default="native", description="Modality of the extraction")
    reasoning_effort: Optional[ChatCompletionReasoningEffort] = Field(default=None, description="The effort level for the model to reason about the input data.")
    
    # Infered from the schema
    schema_id: str = Field(..., description="Version of the schema used for the analysis")
    schema_data_id: str = Field(..., description="Version of the schema data used for the analysis")
    created_at: datetime.datetime = Field(default_factory=lambda: datetime.datetime.now(datetime.timezone.utc))
    organization_id: str = Field(..., description="Organization ID of the user or application")
    validation_state: Optional[ValidationsState] = Field(default=None, description="Validation state of the extraction")
    @computed_field
    @property
    def api_cost(self) -> Optional[Amount]:
        if self.completion and self.completion.usage:
            try: 
                cost = compute_cost_from_model(self.completion.model, self.completion.usage)
                return cost
            except Exception as e:
                print(f"Error computing cost: {e}")
                return None
        return None

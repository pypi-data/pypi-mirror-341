from _typeshed import Incomplete
from pyvqnet import tensor as tensor
from pyvqnet.dtype import C_DTYPE as C_DTYPE, complex_dtype_to_float_dtype as complex_dtype_to_float_dtype, float_dtype_to_complex_dtype as float_dtype_to_complex_dtype, get_readable_dtype_str as get_readable_dtype_str
from pyvqnet.nn import Parameter as Parameter

INV_SQRT2: Incomplete
SQRT2: Incomplete

def expand_matrix(mat, wires, wire_order, format: str = 'dense'): ...
def check_wires_valid(valid_num, wires, name) -> None: ...
def check_wires(wires, num_wires) -> None: ...
def check_param_dim_valid(valid_num, param, name) -> None: ...
def find_nodes_without_post(node): ...
def cov_matrix(prob, obs, wires: Incomplete | None = None, diag_approx: bool = False): ...
def marginal_prob(prob, num_wires, wires): ...
def probs(q_state, num_wires, wires): ...
def rearrange_coeff(wires, coeff): ...
def vqc_paulisum_str_parse(paulisum_str, num_wires): ...
def qpanda_paulisum_str_parse(qpanda_paulisum_str, num_wires):
    """
    {'X0': 0.23,'Y1':-3.5}->
    {'wires': [0,  1], 'observables': ['x', 'y']
,'coefficient':[0.23,-3.5]} 
    
    """
def helper_parse_paulisum(obs, number_of_wires): ...
def apply_unitary_bmm(state, mat, wires):
    """Apply the unitary to the statevector using bmm method.

        """
def stack_broadcasted_single_qubit_rot_angles(op_dict): ...
def single_qubit_rot_angles_from_op_name(op_name: str, params: Incomplete | None = None):
    """
    unbroadcast single_qubit_rot_angles list.
    """
def save_op_history(op_history, name, wires, params, use_dagger, q_machine, obs: Incomplete | None = None) -> None: ...

op_name_dict: Incomplete

def construct_modules_from_ops(operations: list, op_class_dict, measure_name_dict): ...
def construct_op_with_autograd_param(current_gate, op_class_dict, measure_name_dict): ...

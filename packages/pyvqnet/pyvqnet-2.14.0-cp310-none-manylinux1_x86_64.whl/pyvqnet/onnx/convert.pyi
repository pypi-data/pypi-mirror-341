from ..tensor import get_global_onnx_node_id as get_global_onnx_node_id, init_global_onnx_node_id as init_global_onnx_node_id, set_global_onnx_convert_config_value as set_global_onnx_convert_config_value, set_global_onnx_init_dict as set_global_onnx_init_dict

slice_none_placeholder: int

def reduce_axes_nodes_create(op_name: str, input_name: str, outputs: list, axes: list, keepdims: int = 0, axes_name: str = '', init_list: list = []) -> list: ...
def helper_function_for_bi(i, oo, temp_name, init_list, pack_nodes): ...
def convert_adv_indexing(input, input_shape, outputs, outputs_shape, attr, init_list, pack_nodes) -> None: ...
def just_adv(key): ...
def convert_multi_adv_indexing(input, input_shape, outputs, outputs_shape, tmp_slice_list, init_list, pack_nodes, if_adv) -> None: ...
def convert_single_adv_indexing(input, input_shape, outputs, outputs_shape, tmp_slice_list, init_list, pack_nodes) -> None: ...
def convert_only_adv_indexing(input, input_shape, outputs, attr, init_list, pack_nodes) -> None: ...
def convert_basic_indexing(input, input_shape, outputs, attr, init_list, pack_nodes) -> None: ...
def convert_sort(input_names, output_names, attr, init_list, pack_nodes) -> None: ...
def convert_argsort(input_names, output_names, attr, init_list, pack_nodes) -> None: ...
def convert_reshape(input, outputs, attr, init_list): ...
def convert_var(input_names, input_shapes, output_names, attr, init_list): ...
def convert_std(input_names, input_shapes, output_names, attr, init_list): ...
def convert_mean(input_names, input_shapes, output_names, attr, init_list): ...
def convert_swapaxis(input_names, output_names, attr, init_list): ...
def convert_trigonometric(input_names, output_names, attr, init_list, opname): ...
def convert_clip(input_names, output_names, attr, init_list): ...
def convert_masked_fill(input_names, output_names, attr, opname, init_list, pack_nodes) -> None:
    '''
        mask = _cast_Bool(g, mask, False)  # type: ignore[name-defined]
    value = symbolic_helper._maybe_get_scalar(value)
    return g.op("Where", mask, symbolic_helper._if_scalar_type_as(g, value, self), self)


    '''
def convert_rounding(input_names, output_names, attr, opname, init_list): ...
def convert_logical(input_names, output_names, attr, opname, init_list): ...
def convert_topk(input_names, output_names, attr, init_list, pack_nodes) -> None: ...
def convert_trilu(input_names, output_names, attr, name, init_list, pack_nodes) -> None: ...
def convert_argtopk(input_names, output_names, attr, init_list, pack_nodes) -> None: ...
def convert_fnorm(input_names, input_shapes, output_names, attr, init_list): ...
def convert_sum(input_names, input_shapes, output_names, attr, init_list): ...
def convert_where(input_names, output_names, attr, opname, init_list, pack_nodes) -> None: ...
def convert_flip(input_names, output_names, attr, opname, init_list): ...
def convert_max(input_names, output_names, attr, init_list): ...
def convert_min(input_names, output_names, attr, init_list): ...
def convert_tranpose(input_names, output_names, attr, init_list): ...
def convert_concat(input_names, output_names, attr, init_list): ...
def convert_stack(input_names, output_names, attr, init_list): ...
def convert_tile(input_names, output_names, attr, init_list): ...
def convert_unsqueeze(input_names, output_names, attr, init_list): ...
def convert_squeeze(input_names, output_names, attr, init_list): ...
def convert_rnns(input_names, output_names, attr, op_para_buffer_id_lists, rnn_type, init_list): ...
def convert_conv2d(input_names, output_names, attr, para_names): ...
def convert_linear(input_names, output_names, attr, para_names, if_rank_2: bool = True): ...
def convert_sigmoid(input_names, output_names, attr, para_names): ...
def convert_leakyrelu(input_names, output_names, attr, para_names): ...
def convert_softplus(input_names, output_names, attr, para_names): ...
def convert_softsign(input_names, output_names, attr, para_names): ...
def convert_softmax(input_names, output_names, attr, para_names): ...
def convert_hardsigmoid(input_names, output_names, attr, para_names): ...
def convert_elu(input_names, output_names, attr, para_names): ...
def convert_tanh(input_names, output_names, attr, para_names): ...
def convert_flatten(input_names, output_names, attr, para_names): ...
def convert_add_sub_mul_div(input_names, output_names, opname): ...
def convert_relu(input_names, output_names, attr, para_names): ...
def convert_conv1d(input_names, output_names, attr, para_names): ...
def convert_convt2d(input_names, output_names, attr, para_names): ...
def convert_bn(input_names, output_names, attr, para_names): ...
def create_helper_tensor_node(input_vals, output_name, param_name_init_list):
    """create extra tensor node from numpy values"""
def convert_dropout(input_names, output_names, attr, para_names, param_name_init_list): ...
def convert_embedding(input_names, output_names, attr, para_names): ...
def convert_ln(input_names, output_names, attr, para_names, init_lists): ...
def convert_mp(input_names, output_names, attr, para_names, init_lists): ...
def convert_ap(input_names, output_names, attr, para_names, init_lists): ...
def convert_set_indexing(input, input_shape, outputs, outputs_shape, attr, init_list, pack_nodes, if_adv: bool = False) -> None: ...
def convert_adv_set_indexing(input, input_shape, outputs, outputs_shape, attr, init_list, pack_nodes) -> None: ...

# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ApikeyTimeoutsArgs',
    'ApikeyTimeoutsArgsDict',
    'MetricsEndpointTimeoutsArgs',
    'MetricsEndpointTimeoutsArgsDict',
    'NamespaceCertificateFilterArgs',
    'NamespaceCertificateFilterArgsDict',
    'NamespaceCodecServerArgs',
    'NamespaceCodecServerArgsDict',
    'NamespaceEndpointsArgs',
    'NamespaceEndpointsArgsDict',
    'NamespaceExportSinkGcsArgs',
    'NamespaceExportSinkGcsArgsDict',
    'NamespaceExportSinkS3Args',
    'NamespaceExportSinkS3ArgsDict',
    'NamespaceExportSinkTimeoutsArgs',
    'NamespaceExportSinkTimeoutsArgsDict',
    'NamespaceTimeoutsArgs',
    'NamespaceTimeoutsArgsDict',
    'NexusEndpointTimeoutsArgs',
    'NexusEndpointTimeoutsArgsDict',
    'NexusEndpointWorkerTargetArgs',
    'NexusEndpointWorkerTargetArgsDict',
    'ServiceAccountNamespaceAccessArgs',
    'ServiceAccountNamespaceAccessArgsDict',
    'ServiceAccountTimeoutsArgs',
    'ServiceAccountTimeoutsArgsDict',
    'UserNamespaceAccessArgs',
    'UserNamespaceAccessArgsDict',
    'UserTimeoutsArgs',
    'UserTimeoutsArgsDict',
    'GetNamespaceCertificateFilterArgs',
    'GetNamespaceCertificateFilterArgsDict',
    'GetNamespaceCodecServerArgs',
    'GetNamespaceCodecServerArgsDict',
    'GetNamespacePrivateConnectivityArgs',
    'GetNamespacePrivateConnectivityArgsDict',
    'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgs',
    'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgsDict',
    'GetServiceAccountNamespaceAccessArgs',
    'GetServiceAccountNamespaceAccessArgsDict',
]

MYPY = False

if not MYPY:
    class ApikeyTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ApikeyTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApikeyTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class MetricsEndpointTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    MetricsEndpointTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsEndpointTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class NamespaceCertificateFilterArgsDict(TypedDict):
        common_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The certificate's common name.
        """
        organization: NotRequired[pulumi.Input[builtins.str]]
        """
        The certificate's organization.
        """
        organizational_unit: NotRequired[pulumi.Input[builtins.str]]
        """
        The certificate's organizational unit.
        """
        subject_alternative_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The certificate's subject alternative name (or SAN).
        """
elif False:
    NamespaceCertificateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceCertificateFilterArgs:
    def __init__(__self__, *,
                 common_name: Optional[pulumi.Input[builtins.str]] = None,
                 organization: Optional[pulumi.Input[builtins.str]] = None,
                 organizational_unit: Optional[pulumi.Input[builtins.str]] = None,
                 subject_alternative_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] common_name: The certificate's common name.
        :param pulumi.Input[builtins.str] organization: The certificate's organization.
        :param pulumi.Input[builtins.str] organizational_unit: The certificate's organizational unit.
        :param pulumi.Input[builtins.str] subject_alternative_name: The certificate's subject alternative name (or SAN).
        """
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if subject_alternative_name is not None:
            pulumi.set(__self__, "subject_alternative_name", subject_alternative_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The certificate's common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The certificate's organization.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The certificate's organizational unit.
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="subjectAlternativeName")
    def subject_alternative_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The certificate's subject alternative name (or SAN).
        """
        return pulumi.get(self, "subject_alternative_name")

    @subject_alternative_name.setter
    def subject_alternative_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject_alternative_name", value)


if not MYPY:
    class NamespaceCodecServerArgsDict(TypedDict):
        endpoint: pulumi.Input[builtins.str]
        """
        The endpoint of the codec server. Must begin with "https".
        """
        include_cross_origin_credentials: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        """
        pass_access_token: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
elif False:
    NamespaceCodecServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceCodecServerArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[builtins.str],
                 include_cross_origin_credentials: Optional[pulumi.Input[builtins.bool]] = None,
                 pass_access_token: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] endpoint: The endpoint of the codec server. Must begin with "https".
        :param pulumi.Input[builtins.bool] include_cross_origin_credentials: If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        :param pulumi.Input[builtins.bool] pass_access_token: If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if include_cross_origin_credentials is not None:
            pulumi.set(__self__, "include_cross_origin_credentials", include_cross_origin_credentials)
        if pass_access_token is not None:
            pulumi.set(__self__, "pass_access_token", pass_access_token)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[builtins.str]:
        """
        The endpoint of the codec server. Must begin with "https".
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="includeCrossOriginCredentials")
    def include_cross_origin_credentials(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        """
        return pulumi.get(self, "include_cross_origin_credentials")

    @include_cross_origin_credentials.setter
    def include_cross_origin_credentials(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_cross_origin_credentials", value)

    @property
    @pulumi.getter(name="passAccessToken")
    def pass_access_token(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        return pulumi.get(self, "pass_access_token")

    @pass_access_token.setter
    def pass_access_token(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "pass_access_token", value)


if not MYPY:
    class NamespaceEndpointsArgsDict(TypedDict):
        grpc_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The gRPC address for API key client connections (may be empty if API keys are disabled).
        """
        mtls_grpc_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
        """
        web_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The address in the Temporal Cloud Web UI for the namespace
        """
elif False:
    NamespaceEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceEndpointsArgs:
    def __init__(__self__, *,
                 grpc_address: Optional[pulumi.Input[builtins.str]] = None,
                 mtls_grpc_address: Optional[pulumi.Input[builtins.str]] = None,
                 web_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] grpc_address: The gRPC address for API key client connections (may be empty if API keys are disabled).
        :param pulumi.Input[builtins.str] mtls_grpc_address: The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
        :param pulumi.Input[builtins.str] web_address: The address in the Temporal Cloud Web UI for the namespace
        """
        if grpc_address is not None:
            pulumi.set(__self__, "grpc_address", grpc_address)
        if mtls_grpc_address is not None:
            pulumi.set(__self__, "mtls_grpc_address", mtls_grpc_address)
        if web_address is not None:
            pulumi.set(__self__, "web_address", web_address)

    @property
    @pulumi.getter(name="grpcAddress")
    def grpc_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gRPC address for API key client connections (may be empty if API keys are disabled).
        """
        return pulumi.get(self, "grpc_address")

    @grpc_address.setter
    def grpc_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "grpc_address", value)

    @property
    @pulumi.getter(name="mtlsGrpcAddress")
    def mtls_grpc_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
        """
        return pulumi.get(self, "mtls_grpc_address")

    @mtls_grpc_address.setter
    def mtls_grpc_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mtls_grpc_address", value)

    @property
    @pulumi.getter(name="webAddress")
    def web_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The address in the Temporal Cloud Web UI for the namespace
        """
        return pulumi.get(self, "web_address")

    @web_address.setter
    def web_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "web_address", value)


if not MYPY:
    class NamespaceExportSinkGcsArgsDict(TypedDict):
        bucket_name: pulumi.Input[builtins.str]
        """
        The name of the destination GCS bucket where Temporal will send data.
        """
        gcp_project_id: pulumi.Input[builtins.str]
        """
        The GCP project ID associated with the GCS bucket and service account.
        """
        region: pulumi.Input[builtins.str]
        """
        The region of the gcs bucket
        """
        service_account_id: pulumi.Input[builtins.str]
        """
        The customer service account ID that Temporal Cloud impersonates for writing records to the customer's GCS bucket.
        """
elif False:
    NamespaceExportSinkGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceExportSinkGcsArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[builtins.str],
                 gcp_project_id: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 service_account_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] bucket_name: The name of the destination GCS bucket where Temporal will send data.
        :param pulumi.Input[builtins.str] gcp_project_id: The GCP project ID associated with the GCS bucket and service account.
        :param pulumi.Input[builtins.str] region: The region of the gcs bucket
        :param pulumi.Input[builtins.str] service_account_id: The customer service account ID that Temporal Cloud impersonates for writing records to the customer's GCS bucket.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the destination GCS bucket where Temporal will send data.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> pulumi.Input[builtins.str]:
        """
        The GCP project ID associated with the GCS bucket and service account.
        """
        return pulumi.get(self, "gcp_project_id")

    @gcp_project_id.setter
    def gcp_project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "gcp_project_id", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The region of the gcs bucket
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> pulumi.Input[builtins.str]:
        """
        The customer service account ID that Temporal Cloud impersonates for writing records to the customer's GCS bucket.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class NamespaceExportSinkS3ArgsDict(TypedDict):
        aws_account_id: pulumi.Input[builtins.str]
        """
        The AWS account ID associated with the S3 bucket and the assumed role.
        """
        bucket_name: pulumi.Input[builtins.str]
        """
        The name of the destination S3 bucket where Temporal will send data.
        """
        kms_arn: pulumi.Input[builtins.str]
        """
        The AWS Key Management Service (KMS) ARN used for encryption.
        """
        region: pulumi.Input[builtins.str]
        """
        The region where the S3 bucket is located.
        """
        role_name: pulumi.Input[builtins.str]
        """
        The IAM role that Temporal Cloud assumes for writing records to the customer's S3 bucket.
        """
elif False:
    NamespaceExportSinkS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceExportSinkS3Args:
    def __init__(__self__, *,
                 aws_account_id: pulumi.Input[builtins.str],
                 bucket_name: pulumi.Input[builtins.str],
                 kms_arn: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 role_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] aws_account_id: The AWS account ID associated with the S3 bucket and the assumed role.
        :param pulumi.Input[builtins.str] bucket_name: The name of the destination S3 bucket where Temporal will send data.
        :param pulumi.Input[builtins.str] kms_arn: The AWS Key Management Service (KMS) ARN used for encryption.
        :param pulumi.Input[builtins.str] region: The region where the S3 bucket is located.
        :param pulumi.Input[builtins.str] role_name: The IAM role that Temporal Cloud assumes for writing records to the customer's S3 bucket.
        """
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "kms_arn", kms_arn)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> pulumi.Input[builtins.str]:
        """
        The AWS account ID associated with the S3 bucket and the assumed role.
        """
        return pulumi.get(self, "aws_account_id")

    @aws_account_id.setter
    def aws_account_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "aws_account_id", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the destination S3 bucket where Temporal will send data.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="kmsArn")
    def kms_arn(self) -> pulumi.Input[builtins.str]:
        """
        The AWS Key Management Service (KMS) ARN used for encryption.
        """
        return pulumi.get(self, "kms_arn")

    @kms_arn.setter
    def kms_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "kms_arn", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The region where the S3 bucket is located.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[builtins.str]:
        """
        The IAM role that Temporal Cloud assumes for writing records to the customer's S3 bucket.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_name", value)


if not MYPY:
    class NamespaceExportSinkTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    NamespaceExportSinkTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceExportSinkTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class NamespaceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    NamespaceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class NexusEndpointTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    NexusEndpointTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NexusEndpointTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class NexusEndpointWorkerTargetArgsDict(TypedDict):
        namespace_id: pulumi.Input[builtins.str]
        """
        The target cloud namespace to route requests to. Namespace must be in same account as the endpoint.
        """
        task_queue: pulumi.Input[builtins.str]
        """
        The task queue on the cloud namespace to route requests to.
        """
elif False:
    NexusEndpointWorkerTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NexusEndpointWorkerTargetArgs:
    def __init__(__self__, *,
                 namespace_id: pulumi.Input[builtins.str],
                 task_queue: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] namespace_id: The target cloud namespace to route requests to. Namespace must be in same account as the endpoint.
        :param pulumi.Input[builtins.str] task_queue: The task queue on the cloud namespace to route requests to.
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "task_queue", task_queue)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> pulumi.Input[builtins.str]:
        """
        The target cloud namespace to route requests to. Namespace must be in same account as the endpoint.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter(name="taskQueue")
    def task_queue(self) -> pulumi.Input[builtins.str]:
        """
        The task queue on the cloud namespace to route requests to.
        """
        return pulumi.get(self, "task_queue")

    @task_queue.setter
    def task_queue(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "task_queue", value)


if not MYPY:
    class ServiceAccountNamespaceAccessArgsDict(TypedDict):
        namespace_id: pulumi.Input[builtins.str]
        """
        The namespace to assign permissions to.
        """
        permission: pulumi.Input[builtins.str]
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
elif False:
    ServiceAccountNamespaceAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAccountNamespaceAccessArgs:
    def __init__(__self__, *,
                 namespace_id: pulumi.Input[builtins.str],
                 permission: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] namespace_id: The namespace to assign permissions to.
        :param pulumi.Input[builtins.str] permission: The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> pulumi.Input[builtins.str]:
        """
        The namespace to assign permissions to.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[builtins.str]:
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class ServiceAccountTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ServiceAccountTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAccountTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class UserNamespaceAccessArgsDict(TypedDict):
        namespace_id: pulumi.Input[builtins.str]
        """
        The namespace to assign permissions to.
        """
        permission: pulumi.Input[builtins.str]
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
elif False:
    UserNamespaceAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserNamespaceAccessArgs:
    def __init__(__self__, *,
                 namespace_id: pulumi.Input[builtins.str],
                 permission: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] namespace_id: The namespace to assign permissions to.
        :param pulumi.Input[builtins.str] permission: The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> pulumi.Input[builtins.str]:
        """
        The namespace to assign permissions to.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[builtins.str]:
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class UserTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    UserTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class GetNamespaceCertificateFilterArgsDict(TypedDict):
        common_name: builtins.str
        """
        The certificate's common name.
        """
        organization: builtins.str
        """
        The certificate's organization.
        """
        organizational_unit: builtins.str
        """
        The certificate's organizational unit.
        """
        subject_alternative_name: builtins.str
        """
        The certificate's subject alternative name (or SAN).
        """
elif False:
    GetNamespaceCertificateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceCertificateFilterArgs:
    def __init__(__self__, *,
                 common_name: builtins.str,
                 organization: builtins.str,
                 organizational_unit: builtins.str,
                 subject_alternative_name: builtins.str):
        """
        :param builtins.str common_name: The certificate's common name.
        :param builtins.str organization: The certificate's organization.
        :param builtins.str organizational_unit: The certificate's organizational unit.
        :param builtins.str subject_alternative_name: The certificate's subject alternative name (or SAN).
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "organizational_unit", organizational_unit)
        pulumi.set(__self__, "subject_alternative_name", subject_alternative_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> builtins.str:
        """
        The certificate's common name.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: builtins.str):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def organization(self) -> builtins.str:
        """
        The certificate's organization.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: builtins.str):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> builtins.str:
        """
        The certificate's organizational unit.
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: builtins.str):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="subjectAlternativeName")
    def subject_alternative_name(self) -> builtins.str:
        """
        The certificate's subject alternative name (or SAN).
        """
        return pulumi.get(self, "subject_alternative_name")

    @subject_alternative_name.setter
    def subject_alternative_name(self, value: builtins.str):
        pulumi.set(self, "subject_alternative_name", value)


if not MYPY:
    class GetNamespaceCodecServerArgsDict(TypedDict):
        endpoint: builtins.str
        """
        The endpoint of the codec server.
        """
        include_cross_origin_credentials: builtins.bool
        """
        If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        """
        pass_access_token: builtins.bool
        """
        If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
elif False:
    GetNamespaceCodecServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespaceCodecServerArgs:
    def __init__(__self__, *,
                 endpoint: builtins.str,
                 include_cross_origin_credentials: builtins.bool,
                 pass_access_token: builtins.bool):
        """
        :param builtins.str endpoint: The endpoint of the codec server.
        :param builtins.bool include_cross_origin_credentials: If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        :param builtins.bool pass_access_token: If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "include_cross_origin_credentials", include_cross_origin_credentials)
        pulumi.set(__self__, "pass_access_token", pass_access_token)

    @property
    @pulumi.getter
    def endpoint(self) -> builtins.str:
        """
        The endpoint of the codec server.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: builtins.str):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="includeCrossOriginCredentials")
    def include_cross_origin_credentials(self) -> builtins.bool:
        """
        If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        """
        return pulumi.get(self, "include_cross_origin_credentials")

    @include_cross_origin_credentials.setter
    def include_cross_origin_credentials(self, value: builtins.bool):
        pulumi.set(self, "include_cross_origin_credentials", value)

    @property
    @pulumi.getter(name="passAccessToken")
    def pass_access_token(self) -> builtins.bool:
        """
        If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        return pulumi.get(self, "pass_access_token")

    @pass_access_token.setter
    def pass_access_token(self, value: builtins.bool):
        pulumi.set(self, "pass_access_token", value)


if not MYPY:
    class GetNamespacePrivateConnectivityArgsDict(TypedDict):
        aws_private_link_info: 'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgsDict'
        """
        The AWS PrivateLink info. This will only be set for namespaces whose cloud provider is AWS.
        """
        region: builtins.str
        """
        The id of the region where the private connectivity applies.
        """
elif False:
    GetNamespacePrivateConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespacePrivateConnectivityArgs:
    def __init__(__self__, *,
                 aws_private_link_info: 'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgs',
                 region: builtins.str):
        """
        :param 'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgs' aws_private_link_info: The AWS PrivateLink info. This will only be set for namespaces whose cloud provider is AWS.
        :param builtins.str region: The id of the region where the private connectivity applies.
        """
        pulumi.set(__self__, "aws_private_link_info", aws_private_link_info)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="awsPrivateLinkInfo")
    def aws_private_link_info(self) -> 'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgs':
        """
        The AWS PrivateLink info. This will only be set for namespaces whose cloud provider is AWS.
        """
        return pulumi.get(self, "aws_private_link_info")

    @aws_private_link_info.setter
    def aws_private_link_info(self, value: 'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgs'):
        pulumi.set(self, "aws_private_link_info", value)

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        The id of the region where the private connectivity applies.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: builtins.str):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgsDict(TypedDict):
        allowed_principal_arns: Sequence[builtins.str]
        """
        The list of principal arns that are allowed to access the namespace on the private link.
        """
        vpc_endpoint_service_names: Sequence[builtins.str]
        """
        The list of vpc endpoint service names that are associated with the namespace.
        """
elif False:
    GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgs:
    def __init__(__self__, *,
                 allowed_principal_arns: Sequence[builtins.str],
                 vpc_endpoint_service_names: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] allowed_principal_arns: The list of principal arns that are allowed to access the namespace on the private link.
        :param Sequence[builtins.str] vpc_endpoint_service_names: The list of vpc endpoint service names that are associated with the namespace.
        """
        pulumi.set(__self__, "allowed_principal_arns", allowed_principal_arns)
        pulumi.set(__self__, "vpc_endpoint_service_names", vpc_endpoint_service_names)

    @property
    @pulumi.getter(name="allowedPrincipalArns")
    def allowed_principal_arns(self) -> Sequence[builtins.str]:
        """
        The list of principal arns that are allowed to access the namespace on the private link.
        """
        return pulumi.get(self, "allowed_principal_arns")

    @allowed_principal_arns.setter
    def allowed_principal_arns(self, value: Sequence[builtins.str]):
        pulumi.set(self, "allowed_principal_arns", value)

    @property
    @pulumi.getter(name="vpcEndpointServiceNames")
    def vpc_endpoint_service_names(self) -> Sequence[builtins.str]:
        """
        The list of vpc endpoint service names that are associated with the namespace.
        """
        return pulumi.get(self, "vpc_endpoint_service_names")

    @vpc_endpoint_service_names.setter
    def vpc_endpoint_service_names(self, value: Sequence[builtins.str]):
        pulumi.set(self, "vpc_endpoint_service_names", value)


if not MYPY:
    class GetServiceAccountNamespaceAccessArgsDict(TypedDict):
        namespace_id: builtins.str
        """
        The namespace to assign permissions to.
        """
        permission: builtins.str
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
elif False:
    GetServiceAccountNamespaceAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceAccountNamespaceAccessArgs:
    def __init__(__self__, *,
                 namespace_id: builtins.str,
                 permission: builtins.str):
        """
        :param builtins.str namespace_id: The namespace to assign permissions to.
        :param builtins.str permission: The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        The namespace to assign permissions to.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: builtins.str):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter
    def permission(self) -> builtins.str:
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: builtins.str):
        pulumi.set(self, "permission", value)



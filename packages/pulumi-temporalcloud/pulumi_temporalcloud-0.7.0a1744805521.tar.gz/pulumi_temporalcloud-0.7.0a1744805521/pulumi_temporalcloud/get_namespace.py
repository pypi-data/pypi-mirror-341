# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetNamespaceResult',
    'AwaitableGetNamespaceResult',
    'get_namespace',
    'get_namespace_output',
]

@pulumi.output_type
class GetNamespaceResult:
    """
    A collection of values returned by getNamespace.
    """
    def __init__(__self__, accepted_client_ca=None, active_region=None, api_key_auth=None, certificate_filters=None, codec_server=None, created_time=None, custom_search_attributes=None, endpoints=None, id=None, last_modified_time=None, limits=None, name=None, private_connectivities=None, regions=None, retention_days=None, state=None):
        if accepted_client_ca and not isinstance(accepted_client_ca, str):
            raise TypeError("Expected argument 'accepted_client_ca' to be a str")
        pulumi.set(__self__, "accepted_client_ca", accepted_client_ca)
        if active_region and not isinstance(active_region, str):
            raise TypeError("Expected argument 'active_region' to be a str")
        pulumi.set(__self__, "active_region", active_region)
        if api_key_auth and not isinstance(api_key_auth, bool):
            raise TypeError("Expected argument 'api_key_auth' to be a bool")
        pulumi.set(__self__, "api_key_auth", api_key_auth)
        if certificate_filters and not isinstance(certificate_filters, list):
            raise TypeError("Expected argument 'certificate_filters' to be a list")
        pulumi.set(__self__, "certificate_filters", certificate_filters)
        if codec_server and not isinstance(codec_server, dict):
            raise TypeError("Expected argument 'codec_server' to be a dict")
        pulumi.set(__self__, "codec_server", codec_server)
        if created_time and not isinstance(created_time, str):
            raise TypeError("Expected argument 'created_time' to be a str")
        pulumi.set(__self__, "created_time", created_time)
        if custom_search_attributes and not isinstance(custom_search_attributes, dict):
            raise TypeError("Expected argument 'custom_search_attributes' to be a dict")
        pulumi.set(__self__, "custom_search_attributes", custom_search_attributes)
        if endpoints and not isinstance(endpoints, dict):
            raise TypeError("Expected argument 'endpoints' to be a dict")
        pulumi.set(__self__, "endpoints", endpoints)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if last_modified_time and not isinstance(last_modified_time, str):
            raise TypeError("Expected argument 'last_modified_time' to be a str")
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        if limits and not isinstance(limits, dict):
            raise TypeError("Expected argument 'limits' to be a dict")
        pulumi.set(__self__, "limits", limits)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if private_connectivities and not isinstance(private_connectivities, list):
            raise TypeError("Expected argument 'private_connectivities' to be a list")
        pulumi.set(__self__, "private_connectivities", private_connectivities)
        if regions and not isinstance(regions, list):
            raise TypeError("Expected argument 'regions' to be a list")
        pulumi.set(__self__, "regions", regions)
        if retention_days and not isinstance(retention_days, int):
            raise TypeError("Expected argument 'retention_days' to be a int")
        pulumi.set(__self__, "retention_days", retention_days)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="acceptedClientCa")
    def accepted_client_ca(self) -> builtins.str:
        """
        The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud.
        """
        return pulumi.get(self, "accepted_client_ca")

    @property
    @pulumi.getter(name="activeRegion")
    def active_region(self) -> builtins.str:
        """
        The currently active region for the namespace.
        """
        return pulumi.get(self, "active_region")

    @property
    @pulumi.getter(name="apiKeyAuth")
    def api_key_auth(self) -> Optional[builtins.bool]:
        """
        If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
        """
        return pulumi.get(self, "api_key_auth")

    @property
    @pulumi.getter(name="certificateFilters")
    def certificate_filters(self) -> Sequence['outputs.GetNamespaceCertificateFilterResult']:
        """
        A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters.
        """
        return pulumi.get(self, "certificate_filters")

    @property
    @pulumi.getter(name="codecServer")
    def codec_server(self) -> 'outputs.GetNamespaceCodecServerResult':
        """
        A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
        """
        return pulumi.get(self, "codec_server")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> builtins.str:
        """
        The date and time when the namespace was created.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="customSearchAttributes")
    def custom_search_attributes(self) -> Mapping[str, builtins.str]:
        """
        The custom search attributes to use for the namespace.
        """
        return pulumi.get(self, "custom_search_attributes")

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.GetNamespaceEndpointsResult':
        """
        The endpoints for the namespace.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The unique identifier of the namespace across all Temporal Cloud tenants.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> builtins.str:
        """
        The date and time when the namespace was last modified. Will not be set if the namespace has never been modified.
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter
    def limits(self) -> 'outputs.GetNamespaceLimitsResult':
        """
        The limits set on the namespace currently.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the namespace.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateConnectivities")
    def private_connectivities(self) -> Sequence['outputs.GetNamespacePrivateConnectivityResult']:
        """
        The private connectivities for the namespace, if any.
        """
        return pulumi.get(self, "private_connectivities")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> builtins.int:
        """
        The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The current state of the namespace.
        """
        return pulumi.get(self, "state")


class AwaitableGetNamespaceResult(GetNamespaceResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetNamespaceResult(
            accepted_client_ca=self.accepted_client_ca,
            active_region=self.active_region,
            api_key_auth=self.api_key_auth,
            certificate_filters=self.certificate_filters,
            codec_server=self.codec_server,
            created_time=self.created_time,
            custom_search_attributes=self.custom_search_attributes,
            endpoints=self.endpoints,
            id=self.id,
            last_modified_time=self.last_modified_time,
            limits=self.limits,
            name=self.name,
            private_connectivities=self.private_connectivities,
            regions=self.regions,
            retention_days=self.retention_days,
            state=self.state)


def get_namespace(api_key_auth: Optional[builtins.bool] = None,
                  certificate_filters: Optional[Sequence[Union['GetNamespaceCertificateFilterArgs', 'GetNamespaceCertificateFilterArgsDict']]] = None,
                  codec_server: Optional[Union['GetNamespaceCodecServerArgs', 'GetNamespaceCodecServerArgsDict']] = None,
                  custom_search_attributes: Optional[Mapping[str, builtins.str]] = None,
                  id: Optional[builtins.str] = None,
                  last_modified_time: Optional[builtins.str] = None,
                  private_connectivities: Optional[Sequence[Union['GetNamespacePrivateConnectivityArgs', 'GetNamespacePrivateConnectivityArgsDict']]] = None,
                  opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetNamespaceResult:
    """
    Fetches details about a Namespace.


    :param builtins.bool api_key_auth: If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
    :param Sequence[Union['GetNamespaceCertificateFilterArgs', 'GetNamespaceCertificateFilterArgsDict']] certificate_filters: A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters.
    :param Union['GetNamespaceCodecServerArgs', 'GetNamespaceCodecServerArgsDict'] codec_server: A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
    :param Mapping[str, builtins.str] custom_search_attributes: The custom search attributes to use for the namespace.
    :param builtins.str id: The unique identifier of the namespace across all Temporal Cloud tenants.
    :param builtins.str last_modified_time: The date and time when the namespace was last modified. Will not be set if the namespace has never been modified.
    :param Sequence[Union['GetNamespacePrivateConnectivityArgs', 'GetNamespacePrivateConnectivityArgsDict']] private_connectivities: The private connectivities for the namespace, if any.
    """
    __args__ = dict()
    __args__['apiKeyAuth'] = api_key_auth
    __args__['certificateFilters'] = certificate_filters
    __args__['codecServer'] = codec_server
    __args__['customSearchAttributes'] = custom_search_attributes
    __args__['id'] = id
    __args__['lastModifiedTime'] = last_modified_time
    __args__['privateConnectivities'] = private_connectivities
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('temporalcloud:index/getNamespace:getNamespace', __args__, opts=opts, typ=GetNamespaceResult).value

    return AwaitableGetNamespaceResult(
        accepted_client_ca=pulumi.get(__ret__, 'accepted_client_ca'),
        active_region=pulumi.get(__ret__, 'active_region'),
        api_key_auth=pulumi.get(__ret__, 'api_key_auth'),
        certificate_filters=pulumi.get(__ret__, 'certificate_filters'),
        codec_server=pulumi.get(__ret__, 'codec_server'),
        created_time=pulumi.get(__ret__, 'created_time'),
        custom_search_attributes=pulumi.get(__ret__, 'custom_search_attributes'),
        endpoints=pulumi.get(__ret__, 'endpoints'),
        id=pulumi.get(__ret__, 'id'),
        last_modified_time=pulumi.get(__ret__, 'last_modified_time'),
        limits=pulumi.get(__ret__, 'limits'),
        name=pulumi.get(__ret__, 'name'),
        private_connectivities=pulumi.get(__ret__, 'private_connectivities'),
        regions=pulumi.get(__ret__, 'regions'),
        retention_days=pulumi.get(__ret__, 'retention_days'),
        state=pulumi.get(__ret__, 'state'))
def get_namespace_output(api_key_auth: Optional[pulumi.Input[Optional[builtins.bool]]] = None,
                         certificate_filters: Optional[pulumi.Input[Optional[Sequence[Union['GetNamespaceCertificateFilterArgs', 'GetNamespaceCertificateFilterArgsDict']]]]] = None,
                         codec_server: Optional[pulumi.Input[Optional[Union['GetNamespaceCodecServerArgs', 'GetNamespaceCodecServerArgsDict']]]] = None,
                         custom_search_attributes: Optional[pulumi.Input[Optional[Mapping[str, builtins.str]]]] = None,
                         id: Optional[pulumi.Input[builtins.str]] = None,
                         last_modified_time: Optional[pulumi.Input[Optional[builtins.str]]] = None,
                         private_connectivities: Optional[pulumi.Input[Optional[Sequence[Union['GetNamespacePrivateConnectivityArgs', 'GetNamespacePrivateConnectivityArgsDict']]]]] = None,
                         opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetNamespaceResult]:
    """
    Fetches details about a Namespace.


    :param builtins.bool api_key_auth: If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
    :param Sequence[Union['GetNamespaceCertificateFilterArgs', 'GetNamespaceCertificateFilterArgsDict']] certificate_filters: A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters.
    :param Union['GetNamespaceCodecServerArgs', 'GetNamespaceCodecServerArgsDict'] codec_server: A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
    :param Mapping[str, builtins.str] custom_search_attributes: The custom search attributes to use for the namespace.
    :param builtins.str id: The unique identifier of the namespace across all Temporal Cloud tenants.
    :param builtins.str last_modified_time: The date and time when the namespace was last modified. Will not be set if the namespace has never been modified.
    :param Sequence[Union['GetNamespacePrivateConnectivityArgs', 'GetNamespacePrivateConnectivityArgsDict']] private_connectivities: The private connectivities for the namespace, if any.
    """
    __args__ = dict()
    __args__['apiKeyAuth'] = api_key_auth
    __args__['certificateFilters'] = certificate_filters
    __args__['codecServer'] = codec_server
    __args__['customSearchAttributes'] = custom_search_attributes
    __args__['id'] = id
    __args__['lastModifiedTime'] = last_modified_time
    __args__['privateConnectivities'] = private_connectivities
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('temporalcloud:index/getNamespace:getNamespace', __args__, opts=opts, typ=GetNamespaceResult)
    return __ret__.apply(lambda __response__: GetNamespaceResult(
        accepted_client_ca=pulumi.get(__response__, 'accepted_client_ca'),
        active_region=pulumi.get(__response__, 'active_region'),
        api_key_auth=pulumi.get(__response__, 'api_key_auth'),
        certificate_filters=pulumi.get(__response__, 'certificate_filters'),
        codec_server=pulumi.get(__response__, 'codec_server'),
        created_time=pulumi.get(__response__, 'created_time'),
        custom_search_attributes=pulumi.get(__response__, 'custom_search_attributes'),
        endpoints=pulumi.get(__response__, 'endpoints'),
        id=pulumi.get(__response__, 'id'),
        last_modified_time=pulumi.get(__response__, 'last_modified_time'),
        limits=pulumi.get(__response__, 'limits'),
        name=pulumi.get(__response__, 'name'),
        private_connectivities=pulumi.get(__response__, 'private_connectivities'),
        regions=pulumi.get(__response__, 'regions'),
        retention_days=pulumi.get(__response__, 'retention_days'),
        state=pulumi.get(__response__, 'state')))

# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ApikeyTimeouts',
    'MetricsEndpointTimeouts',
    'NamespaceCertificateFilter',
    'NamespaceCodecServer',
    'NamespaceEndpoints',
    'NamespaceExportSinkGcs',
    'NamespaceExportSinkS3',
    'NamespaceExportSinkTimeouts',
    'NamespaceTimeouts',
    'NexusEndpointTimeouts',
    'NexusEndpointWorkerTarget',
    'ServiceAccountNamespaceAccess',
    'ServiceAccountTimeouts',
    'UserNamespaceAccess',
    'UserTimeouts',
    'GetNamespaceCertificateFilterResult',
    'GetNamespaceCodecServerResult',
    'GetNamespaceEndpointsResult',
    'GetNamespaceLimitsResult',
    'GetNamespacePrivateConnectivityResult',
    'GetNamespacePrivateConnectivityAwsPrivateLinkInfoResult',
    'GetNamespacesNamespaceResult',
    'GetNamespacesNamespaceCertificateFilterResult',
    'GetNamespacesNamespaceCodecServerResult',
    'GetNamespacesNamespaceEndpointsResult',
    'GetNamespacesNamespaceLimitsResult',
    'GetNamespacesNamespacePrivateConnectivityResult',
    'GetNamespacesNamespacePrivateConnectivityAwsPrivateLinkInfoResult',
    'GetRegionsRegionResult',
    'GetServiceAccountNamespaceAccessResult',
    'GetServiceAccountsServiceAccountResult',
    'GetServiceAccountsServiceAccountNamespaceAccessResult',
]

@pulumi.output_type
class ApikeyTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class MetricsEndpointTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None,
                 update: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class NamespaceCertificateFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "subjectAlternativeName":
            suggest = "subject_alternative_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceCertificateFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceCertificateFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceCertificateFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: Optional[builtins.str] = None,
                 organization: Optional[builtins.str] = None,
                 organizational_unit: Optional[builtins.str] = None,
                 subject_alternative_name: Optional[builtins.str] = None):
        """
        :param builtins.str common_name: The certificate's common name.
        :param builtins.str organization: The certificate's organization.
        :param builtins.str organizational_unit: The certificate's organizational unit.
        :param builtins.str subject_alternative_name: The certificate's subject alternative name (or SAN).
        """
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if subject_alternative_name is not None:
            pulumi.set(__self__, "subject_alternative_name", subject_alternative_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[builtins.str]:
        """
        The certificate's common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def organization(self) -> Optional[builtins.str]:
        """
        The certificate's organization.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[builtins.str]:
        """
        The certificate's organizational unit.
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="subjectAlternativeName")
    def subject_alternative_name(self) -> Optional[builtins.str]:
        """
        The certificate's subject alternative name (or SAN).
        """
        return pulumi.get(self, "subject_alternative_name")


@pulumi.output_type
class NamespaceCodecServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeCrossOriginCredentials":
            suggest = "include_cross_origin_credentials"
        elif key == "passAccessToken":
            suggest = "pass_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceCodecServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceCodecServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceCodecServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: builtins.str,
                 include_cross_origin_credentials: Optional[builtins.bool] = None,
                 pass_access_token: Optional[builtins.bool] = None):
        """
        :param builtins.str endpoint: The endpoint of the codec server. Must begin with "https".
        :param builtins.bool include_cross_origin_credentials: If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        :param builtins.bool pass_access_token: If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if include_cross_origin_credentials is not None:
            pulumi.set(__self__, "include_cross_origin_credentials", include_cross_origin_credentials)
        if pass_access_token is not None:
            pulumi.set(__self__, "pass_access_token", pass_access_token)

    @property
    @pulumi.getter
    def endpoint(self) -> builtins.str:
        """
        The endpoint of the codec server. Must begin with "https".
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="includeCrossOriginCredentials")
    def include_cross_origin_credentials(self) -> Optional[builtins.bool]:
        """
        If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        """
        return pulumi.get(self, "include_cross_origin_credentials")

    @property
    @pulumi.getter(name="passAccessToken")
    def pass_access_token(self) -> Optional[builtins.bool]:
        """
        If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        return pulumi.get(self, "pass_access_token")


@pulumi.output_type
class NamespaceEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcAddress":
            suggest = "grpc_address"
        elif key == "mtlsGrpcAddress":
            suggest = "mtls_grpc_address"
        elif key == "webAddress":
            suggest = "web_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_address: Optional[builtins.str] = None,
                 mtls_grpc_address: Optional[builtins.str] = None,
                 web_address: Optional[builtins.str] = None):
        """
        :param builtins.str grpc_address: The gRPC address for API key client connections (may be empty if API keys are disabled).
        :param builtins.str mtls_grpc_address: The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
        :param builtins.str web_address: The address in the Temporal Cloud Web UI for the namespace
        """
        if grpc_address is not None:
            pulumi.set(__self__, "grpc_address", grpc_address)
        if mtls_grpc_address is not None:
            pulumi.set(__self__, "mtls_grpc_address", mtls_grpc_address)
        if web_address is not None:
            pulumi.set(__self__, "web_address", web_address)

    @property
    @pulumi.getter(name="grpcAddress")
    def grpc_address(self) -> Optional[builtins.str]:
        """
        The gRPC address for API key client connections (may be empty if API keys are disabled).
        """
        return pulumi.get(self, "grpc_address")

    @property
    @pulumi.getter(name="mtlsGrpcAddress")
    def mtls_grpc_address(self) -> Optional[builtins.str]:
        """
        The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
        """
        return pulumi.get(self, "mtls_grpc_address")

    @property
    @pulumi.getter(name="webAddress")
    def web_address(self) -> Optional[builtins.str]:
        """
        The address in the Temporal Cloud Web UI for the namespace
        """
        return pulumi.get(self, "web_address")


@pulumi.output_type
class NamespaceExportSinkGcs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "gcpProjectId":
            suggest = "gcp_project_id"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceExportSinkGcs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceExportSinkGcs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceExportSinkGcs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: builtins.str,
                 gcp_project_id: builtins.str,
                 region: builtins.str,
                 service_account_id: builtins.str):
        """
        :param builtins.str bucket_name: The name of the destination GCS bucket where Temporal will send data.
        :param builtins.str gcp_project_id: The GCP project ID associated with the GCS bucket and service account.
        :param builtins.str region: The region of the gcs bucket
        :param builtins.str service_account_id: The customer service account ID that Temporal Cloud impersonates for writing records to the customer's GCS bucket.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> builtins.str:
        """
        The name of the destination GCS bucket where Temporal will send data.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> builtins.str:
        """
        The GCP project ID associated with the GCS bucket and service account.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        The region of the gcs bucket
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> builtins.str:
        """
        The customer service account ID that Temporal Cloud impersonates for writing records to the customer's GCS bucket.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class NamespaceExportSinkS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "kmsArn":
            suggest = "kms_arn"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceExportSinkS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceExportSinkS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceExportSinkS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_account_id: builtins.str,
                 bucket_name: builtins.str,
                 kms_arn: builtins.str,
                 region: builtins.str,
                 role_name: builtins.str):
        """
        :param builtins.str aws_account_id: The AWS account ID associated with the S3 bucket and the assumed role.
        :param builtins.str bucket_name: The name of the destination S3 bucket where Temporal will send data.
        :param builtins.str kms_arn: The AWS Key Management Service (KMS) ARN used for encryption.
        :param builtins.str region: The region where the S3 bucket is located.
        :param builtins.str role_name: The IAM role that Temporal Cloud assumes for writing records to the customer's S3 bucket.
        """
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "kms_arn", kms_arn)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> builtins.str:
        """
        The AWS account ID associated with the S3 bucket and the assumed role.
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> builtins.str:
        """
        The name of the destination S3 bucket where Temporal will send data.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="kmsArn")
    def kms_arn(self) -> builtins.str:
        """
        The AWS Key Management Service (KMS) ARN used for encryption.
        """
        return pulumi.get(self, "kms_arn")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        The region where the S3 bucket is located.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> builtins.str:
        """
        The IAM role that Temporal Cloud assumes for writing records to the customer's S3 bucket.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class NamespaceExportSinkTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class NamespaceTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class NexusEndpointTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class NexusEndpointWorkerTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"
        elif key == "taskQueue":
            suggest = "task_queue"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NexusEndpointWorkerTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NexusEndpointWorkerTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NexusEndpointWorkerTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_id: builtins.str,
                 task_queue: builtins.str):
        """
        :param builtins.str namespace_id: The target cloud namespace to route requests to. Namespace must be in same account as the endpoint.
        :param builtins.str task_queue: The task queue on the cloud namespace to route requests to.
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "task_queue", task_queue)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        The target cloud namespace to route requests to. Namespace must be in same account as the endpoint.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="taskQueue")
    def task_queue(self) -> builtins.str:
        """
        The task queue on the cloud namespace to route requests to.
        """
        return pulumi.get(self, "task_queue")


@pulumi.output_type
class ServiceAccountNamespaceAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAccountNamespaceAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAccountNamespaceAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAccountNamespaceAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_id: builtins.str,
                 permission: builtins.str):
        """
        :param builtins.str namespace_id: The namespace to assign permissions to.
        :param builtins.str permission: The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        The namespace to assign permissions to.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter
    def permission(self) -> builtins.str:
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class ServiceAccountTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class UserNamespaceAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserNamespaceAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserNamespaceAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserNamespaceAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_id: builtins.str,
                 permission: builtins.str):
        """
        :param builtins.str namespace_id: The namespace to assign permissions to.
        :param builtins.str permission: The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        The namespace to assign permissions to.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter
    def permission(self) -> builtins.str:
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class UserTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[builtins.str] = None,
                 delete: Optional[builtins.str] = None):
        """
        :param builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class GetNamespaceCertificateFilterResult(dict):
    def __init__(__self__, *,
                 common_name: builtins.str,
                 organization: builtins.str,
                 organizational_unit: builtins.str,
                 subject_alternative_name: builtins.str):
        """
        :param builtins.str common_name: The certificate's common name.
        :param builtins.str organization: The certificate's organization.
        :param builtins.str organizational_unit: The certificate's organizational unit.
        :param builtins.str subject_alternative_name: The certificate's subject alternative name (or SAN).
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "organizational_unit", organizational_unit)
        pulumi.set(__self__, "subject_alternative_name", subject_alternative_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> builtins.str:
        """
        The certificate's common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def organization(self) -> builtins.str:
        """
        The certificate's organization.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> builtins.str:
        """
        The certificate's organizational unit.
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="subjectAlternativeName")
    def subject_alternative_name(self) -> builtins.str:
        """
        The certificate's subject alternative name (or SAN).
        """
        return pulumi.get(self, "subject_alternative_name")


@pulumi.output_type
class GetNamespaceCodecServerResult(dict):
    def __init__(__self__, *,
                 endpoint: builtins.str,
                 include_cross_origin_credentials: builtins.bool,
                 pass_access_token: builtins.bool):
        """
        :param builtins.str endpoint: The endpoint of the codec server.
        :param builtins.bool include_cross_origin_credentials: If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        :param builtins.bool pass_access_token: If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "include_cross_origin_credentials", include_cross_origin_credentials)
        pulumi.set(__self__, "pass_access_token", pass_access_token)

    @property
    @pulumi.getter
    def endpoint(self) -> builtins.str:
        """
        The endpoint of the codec server.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="includeCrossOriginCredentials")
    def include_cross_origin_credentials(self) -> builtins.bool:
        """
        If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        """
        return pulumi.get(self, "include_cross_origin_credentials")

    @property
    @pulumi.getter(name="passAccessToken")
    def pass_access_token(self) -> builtins.bool:
        """
        If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        return pulumi.get(self, "pass_access_token")


@pulumi.output_type
class GetNamespaceEndpointsResult(dict):
    def __init__(__self__, *,
                 grpc_address: builtins.str,
                 web_address: builtins.str):
        """
        :param builtins.str grpc_address: The gRPC hostport address that the temporal workers, clients and tctl connect to.
        :param builtins.str web_address: The web UI address.
        """
        pulumi.set(__self__, "grpc_address", grpc_address)
        pulumi.set(__self__, "web_address", web_address)

    @property
    @pulumi.getter(name="grpcAddress")
    def grpc_address(self) -> builtins.str:
        """
        The gRPC hostport address that the temporal workers, clients and tctl connect to.
        """
        return pulumi.get(self, "grpc_address")

    @property
    @pulumi.getter(name="webAddress")
    def web_address(self) -> builtins.str:
        """
        The web UI address.
        """
        return pulumi.get(self, "web_address")


@pulumi.output_type
class GetNamespaceLimitsResult(dict):
    def __init__(__self__, *,
                 actions_per_second_limit: builtins.int):
        """
        :param builtins.int actions_per_second_limit: The number of actions per second (APS) that is currently allowed for the namespace. The namespace may be throttled if its APS exceeds the limit.
        """
        pulumi.set(__self__, "actions_per_second_limit", actions_per_second_limit)

    @property
    @pulumi.getter(name="actionsPerSecondLimit")
    def actions_per_second_limit(self) -> builtins.int:
        """
        The number of actions per second (APS) that is currently allowed for the namespace. The namespace may be throttled if its APS exceeds the limit.
        """
        return pulumi.get(self, "actions_per_second_limit")


@pulumi.output_type
class GetNamespacePrivateConnectivityResult(dict):
    def __init__(__self__, *,
                 aws_private_link_info: 'outputs.GetNamespacePrivateConnectivityAwsPrivateLinkInfoResult',
                 region: builtins.str):
        """
        :param 'GetNamespacePrivateConnectivityAwsPrivateLinkInfoArgs' aws_private_link_info: The AWS PrivateLink info. This will only be set for namespaces whose cloud provider is AWS.
        :param builtins.str region: The id of the region where the private connectivity applies.
        """
        pulumi.set(__self__, "aws_private_link_info", aws_private_link_info)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="awsPrivateLinkInfo")
    def aws_private_link_info(self) -> 'outputs.GetNamespacePrivateConnectivityAwsPrivateLinkInfoResult':
        """
        The AWS PrivateLink info. This will only be set for namespaces whose cloud provider is AWS.
        """
        return pulumi.get(self, "aws_private_link_info")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        The id of the region where the private connectivity applies.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetNamespacePrivateConnectivityAwsPrivateLinkInfoResult(dict):
    def __init__(__self__, *,
                 allowed_principal_arns: Sequence[builtins.str],
                 vpc_endpoint_service_names: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] allowed_principal_arns: The list of principal arns that are allowed to access the namespace on the private link.
        :param Sequence[builtins.str] vpc_endpoint_service_names: The list of vpc endpoint service names that are associated with the namespace.
        """
        pulumi.set(__self__, "allowed_principal_arns", allowed_principal_arns)
        pulumi.set(__self__, "vpc_endpoint_service_names", vpc_endpoint_service_names)

    @property
    @pulumi.getter(name="allowedPrincipalArns")
    def allowed_principal_arns(self) -> Sequence[builtins.str]:
        """
        The list of principal arns that are allowed to access the namespace on the private link.
        """
        return pulumi.get(self, "allowed_principal_arns")

    @property
    @pulumi.getter(name="vpcEndpointServiceNames")
    def vpc_endpoint_service_names(self) -> Sequence[builtins.str]:
        """
        The list of vpc endpoint service names that are associated with the namespace.
        """
        return pulumi.get(self, "vpc_endpoint_service_names")


@pulumi.output_type
class GetNamespacesNamespaceResult(dict):
    def __init__(__self__, *,
                 accepted_client_ca: builtins.str,
                 active_region: builtins.str,
                 certificate_filters: Sequence['outputs.GetNamespacesNamespaceCertificateFilterResult'],
                 codec_server: 'outputs.GetNamespacesNamespaceCodecServerResult',
                 created_time: builtins.str,
                 custom_search_attributes: Mapping[str, builtins.str],
                 endpoints: 'outputs.GetNamespacesNamespaceEndpointsResult',
                 id: builtins.str,
                 last_modified_time: builtins.str,
                 limits: 'outputs.GetNamespacesNamespaceLimitsResult',
                 name: builtins.str,
                 private_connectivities: Sequence['outputs.GetNamespacesNamespacePrivateConnectivityResult'],
                 regions: Sequence[builtins.str],
                 retention_days: builtins.int,
                 state: builtins.str,
                 api_key_auth: Optional[builtins.bool] = None):
        """
        :param builtins.str accepted_client_ca: The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud.
        :param builtins.str active_region: The currently active region for the namespace.
        :param Sequence['GetNamespacesNamespaceCertificateFilterArgs'] certificate_filters: A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters.
        :param 'GetNamespacesNamespaceCodecServerArgs' codec_server: A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
        :param builtins.str created_time: The date and time when the namespace was created.
        :param Mapping[str, builtins.str] custom_search_attributes: The custom search attributes to use for the namespace.
        :param 'GetNamespacesNamespaceEndpointsArgs' endpoints: The endpoints for the namespace.
        :param builtins.str id: The unique identifier of the namespace across all Temporal Cloud tenants.
        :param builtins.str last_modified_time: The date and time when the namespace was last modified. Will not be set if the namespace has never been modified.
        :param 'GetNamespacesNamespaceLimitsArgs' limits: The limits set on the namespace currently.
        :param builtins.str name: The name of the namespace.
        :param Sequence['GetNamespacesNamespacePrivateConnectivityArgs'] private_connectivities: The private connectivities for the namespace, if any.
        :param builtins.int retention_days: The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
        :param builtins.str state: The current state of the namespace.
        :param builtins.bool api_key_auth: If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
        """
        pulumi.set(__self__, "accepted_client_ca", accepted_client_ca)
        pulumi.set(__self__, "active_region", active_region)
        pulumi.set(__self__, "certificate_filters", certificate_filters)
        pulumi.set(__self__, "codec_server", codec_server)
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "custom_search_attributes", custom_search_attributes)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_connectivities", private_connectivities)
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "retention_days", retention_days)
        pulumi.set(__self__, "state", state)
        if api_key_auth is not None:
            pulumi.set(__self__, "api_key_auth", api_key_auth)

    @property
    @pulumi.getter(name="acceptedClientCa")
    def accepted_client_ca(self) -> builtins.str:
        """
        The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud.
        """
        return pulumi.get(self, "accepted_client_ca")

    @property
    @pulumi.getter(name="activeRegion")
    def active_region(self) -> builtins.str:
        """
        The currently active region for the namespace.
        """
        return pulumi.get(self, "active_region")

    @property
    @pulumi.getter(name="certificateFilters")
    def certificate_filters(self) -> Sequence['outputs.GetNamespacesNamespaceCertificateFilterResult']:
        """
        A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters.
        """
        return pulumi.get(self, "certificate_filters")

    @property
    @pulumi.getter(name="codecServer")
    def codec_server(self) -> 'outputs.GetNamespacesNamespaceCodecServerResult':
        """
        A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
        """
        return pulumi.get(self, "codec_server")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> builtins.str:
        """
        The date and time when the namespace was created.
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="customSearchAttributes")
    def custom_search_attributes(self) -> Mapping[str, builtins.str]:
        """
        The custom search attributes to use for the namespace.
        """
        return pulumi.get(self, "custom_search_attributes")

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.GetNamespacesNamespaceEndpointsResult':
        """
        The endpoints for the namespace.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The unique identifier of the namespace across all Temporal Cloud tenants.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> builtins.str:
        """
        The date and time when the namespace was last modified. Will not be set if the namespace has never been modified.
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter
    def limits(self) -> 'outputs.GetNamespacesNamespaceLimitsResult':
        """
        The limits set on the namespace currently.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the namespace.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateConnectivities")
    def private_connectivities(self) -> Sequence['outputs.GetNamespacesNamespacePrivateConnectivityResult']:
        """
        The private connectivities for the namespace, if any.
        """
        return pulumi.get(self, "private_connectivities")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> builtins.int:
        """
        The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
        """
        return pulumi.get(self, "retention_days")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The current state of the namespace.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="apiKeyAuth")
    def api_key_auth(self) -> Optional[builtins.bool]:
        """
        If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
        """
        return pulumi.get(self, "api_key_auth")


@pulumi.output_type
class GetNamespacesNamespaceCertificateFilterResult(dict):
    def __init__(__self__, *,
                 common_name: builtins.str,
                 organization: builtins.str,
                 organizational_unit: builtins.str,
                 subject_alternative_name: builtins.str):
        """
        :param builtins.str common_name: The certificate's common name.
        :param builtins.str organization: The certificate's organization.
        :param builtins.str organizational_unit: The certificate's organizational unit.
        :param builtins.str subject_alternative_name: The certificate's subject alternative name (or SAN).
        """
        pulumi.set(__self__, "common_name", common_name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "organizational_unit", organizational_unit)
        pulumi.set(__self__, "subject_alternative_name", subject_alternative_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> builtins.str:
        """
        The certificate's common name.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter
    def organization(self) -> builtins.str:
        """
        The certificate's organization.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> builtins.str:
        """
        The certificate's organizational unit.
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter(name="subjectAlternativeName")
    def subject_alternative_name(self) -> builtins.str:
        """
        The certificate's subject alternative name (or SAN).
        """
        return pulumi.get(self, "subject_alternative_name")


@pulumi.output_type
class GetNamespacesNamespaceCodecServerResult(dict):
    def __init__(__self__, *,
                 endpoint: builtins.str,
                 include_cross_origin_credentials: builtins.bool,
                 pass_access_token: builtins.bool):
        """
        :param builtins.str endpoint: The endpoint of the codec server.
        :param builtins.bool include_cross_origin_credentials: If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        :param builtins.bool pass_access_token: If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "include_cross_origin_credentials", include_cross_origin_credentials)
        pulumi.set(__self__, "pass_access_token", pass_access_token)

    @property
    @pulumi.getter
    def endpoint(self) -> builtins.str:
        """
        The endpoint of the codec server.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="includeCrossOriginCredentials")
    def include_cross_origin_credentials(self) -> builtins.bool:
        """
        If true, Temporal Cloud will include cross-origin credentials in requests to the codec server.
        """
        return pulumi.get(self, "include_cross_origin_credentials")

    @property
    @pulumi.getter(name="passAccessToken")
    def pass_access_token(self) -> builtins.bool:
        """
        If true, Temporal Cloud will pass the access token to the codec server upon each request.
        """
        return pulumi.get(self, "pass_access_token")


@pulumi.output_type
class GetNamespacesNamespaceEndpointsResult(dict):
    def __init__(__self__, *,
                 grpc_address: builtins.str,
                 web_address: builtins.str):
        """
        :param builtins.str grpc_address: The gRPC hostport address that the temporal workers, clients and tctl connect to.
        :param builtins.str web_address: The web UI address.
        """
        pulumi.set(__self__, "grpc_address", grpc_address)
        pulumi.set(__self__, "web_address", web_address)

    @property
    @pulumi.getter(name="grpcAddress")
    def grpc_address(self) -> builtins.str:
        """
        The gRPC hostport address that the temporal workers, clients and tctl connect to.
        """
        return pulumi.get(self, "grpc_address")

    @property
    @pulumi.getter(name="webAddress")
    def web_address(self) -> builtins.str:
        """
        The web UI address.
        """
        return pulumi.get(self, "web_address")


@pulumi.output_type
class GetNamespacesNamespaceLimitsResult(dict):
    def __init__(__self__, *,
                 actions_per_second_limit: builtins.int):
        """
        :param builtins.int actions_per_second_limit: The number of actions per second (APS) that is currently allowed for the namespace. The namespace may be throttled if its APS exceeds the limit.
        """
        pulumi.set(__self__, "actions_per_second_limit", actions_per_second_limit)

    @property
    @pulumi.getter(name="actionsPerSecondLimit")
    def actions_per_second_limit(self) -> builtins.int:
        """
        The number of actions per second (APS) that is currently allowed for the namespace. The namespace may be throttled if its APS exceeds the limit.
        """
        return pulumi.get(self, "actions_per_second_limit")


@pulumi.output_type
class GetNamespacesNamespacePrivateConnectivityResult(dict):
    def __init__(__self__, *,
                 aws_private_link_info: 'outputs.GetNamespacesNamespacePrivateConnectivityAwsPrivateLinkInfoResult',
                 region: builtins.str):
        """
        :param 'GetNamespacesNamespacePrivateConnectivityAwsPrivateLinkInfoArgs' aws_private_link_info: The AWS PrivateLink info. This will only be set for namespaces whose cloud provider is AWS.
        :param builtins.str region: The id of the region where the private connectivity applies.
        """
        pulumi.set(__self__, "aws_private_link_info", aws_private_link_info)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="awsPrivateLinkInfo")
    def aws_private_link_info(self) -> 'outputs.GetNamespacesNamespacePrivateConnectivityAwsPrivateLinkInfoResult':
        """
        The AWS PrivateLink info. This will only be set for namespaces whose cloud provider is AWS.
        """
        return pulumi.get(self, "aws_private_link_info")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        The id of the region where the private connectivity applies.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetNamespacesNamespacePrivateConnectivityAwsPrivateLinkInfoResult(dict):
    def __init__(__self__, *,
                 allowed_principal_arns: Sequence[builtins.str],
                 vpc_endpoint_service_names: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] allowed_principal_arns: The list of principal arns that are allowed to access the namespace on the private link.
        :param Sequence[builtins.str] vpc_endpoint_service_names: The list of vpc endpoint service names that are associated with the namespace.
        """
        pulumi.set(__self__, "allowed_principal_arns", allowed_principal_arns)
        pulumi.set(__self__, "vpc_endpoint_service_names", vpc_endpoint_service_names)

    @property
    @pulumi.getter(name="allowedPrincipalArns")
    def allowed_principal_arns(self) -> Sequence[builtins.str]:
        """
        The list of principal arns that are allowed to access the namespace on the private link.
        """
        return pulumi.get(self, "allowed_principal_arns")

    @property
    @pulumi.getter(name="vpcEndpointServiceNames")
    def vpc_endpoint_service_names(self) -> Sequence[builtins.str]:
        """
        The list of vpc endpoint service names that are associated with the namespace.
        """
        return pulumi.get(self, "vpc_endpoint_service_names")


@pulumi.output_type
class GetRegionsRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: builtins.str,
                 cloud_provider_region: builtins.str,
                 id: builtins.str,
                 location: builtins.str):
        """
        :param builtins.str cloud_provider: The name of the Cloud provider for this region, e.g. `aws`.
        :param builtins.str cloud_provider_region: The name of the region within the Cloud provider, e.g. `us-east-1`.
        :param builtins.str id: The unique identifier for the region, e.g. `aws-us-east-1`.
        :param builtins.str location: The physical location of the region, e.g. "US East (N. Virginia)".
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cloud_provider_region", cloud_provider_region)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> builtins.str:
        """
        The name of the Cloud provider for this region, e.g. `aws`.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="cloudProviderRegion")
    def cloud_provider_region(self) -> builtins.str:
        """
        The name of the region within the Cloud provider, e.g. `us-east-1`.
        """
        return pulumi.get(self, "cloud_provider_region")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The unique identifier for the region, e.g. `aws-us-east-1`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        """
        The physical location of the region, e.g. "US East (N. Virginia)".
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class GetServiceAccountNamespaceAccessResult(dict):
    def __init__(__self__, *,
                 namespace_id: builtins.str,
                 permission: builtins.str):
        """
        :param builtins.str namespace_id: The namespace to assign permissions to.
        :param builtins.str permission: The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        The namespace to assign permissions to.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter
    def permission(self) -> builtins.str:
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetServiceAccountsServiceAccountResult(dict):
    def __init__(__self__, *,
                 account_access: builtins.str,
                 created_at: builtins.str,
                 description: builtins.str,
                 id: builtins.str,
                 name: builtins.str,
                 namespace_accesses: Sequence['outputs.GetServiceAccountsServiceAccountNamespaceAccessResult'],
                 state: builtins.str,
                 updated_at: builtins.str):
        """
        :param builtins.str account_access: The role on the account. Must be one of admin, developer, or read (case-insensitive).
        :param builtins.str created_at: The creation time of the Service Account.
        :param builtins.str description: The description of the Service Account.
        :param builtins.str id: The unique identifier of the Service Account.
        :param builtins.str name: The name associated with the service account.
        :param Sequence['GetServiceAccountsServiceAccountNamespaceAccessArgs'] namespace_accesses: The set of namespace permissions for this service account, including each namespace and its role.
        :param builtins.str state: The current state of the Service Account.
        :param builtins.str updated_at: The last update time of the Service Account.
        """
        pulumi.set(__self__, "account_access", account_access)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_accesses", namespace_accesses)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="accountAccess")
    def account_access(self) -> builtins.str:
        """
        The role on the account. Must be one of admin, developer, or read (case-insensitive).
        """
        return pulumi.get(self, "account_access")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        The creation time of the Service Account.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        The description of the Service Account.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The unique identifier of the Service Account.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name associated with the service account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceAccesses")
    def namespace_accesses(self) -> Sequence['outputs.GetServiceAccountsServiceAccountNamespaceAccessResult']:
        """
        The set of namespace permissions for this service account, including each namespace and its role.
        """
        return pulumi.get(self, "namespace_accesses")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        The current state of the Service Account.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> builtins.str:
        """
        The last update time of the Service Account.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetServiceAccountsServiceAccountNamespaceAccessResult(dict):
    def __init__(__self__, *,
                 namespace_id: builtins.str,
                 permission: builtins.str):
        """
        :param builtins.str namespace_id: The namespace to assign permissions to.
        :param builtins.str permission: The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> builtins.str:
        """
        The namespace to assign permissions to.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter
    def permission(self) -> builtins.str:
        """
        The permission to assign. Must be one of admin, write, or read (case-insensitive)
        """
        return pulumi.get(self, "permission")



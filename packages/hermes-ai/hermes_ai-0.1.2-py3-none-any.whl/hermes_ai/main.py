import joblib
import ollama
import pandas as pd
from models.data_processor import increase_data
from models.classifier import train
classifier = joblib.load('./models/classifier_model')
vectorizer = joblib.load('./models/vectorizer')
  
def r_classify(message):
  """
  Classifies a message into one of three response categories: 'ignore', 'action', or 'reply'.
  Args:
    message (str): The input message to be classified.
  Returns:
    str: A string representing the classification result:
       - 'R0' for 'ignore'
       - 'R1' for 'action'
       - 'R2' for 'reply'
  Notes:
    The classification is determined by the result of the `get_action` function,
    which analyzes the input message and returns an action string.
  """
  switcher = {
    'ignore': 'R0',
    'action': 'R1',
    'reply': 'R2',
  }  
  
  action = get_action(message)
  
  if action == 'ignore':
    return switcher['ignore']   
  elif action == 'reply':
    return switcher['reply']
  else:
    return switcher['action']
  
def get_action(message):
  """
  Classifies the action of the given message and returns the corresponding action.

  Args:
    message (str): The message to be classified into an action.

  Returns:
    str: The action to be taken based on the classification. Possible actions are:
      - 'make appointment': If the message is classified as a schedule-related message and the message requires to create an appointment.
      - 'cancel appointment': If the message is classified as a schedule-related message and the message requires to cancel an appointment.
      - 'reschedule appointment': If the message is classified as a shcedule-related message and the message reuiqres to reschedule an appointment.
      - 'refer previous message': If the message is classified as a forward-related message and the message requires to point to a specific past message.
      - 'forward information': If the message is classified as a forward-related message and the message requires to share info with someone else.
      - 'reply': If the message is classified as a reply-related message.
      - 'ignore': If the message is classified as an ignore-related message.
  """
  message_count = vectorizer.transform([message])
  return classifier.predict(message_count)[0]

def reply(conversation = None, contactType = None):
  """
  Generates a concise reply to a given conversation using ollama. The reply takes in account the contact type, if provided.
  
  Args:
    conversation (list, optional): A list of message objects, where each object contains 'content' and 'sender' attributes. Defaults to None.
    contactType (str, optional): The type of contact with whom the conversation took place. Defaults to None.
  
  Returns:
    str: The generated reply to the conversation or an error message if the conversation is not provided.
  """
  if conversation is None or len(conversation) == 0:
    return 'Conversation no provided'

  str_conversation = ''
  for i in range(len(conversation)):
    previous_message = conversation[i]['content']
    sender = conversation[i]['sender']
    str_conversation += sender + ": " + previous_message + "\n"

  if contactType is None:
    result = ollama.generate(model='llama3.1', prompt='Reply concisely the following conversation as if you were me. Reply only with one message: \n' + str_conversation)
  else:
    result = ollama.generate(model='llama3.1', prompt='I had a conversation with ' + contactType + '. Reply concisely the conversation as if you were me. Reply only with one message: \n' + str_conversation)
  
  return result['response']

def summarize(conversation):
  """
  Summarizes a conversation using ollama.
  
  Args:
    conversation (list of dict): A list of dictionaries where each dictionary represents a message in the conversation.
      Each dictionary should have the keys 'content' (str) and 'sender' (str).
  
  Returns:
    str: A brief summary of the conversation generated by the ollama model.
  """
  str_conversation = ''
  for i in range(len(conversation)):
    previous_message = conversation[i]['content']
    sender = conversation[i]['sender']
    str_conversation += sender + ": " + previous_message + "\n"
    
  result = ollama.generate(model='llama3.1', prompt='Briefly summarize the following conversation. Only respond with the summary:' + str_conversation)
  return result['response']

def reinforce(new_messages, actions):
  """
  Updates the dataset with new messages and actions, and retrains the model.
  This function performs two main tasks:
  1. Updates the existing dataset (`messages_actions.csv`) by appending new
     messages and their corresponding actions.
  2. Retrains the model using the updated dataset.
  Args:
    new_messages (list of str): A list of new messages to be added to the dataset.
    actions (list of str): A list of actions corresponding to the new messages.
  Returns:
    None
  """
  if(len(new_messages)!=len(actions)):
    return 'Error: the number of messages and actions must match'
  
  #fisrt update data
  old_df = pd.read_csv('./data/messages_actions.csv')
  new_df = pd.DataFrame({
      'message':new_messages,
      'action':actions
    })
  df = increase_data(old_df,new_df)
  df.to_csv('./data/messages_actions.csv', index=False)
  
  #re-train model
  train()
  
  return 'New data added. The model has been retrained sucessfully'

r_classify('Hello')
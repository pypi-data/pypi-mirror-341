"""
Client for the National Vulnerability Database (NVD) API.
"""

import os
import json
import time
import logging
import hashlib
import datetime
from typing import Dict, List, Any, Optional, Union
from urllib.parse import quote

import requests
import aiohttp
import asyncio
from tqdm import tqdm

from ossv_scanner.vulnerability.vulnerability import Vulnerability
from ossv_scanner.caching.cache import Cache

logger = logging.getLogger(__name__)


class NVDClient:
    """Client for querying the NVD API for vulnerabilities."""

    # NVD API endpoints
    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    
    # Rate limits
    RATE_LIMIT_SLEEP = 6.0  # Sleep time between requests (public API is limited to 10 req/min)
    RATE_LIMIT_AUTHENTICATED_SLEEP = 0.6  # Sleep time with API key (100 req/min)
    
    def __init__(
        self,
        api_key: Optional[str] = None,
        cache: Optional[Cache] = None,
        timeout: int = 60,
        max_retries: int = 3,
        rate_limit_sleep: Optional[float] = None
    ):
        """
        Initialize the NVD client.

        Args:
            api_key: API key for the NVD API.
            cache: Cache instance for caching responses.
            timeout: Timeout for HTTP requests in seconds.
            max_retries: Maximum number of retries for failed requests.
            rate_limit_sleep: Custom sleep time between requests.
        """
        self.api_key = api_key
        self.cache = cache
        self.timeout = timeout
        self.max_retries = max_retries
        
        # Set rate limit sleep time based on API key presence
        if rate_limit_sleep is not None:
            self.rate_limit_sleep = rate_limit_sleep
        elif api_key:
            self.rate_limit_sleep = self.RATE_LIMIT_AUTHENTICATED_SLEEP
        else:
            self.rate_limit_sleep = self.RATE_LIMIT_SLEEP
        
        # Track the last request time for rate limiting
        self.last_request_time = 0
    
    def get_vulnerabilities(
        self, package_name: str, package_version: str
    ) -> List[Dict[str, Any]]:
        """
        Get vulnerabilities for a package.

        Args:
            package_name: Name of the package.
            package_version: Version of the package.

        Returns:
            List of vulnerability dictionaries.
        """
        logger.debug(f"Getting vulnerabilities for {package_name}@{package_version}")
        
        # Skip very short package names (likely to cause API issues)
        if len(package_name) <= 1:
            logger.info(f"Skipping very short package name: '{package_name}' (NVD API limitation)")
            return []
        
        # Try to get from cache first
        cache_key = f"vuln:{package_name}:{package_version}"
        if self.cache:
            cached_data = self.cache.get(cache_key)
            if cached_data:
                logger.debug(f"Cache hit for {cache_key}")
                return cached_data
        
        # Search for vulnerabilities
        try:
            vulnerabilities = self._search_vulnerabilities(package_name)
            
            # Filter vulnerabilities by affected version
            # Note: Version filtering is simplified here; a production system would use
            # a proper version comparison library and CPE matching
            results = []
            for vuln_data in vulnerabilities:
                vuln = Vulnerability.from_nvd(vuln_data)
                if self._is_version_affected(package_version, vuln_data):
                    results.append(vuln.to_dict())
            
            # Cache the results
            if self.cache:
                self.cache.set(cache_key, results)
            
            return results
        
        except Exception as e:
            logger.error(f"Error getting vulnerabilities for {package_name}: {str(e)}")
            raise
    
    async def get_vulnerabilities_async(
        self, packages: List[Dict[str, str]]
    ) -> Dict[str, List[Dict[str, Any]]]:
        """
        Get vulnerabilities for multiple packages asynchronously.

        Args:
            packages: List of dictionaries with 'name' and 'version' keys.

        Returns:
            Dictionary mapping package identifiers to lists of vulnerabilities.
        """
        results = {}
        
        # Use a semaphore to limit concurrent requests
        semaphore = asyncio.Semaphore(5)  # Maximum 5 concurrent requests
        
        async with aiohttp.ClientSession() as session:
            tasks = []
            for package in packages:
                if len(package["name"]) <= 1:
                    # Skip very short package names
                    package_id = f"{package['name']}@{package['version']}"
                    results[package_id] = []
                    continue
                    
                task = asyncio.ensure_future(
                    self._get_package_vulnerabilities_async(
                        session, semaphore, package["name"], package["version"]
                    )
                )
                tasks.append(task)
            
            # Wait for all tasks to complete
            for completed_task in tqdm(
                asyncio.as_completed(tasks),
                total=len(tasks),
                desc="Checking vulnerabilities"
            ):
                package_id, vulns = await completed_task
                results[package_id] = vulns
        
        return results
    
    async def _get_package_vulnerabilities_async(
        self,
        session: aiohttp.ClientSession,
        semaphore: asyncio.Semaphore,
        package_name: str,
        package_version: str
    ) -> tuple:
        """
        Get vulnerabilities for a package asynchronously.

        Args:
            session: aiohttp ClientSession.
            semaphore: Semaphore for limiting concurrent requests.
            package_name: Name of the package.
            package_version: Version of the package.

        Returns:
            Tuple of (package_id, vulnerabilities).
        """
        package_id = f"{package_name}@{package_version}"
        
        # Skip very short package names
        if len(package_name) <= 1:
            logger.info(f"Skipping very short package name: '{package_name}' (NVD API limitation)")
            return package_id, []
        
        # Try to get from cache first
        cache_key = f"vuln:{package_name}:{package_version}"
        if self.cache:
            cached_data = self.cache.get(cache_key)
            if cached_data:
                logger.debug(f"Cache hit for {cache_key}")
                return package_id, cached_data
        
        # Rate limiting
        await self._async_rate_limit()
        
        async with semaphore:
            try:
                # Build the request URL
                url = f"{self.BASE_URL}?keywordSearch={quote(package_name)}"
                
                # Set up headers
                headers = {"User-Agent": "ossv-scanner/0.1.0"}
                if self.api_key:
                    headers["apiKey"] = self.api_key
                
                # Make the request
                async with session.get(url, headers=headers, timeout=self.timeout) as response:
                    # Update last request time
                    self.last_request_time = time.time()
                    
                    if response.status == 200:
                        data = await response.json()
                        vulnerabilities = data.get("vulnerabilities", [])
                        
                        # Extract the actual vulnerability data
                        vuln_data_list = [v.get("cve", {}) for v in vulnerabilities]
                        
                        # Filter vulnerabilities by affected version
                        results = []
                        for vuln_data in vuln_data_list:
                            vuln = Vulnerability.from_nvd(vuln_data)
                            if self._is_version_affected(package_version, vuln_data):
                                results.append(vuln.to_dict())
                        
                        # Cache the results
                        if self.cache:
                            self.cache.set(cache_key, results)
                        
                        return package_id, results
                    
                    elif response.status == 404:
                        logger.info(f"No vulnerability data found for {package_name} (404 response)")
                        return package_id, []
                        
                    else:
                        error_msg = await response.text()
                        logger.error(
                            f"Error {response.status} from NVD API for {package_name}: {error_msg}"
                        )
                        return package_id, []
            
            except Exception as e:
                logger.error(f"Error getting vulnerabilities for {package_name}: {str(e)}")
                return package_id, []
    
    def _search_vulnerabilities(self, package_name: str) -> List[Dict[str, Any]]:
        """
        Search for vulnerabilities by package name.

        Args:
            package_name: Name of the package.

        Returns:
            List of vulnerability data dictionaries.
        """
        # Skip very short package names that are likely to cause errors
        if len(package_name) <= 1:
            logger.info(f"Skipping very short package name: '{package_name}' (NVD API limitation)")
            return []
        
        # Apply rate limiting
        self._rate_limit()
        
        # Build the request URL
        url = f"{self.BASE_URL}?keywordSearch={quote(package_name)}"
        
        # Set up headers
        headers = {"User-Agent": "ossv-scanner/0.1.0"}
        if self.api_key:
            headers["apiKey"] = self.api_key
        
        # Make the request with retries
        for attempt in range(self.max_retries + 1):
            try:
                response = requests.get(url, headers=headers, timeout=self.timeout)
                
                # Update last request time
                self.last_request_time = time.time()
                
                if response.status_code == 200:
                    data = response.json()
                    vulnerabilities = data.get("vulnerabilities", [])
                    
                    # Extract the actual vulnerability data
                    return [v.get("cve", {}) for v in vulnerabilities]
                
                # Handle 404 errors (no data found) - this is normal for many packages
                elif response.status_code == 404:
                    logger.info(f"No vulnerability data found for {package_name} (404 response)")
                    return []
                
                # Handle rate limiting
                elif response.status_code == 403:
                    logger.warning(f"Rate limit exceeded, retrying in {self.rate_limit_sleep * 2} seconds")
                    time.sleep(self.rate_limit_sleep * 2)
                
                # Handle server error
                elif response.status_code >= 500:
                    logger.warning(f"Server error {response.status_code}, retrying in {attempt + 1} seconds")
                    time.sleep(attempt + 1)
                
                # Other errors
                else:
                    logger.error(f"Error {response.status_code} from NVD API: {response.text}")
                    break
            
            except requests.RequestException as e:
                logger.warning(f"Request failed (attempt {attempt + 1}): {str(e)}")
                time.sleep(attempt + 1)
        
        # If we get here, all retries failed
        raise Exception(f"Failed to get vulnerabilities for {package_name} after {self.max_retries + 1} attempts")
    
    def _is_version_affected(self, package_version: str, vuln_data: Dict[str, Any]) -> bool:
        """
        Check if a package version is affected by a vulnerability.

        Args:
            package_version: Version of the package.
            vuln_data: Vulnerability data from NVD.

        Returns:
            True if the version is affected, False otherwise.
        """
        # This is a simplified implementation
        # A production system would use a proper version comparison library
        # and CPE matching to determine if a version is affected
        
        # For now, we'll just check if the version appears in any of the configurations
        if "configurations" not in vuln_data:
            return False
        
        for config in vuln_data.get("configurations", []):
            for node in config.get("nodes", []):
                for cpe_match in node.get("cpeMatch", []):
                    cpe = cpe_match.get("criteria", "")
                    
                    # Check if the version is in the CPE
                    if f":{package_version}:" in cpe:
                        return True
        
        return False
    
    def _rate_limit(self) -> None:
        """Apply rate limiting to avoid exceeding API limits."""
        if self.last_request_time > 0:
            elapsed = time.time() - self.last_request_time
            if elapsed < self.rate_limit_sleep:
                time.sleep(self.rate_limit_sleep - elapsed)
    
    async def _async_rate_limit(self) -> None:
        """Apply rate limiting asynchronously."""
        if self.last_request_time > 0:
            elapsed = time.time() - self.last_request_time
            if elapsed < self.rate_limit_sleep:
                await asyncio.sleep(self.rate_limit_sleep - elapsed)
from typing import Any
import requests
import datetime
from slugify import slugify
import sys


def fetchPkgInfo(pkg: str) -> dict[str, Any] | None:
    """
    Query the PyPI API and return all possible information about the latest version of the package.
    """
    url: str = f"https://pypi.org/pypi/{pkg}/json"
    try:
        resp: requests.Response = requests.get(url=url)
        resp.raise_for_status()
        data = resp.json()
        # print(data)
        latest_version = data["info"]["version"]
        version_info = data["releases"].get(latest_version, [])
        return {
            "info": data["info"],
            "latest_version": latest_version,
            "release_files": version_info,
            "urls": data.get("urls", []),
        }
    except Exception as e:
        return None


def appendLinesToFile(file_path: str, lines: list[str]) -> None:
    """
    Append multiple lines to a file.

    Args:
        file_path (str): The path to the file.
        lines (list[str]): The lines to append.
    """
    try:
        with open(file_path, "a") as file:
            for line in lines:
                file.write(line + "\n")

    except IOError as e:
        print(f"::: Error writing to file {file_path}: {e}")


def createPKGBUILD(pypiPackage: str) -> None:
    print(f"::: Creating PKGBUILD for pypi: [{pypiPackage}]...")
    print(f"::: Fetching package info from PyPI...")
    pkg_info = fetchPkgInfo(pypiPackage)
    if pkg_info is None:
        print(f"::: {pypiPackage} does not exist on PyPI.")
    else:
        print(f"::: {pypiPackage} info fetched successfully.")
        print(f"::: {pypiPackage} latest version is {pkg_info['latest_version']}")
        # verify if PKGBUILD file exists
        try:
            with open("PKGBUILD", "r") as file:
                print(f"::: PKGBUILD file already exists.")
                print("Exiting...")
                sys.exit(1)
        except FileNotFoundError:
            print(f"::: append lines to PKGBUILD...")
            # header
            appendLinesToFile(
                file_path="PKGBUILD",
                lines=[
                    "#",
                    f"# Generated by pypi2aur from pypi package {pypiPackage}",
                    f"# Date {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                    "#",
                ],
            )
            # body
            appendLinesToFile(
                file_path="PKGBUILD",
                lines=[
                    f"pkgname={pypiPackage}",
                    f"_origpkgname={slugify(text=pypiPackage, separator="_")}",
                    f"pkgver={pkg_info['latest_version']}",
                    f"pkrel=1",
                    f"pkgdesc=\"{pkg_info['info']['summary']}\"",
                    f'arch=("x86_64")',
                    f"url='{pkg_info['info']['project_url']}'",
                    f"license=(\"{pkg_info['info']['license']}\")",
                    "depends=()",
                    "makedepends=(",
                    '\t"python-build"',
                    '\t"python-installer"',
                    '\t"python-wheel"',
                    '\t"python-setuptools"',
                    '\t"python-hatchling"',
                    ")",
                    f"source=(\"{pkg_info["release_files"][1]['url']}\")",
                    f"sha256sums=(\"{pkg_info["release_files"][1]['digests']['sha256']}\")",
                    "package() {",
                    "\t" + 'cd "${_origpkgname}-${pkgver}" || exit',
                    "\t" + "python -m build --wheel --no-isolation",
                    "\t" + 'python -m installer --destdir="$pkgdir" dist/*.whl',
                    "\t"
                    + 'install -Dm644 LICENSE "$pkgdir/usr/share/licenses/$pkgname/LICENSE"',
                    "}",
                    "",
                    "# vim:set ts=2 sw=2 et:",
                ],
            )


def readParameter(parameterName: str, filePath: str = "PKGBUILD") -> str | None:
    """
    Read the value of a parameter from the PKGBUILD file.

    Args:
        parameterName (str): The name of the parameter to read.
        filePath (str): The path to the PKGBUILD file (default: 'PKGBUILD').

    Returns:
        str | None: The value of the parameter, or None if not found.
    """
    try:
        with open(filePath, "r") as file:
            for line in file:
                line = line.strip()
                if line.startswith(parameterName + "="):
                    value = line.split("=", 1)[1].strip()
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    return value
        return None
    except IOError as e:
        return None


def changeParameter(
    parameterName: str, newValue: str, filePath: str = "PKGBUILD"
) -> bool:
    """
    Change the value of a parameter in the PKGBUILD file and save it.

    Args:
        parameterName (str): The name of the parameter to change.
        newValue (str): The new value to set.
        filePath (str): The path to the PKGBUILD file (default: 'PKGBUILD').

    Returns:
        bool: True if the parameter was changed, False otherwise.
    """
    try:
        with open(filePath, "r") as file:
            lines = file.readlines()
        changed = False
        for i, line in enumerate(lines):
            if line.strip().startswith(parameterName + "="):
                prefix = line.split("=", 1)[0]
                lines[i] = f"{prefix}={newValue}\n"
                changed = True
                break
        if changed:
            with open(filePath, "w") as file:
                file.writelines(lines)
        return changed
    except IOError:
        return False


def printUpdateHelper(param: str, newValue: str) -> None:
    print(f"::: Updating {param}")
    print(f"from =>\t{readParameter(parameterName=param)}")
    print(f"to <=\t{newValue}")


def updatePKGBUILD() -> None:
    pypiPackage = readParameter("pkgname")
    print(f"::: pkgname: {pypiPackage}")
    print(f"::: Fetching Info for pypi: [{pypiPackage}]...")
    pkg_info = fetchPkgInfo(f"{pypiPackage}")
    if pkg_info is None:
        print(f"::: {pypiPackage} does not exist on PyPI.")
    else:
        print(f"::: {pypiPackage} info fetched successfully.")
        print(f"::: {pypiPackage} latest version is {pkg_info['latest_version']}")
        print(f"::: Updating PKGBUILD...")
        newPkgVer = pkg_info["latest_version"]
        printUpdateHelper(param="pkgver", newValue=newPkgVer)
        changeParameter(
            parameterName="pkgver",
            newValue=newPkgVer,
        )
        printUpdateHelper(param="pkgrel", newValue="1")
        changeParameter(
            parameterName="pkgrel",
            newValue="1",
        )

        newSource = f"(\"{pkg_info['release_files'][1]['url']}\")"
        printUpdateHelper(param="source", newValue=newSource)
        changeParameter(
            parameterName="source",
            newValue=newSource,
        )

        newSha256Sums = f"(\"{pkg_info['release_files'][1]['digests']['sha256']}\")"
        printUpdateHelper(param="sha256sums", newValue=newSha256Sums)
        changeParameter(
            parameterName="sha256sums",
            newValue=newSha256Sums,
        )

        print(f"::: PKGBUILD updated successfully.")


def readPyPiDeps(pypipackage: str) -> None:
    """
    Read and show pypi package dependencies.
    """
    pkg_info = fetchPkgInfo(pypipackage)
    if pkg_info is None:
        print(f"::: {pypipackage} does not exist on PyPI.")
    else:
        print(f"::: {pypipackage} info fetched successfully.")
        print(f"::: {pypipackage} latest version is {pkg_info['latest_version']}")
        print(f"::: Dependencies info from package in pypi.org:")
        for dep in pkg_info["info"]["requires_dist"]:
            print(f"::: {dep}")

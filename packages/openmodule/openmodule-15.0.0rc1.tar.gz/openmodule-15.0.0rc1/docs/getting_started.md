# Getting started

[TOC]

## Overview

### Broker

We are using a global broker on the device. The broker is implemented using the [ZeroMQ](http://zeromq.org/) library.
The broker has a `PUB` (publish) socket and a `SUB` (subscribe) socket.
All device services connect to the broker. Device services use the `SUB` port of the broker to send messages
and the `PUB` port to receive messages.

We are send [multipart messages](https://zguide.zeromq.org/docs/chapter2/#Multipart-Messages) to the broker.
The multipart message consists of a `topic` and a `payload`. The `topic` is used to route the message to possible
multiple device services (Broadcast). The `payload` is a JSON string containing the actual data.

![Broker](./images/broker.drawio.png)

All messages and RPC calls are published on this message queue.

### RPC

Our RPC system publishes the RPC messages with a topic that starts with `rpc-` on the same message queue.

## Pydantic models

We are using [Pydantic](https://docs.pydantic.dev/1.10/) for data validation and serialization.

**âš  Attention:** We are using Pydantic `<2.0.0`!

**âš  Attention:** All models have to inherit from `OpenModuleModel` or one of its children.
Do not use `pydantic.BaseModel` directly.

### Broker messages

All models that are used for broker messages have to inherit from `ZMQMessage`.

### Examples

```python
import datetime
from enum import Enum
from openmodule.models.base import OpenModuleModel, timezone_validator, ZMQMessage


# As a coding standard we are using camel case and the name of the enum and value should always be the same.
# For mor information see coding standard.
class MyStatus(str, Enum):
    very_good = "very_good"
    good = "good"
    this_is_fine = "this_is_fine"
    bad = "bad"


class MyStatusMessage(ZMQMessage):
    status: MyStatus
    description: str


class LatestStatus(OpenModuleModel):
    timestamp: datetime.datetime
    status: MyStatus

    # we have to define a validator for the timestamp
    _tz_timestamp = timezone_validator("timestamp")
```

For all `datetime` fields we have to define a timezone validator. This is because we are using UTC timestamps
in naive format and the validator makes sure that if the given datetime has a timezone it will be converted to UTC.
The Openmodule will raise an `AssertionError` if the validator is missing.

## Openmodule

### Project Structure

The Openmodule is structured in the following way:

```
openmodule/
â”œâ”€â”€ openmodule/
â”‚   â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ rpc/
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ openmodule_test/
â”œâ”€â”€ openmodule_commands/
â””â”€â”€ tests/
```

In the `openmodule` folder we have the actual Openmodule code. In this folder the core implementation that
has many features is present. These features are commonly used by the device services.

In the folder `openmodule_test` we have some test mixins that can be used for writing tests cases.

The `openmodule_commands` folder contains some utility commands like for example creating the translations files.

### Project Structure of a Device Service

A typical device service has the following structure:

```
device-service/
â”œâ”€â”€ docker/
â”œâ”€â”€ settings/
â”‚   â”œâ”€â”€ default.env
â”‚   â””â”€â”€ default.yml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app.py
â”‚   â”œâ”€â”€ config.py
â”‚   â””â”€â”€ models.py
â””â”€â”€ tests/
```

**â„¹ Information:** This folder structure and the files are automatically generated by our template project.
You don't have to create them manually.

In the `docker` folder Docker and CI/CD related files are stored.

The `settings` folder will contain the default settings for the device service. The `default.env` file contains
the default values of the variables that are defined in the `app/config.py` file.
The YAML file `default.yml` is an optional additional config file if you need a more complex configuration.

The `src` folder contains the actual source code of the device service. The `app.py` file contains the main function
of the device service. An example of the `app.py` is shown in the section
[Create a Openmodule Instance](getting_started.md#create-a-openmodule-instance).
This example of the `app.py` file was copied from our template project.
The `config.py` file contains the configuration of the device service. The `models.py` file
should hold all models that are used in the device service.

In the `tests` folder all test cases are stored.

### Config alias Settings

We are using environment variables and a YAML file for configuration.

The settings module provides some additional functionality.
For more information see the settings [documentation](settings.md).

#### Examples

Here you can see some examples of the `config.py` file.

```python
from openmodule import config
from openmodule.models.base import OpenModuleModel

USER = config.string("USER")
PASSWORD = config.string("PASSWORD")
TIMEOUT = config.float("TIMEOUT", 5.0)

if config.debug() or config.dev_device():
    ENDPOINT = "staging.api.com/hello"
else:
    ENDPOINT = "production.api.com/hello"


class ExampleYamlConfig(OpenModuleModel):
    showcase: bool


YAML = config.yaml(ExampleYamlConfig)
```

The settings can be used in our `app.py` like this:

```python
import requests
from requests.auth import HTTPBasicAuth
from openmodule.config import settings

print(f"Showcase: {settings.YAML.showcase}")
response = requests.get(settings.ENDPOINT, auth=HTTPBasicAuth(settings.USER, settings.PASSWORD))
```

#### Pitfall: Circular Import

If you are using an Openmodule functionality in your `config.py` which has a dependency to the `settings` module
you will run into a circular import. The most common case is when you are using the `translation` module.

Another circular import can happen for the model definition of the YAML config.
To solve this migrate your model definition and the YAML initialization
(`YAML = config.yaml(ExampleYamlConfig)`) to a separate file.

### Create a Openmodule Instance

The first step that are you have to do is to create an instance of the Openmodule class.
Below you see an example of the main Python file `app.py`. This file was copied from our template project and
you do not have to manually create it. You also need to provide a Sentry DSN to the Openmodule.

```python
import logging
import time

from openmodule.config import settings
from openmodule.core import init_openmodule, shutdown_openmodule


def main_wrapper():
    try:
        main()
    except Exception as e:
        logging.exception(e)
    finally:
        shutdown_openmodule()


def main():
    core = init_openmodule(settings, dsn="https://<key>@debug.acc.si/<project>")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logging.warning("KeyboardInterrupt received, shutting down...")
    finally:
        # shutdown routines
        pass


if __name__ == "__main__":  # pragma: no cover
    main_wrapper()
```

The `core` instance of the openmodule provides a lot of functionality that is used by the other services.
For example it connects to the broker automatically, configures sentry and so on.

### Messaging

We will now send our first message to the broker using the `core` instance.
First of all we need to declare a model for our message.

```python
class WelcomeMessage(ZMQMessage):
    type: str = "hi"
    message: str
```

A `ZMQMessage` always has a `name` and a `type` field. The `name` field is automatically patched to `settings.NAME`,
but you have to manually choose the `type` of your message.

Now we can publish the message to the broker.

```python
core.publish(WelcomeMessage(message="Hello World!"), "welcome")
```

Our broker message always consists of a `topic` and a `payload`. The `topic` is used to route the message to possible
multiple device services (Broadcast). The `payload` is a JSON string containing the actual data.

Now we will subscribe a message that the broker publishes using the message handler of the Openmodule.

```python
def handle_welcome(message):
    """I am handling the welcome message."""
    print(f"Received message: {message.message}")


core.messages.register_handler("welcome", WelcomeMessage, handler=handle_welcome)
```

You can also add a filter to the subscription. The filter is a function that returns `True` if the message should be
processed and `False` if the message should be ignored.

```python
def my_filter(message: dict) -> bool:
    return (message.get("message") or "").startswith("Hello")


core.messages.register_handler("welcome", WelcomeMessage, handler=handle_welcome, filter=my_filter)
```

The `register_handler` method has the parameter `register_schema` which is `True` by default.
This parameter automatically create a schema for your message handler and its models.
For more information see the [documentation](utils.md#documentation).

**âš  Attention:** You have to add a [Docstring](https://peps.python.org/pep-0257/#what-is-a-docstring)
to your handler function.

Instead of using a handler function you can provide a listener which has some handle functions.

```python
from openmodule.dispatcher import EventListener

event_listener = EventListener(log=logger)
core.messages.register_handler("welcome", WelcomeMessage, event_listener)
...
event_listener.append(handle_welcome)
```

Now we can receive and send messages to the broker.

#### Message Handler

By default the message handlers are executed single threaded. If you absolutely have to run your message handlers
multithreaded there is an option to increase the openmodule core's executor threads.

```python
init_openmodule(config, dispatcher_max_threads=5)
```

### RPC

Sometimes you want to call a procedure of another service. For this we are using RPC.
A guide for the RPC client and RPC server can be found [here](rpc.md).

### Health

The Openmodule provides a health check implementation. You can find the documentation [here](health.md).

### Database

If your device service needs a database you have to initialize the Openmodule core with the parameter `database=True`.

```python
core = init_openmodule(settings, database=True)
```

There exist a separate [guide](database.md) for the database.

## Further Reading

We covered the basics of the Openmodule. Now you can start to implement your own service ðŸ˜€.
For further documentation see the files in the `docs` folder.

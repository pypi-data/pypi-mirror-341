"""
Extra tools to interact with Microsoft M365 tenants.
"""
import json
import logging
from datetime import datetime, timedelta, timezone
import re
from time import sleep
from typing import Any, Generator

import requests
from msal import ConfidentialClientApplication
from zut import get_wpad_proxy, parse_tz, ExtendedJSONEncoder

from . import settings

__prog__ = 'm365-extra'

try:
    # Generated by setuptools_scm during build
    from ._version import __version__, __version_tuple__
except ModuleNotFoundError:
    __version__ = None
    __version_tuple__ = None


class M365Client:
    """
    Microsoft Graph API client.
    """
    scopes = ['https://graph.microsoft.com/.default']
    base_url = 'https://graph.microsoft.com/v1.0/'

    def __init__(self):
        self._logger = logging.getLogger(f'{self.__class__.__module__}.{self.__class__.__qualname__}')
        
        self.session = requests.Session()
        if settings.HTTPS_PROXY:
            if settings.HTTPS_PROXY == '__wpad__':
                settings.HTTPS_PROXY = get_wpad_proxy()
                
            if settings.HTTPS_PROXY:
                self.session.proxies.update({
                    'https': settings.HTTPS_PROXY,
                })

        self._access_client = None
        self._access_token = None
        self._access_token_type = None
        self._access_token_expires = None


    @property
    def access_token(self):
        if self._access_token is None or (self._access_token_expires and self._access_token_expires <= datetime.now() + timedelta(seconds=60)):
            self.refresh_access_token()
        return self._access_token
    

    def refresh_access_token(self):
        if self._access_client is None:
            if not settings.TENANT_ID:
                raise ValueError("Missing setting M365_TENANT_ID")
            if not settings.APP_ID:
                raise ValueError("Missing setting M365_APP_ID")
            secret_key = settings.CLIENT_SECRET_KEY.value
            if not secret_key:
                raise ValueError("Missing setting M365_CLIENT_SECRET_KEY or M365_CLIENT_SECRET_KEY_FILE")
            
            self._access_client = ConfidentialClientApplication(settings.APP_ID, client_credential=secret_key,
                                    authority = f'https://login.microsoftonline.com/{settings.TENANT_ID}',
                                    http_client=self.session)
        
        self._logger.debug("Acquire token for scopes %s", self.scopes)
        result = self._access_client.acquire_token_for_client(self.scopes)
        if 'error' in result:
            raise self.Error(result['error'], result.get('error_codes'), result.get('error_description'))

        self._access_token = result['access_token']
        self._access_token_type = result['token_type']
        self._access_token_expires = datetime.now() + timedelta(seconds=result['expires_in'])
        self._logger.debug("Acquired token expires %s", self._access_token_expires)
        

    def list(self, endpoint: str) -> dict[str,Any]:
        """
        Perform request on Microsoft Graph API that return a list of items.
        """
        return [item for item in self.iter(endpoint)]
        

    def iter(self, endpoint: str, *, headers: dict[str,str] = None, no_authorization = False) -> Generator[dict[str,Any],Any,None]:
        """
        Perform request on Microsoft Graph API that iterate over list of items.
        """
        data = self.raw(endpoint, headers=headers, no_authorization=no_authorization)
        
        if not 'value' in data:
            raise ValueError("Cannot iterate on %s: no 'value' key in result" % (endpoint,))
        if not isinstance(data['value'], list):
            raise ValueError("Cannot iterate on %s: 'value' is not a list" % (endpoint,))
        
        for item in data['value']:
            yield item

        remaining = {k: v for k, v in data.items() if k not in {'value', '@odata.context', '@odata.nextLink'}}
        if remaining:
            self._logger.warning("Remaining data after iter: %s", remaining)
        
        if next_url := data.get('@odata.nextLink'):
            yield from self.iter(next_url)


    def get(self, endpoint: str, *, headers: dict[str,str] = None, no_authorization = False):
        """
        Perform a GET request on Microsoft Graph API.
        """
        data = self.raw(endpoint, headers=headers, no_authorization=no_authorization)
        if isinstance(data, dict) and (data.keys() == {'@odata.context', 'value'} or data.keys() == {'@odata.context', 'value', '@odata.nextLink'}) and isinstance(data['value'], list):
            data_list = data['value']
            if next_url := data.get('@odata.nextLink'):
                for data in self.iter(next_url, headers=headers, no_authorization=no_authorization):
                    data_list.append(data)
            return data_list
        else:        
            return data


    def patch(self, endpoint: str, data: dict[str|Any]|str|bytes = None, *, headers: dict[str,str] = None, no_authorization = False):
        """
        Perform a PATCH request on Microsoft Graph API.
        """
        response_data = self.raw(endpoint, data, method='PATCH', headers=headers, no_authorization=no_authorization)
        response_data.pop('@odata.context')
        return response_data


    def post(self, endpoint: str, data: dict[str|Any]|str|bytes = None, *, headers: dict[str,str] = None, no_authorization = False):
        """
        Perform a POST request on Microsoft Graph API.
        """
        response_data = self.raw(endpoint, data, method='POST', headers=headers, no_authorization=no_authorization)
        response_data.pop('@odata.context')
        return response_data


    def put(self, endpoint: str, data: dict[str|Any]|str|bytes = None, *, headers: dict[str,str] = None, no_authorization = False):
        """
        Perform a PUT request on Microsoft Graph API.
        """
        response_data = self.raw(endpoint, data, method='PUT', headers=headers, no_authorization=no_authorization)
        response_data.pop('@odata.context')
        return response_data


    def raw(self, endpoint: str, data: dict[str|Any]|str|bytes = None, *, method: str = None, headers: dict[str,str] = None, no_authorization = False, retries = 2) -> dict[str,Any]:
        """
        Perform a raw request on Microsoft Graph API.
        """
        if not endpoint.startswith(('http://', 'https://')):
            endpoint = self.base_url + endpoint.removeprefix('/')

        if not method:
            if data is not None:
                method = 'POST'
            else:
                method = 'GET'

        actual_headers = {}
        if not no_authorization and not (headers and 'Authorization' in headers):
            actual_headers['Authorization'] = f'Bearer {self.access_token}'
            
        if data and not isinstance(data, bytes):
            actual_headers['Content-Type'] = 'application/json'
            if isinstance(data, dict):
                data = json.dumps(data, ensure_ascii=False, cls=ExtendedJSONEncoder)

        if headers:
            for k, v in headers.items():
                actual_headers[k] = v
                
        response = self.session.request(method, endpoint, data=data, headers=actual_headers)

        if response.status_code >= 400 :
            error = self.Error.from_response(response)
            if retries and response.status_code == 503: # Service Unavailable
                self._logger.info(f"Service unavailble, will retry in 10 seconds ({'last retry' if retries == 1 else f'{retries} retries remaining'}) …")
                sleep(10)
                return self.raw(endpoint, data, method=method, headers=headers, no_authorization=no_authorization, retries=retries - 1)
            else:
                raise error

        return response.json()
    

    #region Helpers

    def parse_datetime(cls, value: str|datetime|dict) -> datetime:
        if value is None:
            return None
        elif isinstance(value, datetime):
            return value
        elif isinstance(value, str):
            return datetime.fromisoformat(value)
        elif isinstance(value, dict):                
            tz = value['timeZone']
            return datetime.fromisoformat(value['dateTime']).replace(tzinfo=timezone.utc if tz == 'UTC' else parse_tz(tz))
        else:
            raise TypeError(f"Invalid type for parse_datetime argument: {type(value).__name__}")

    #endregion


    #region Errors
                
    class Error(Exception):
        def __init__(self, name: str, code: int|list[int], description: str|None = None):
            message = str(name)
            
            if code:
                if isinstance(code, list):
                    message += f" (code {','.join(str(code) for code in code)})"
                    if len(code) == 1:
                        code = code[0]
                else:
                    message += f" (code {code})"
            
            if description:
                message += f": {description}"

            super().__init__(message)

            self.name = name
            self.code = code
            self.description = description

        @classmethod
        def from_response(cls, response: requests.Response):
            code = response.status_code

            if isinstance(response.reason, bytes):
                try:
                    name = response.reason.decode("utf-8")
                except UnicodeDecodeError:
                    name = response.reason.decode("iso-8859-1")
            elif response.reason:
                name = response.reason
            else:
                name = cls.__name__

            content_type = response.headers.get('Content-Type')
            if content_type:
                if m := re.match(r'^([^;]+);.*$', content_type):
                    content_type = m[1].strip()
                else:
                    content_type = content_type.strip()

            description = None
            if content_type == 'application/json':
                data = response.json()
                if isinstance(data, dict) and (error := data.get('error')) and isinstance(error, dict):
                    if value := error.get('code'):
                        if isinstance(value, int):
                            code = value
                        elif isinstance(value, str):
                            name = value
                        
                    if value := error.get('message'):
                        description = value
            
            if not description:
                description = response.text.strip()
                if len(description) > 255:
                    description = description[0:255] + '…'

            if code == 404 and description == "The mailbox is either inactive, soft-deleted, or is hosted on-premise.":
                cls = M365Client.MailboxInactiveError
            return cls(name, code, description)
        
    class MailboxInactiveError(Error):
        pass

    #endregion

// Copyright (c) 2024-2025, NVIDIA CORPORATION & AFFILIATES.  All rights reserved.
//
// NVIDIA CORPORATION and its licensors retain all intellectual property
// and proprietary rights in and to this software, related documentation
// and any modifications thereto.  Any use, reproduction, disclosure or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA CORPORATION is strictly prohibited.

// libmathdx's API is subject to change.
// Please contact Math-Libs-Feedback@nvidia.com for usage feedback.

#ifndef MATHDX_LIBCOMMONDX_H
#define MATHDX_LIBCOMMONDX_H

#include <stddef.h>

#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

#ifndef LIBMATHDX_API
#if __GNUC__ >= 4
#define LIBMATHDX_API __attribute__((visibility("default")))
#else
#define LIBMATHDX_API
#endif
#endif

#ifndef LIBMATHDX_CALL
#ifdef _WIN32
#define LIBMATHDX_CALL __stdcall
#else
#define LIBMATHDX_CALL
#endif
#endif

#ifdef __cplusplus
#ifndef LIBMATHDX_API_NOEXCEPT
#define LIBMATHDX_API_NOEXCEPT noexcept
#endif
#else
#define LIBMATHDX_API_NOEXCEPT
#endif

/**
 * @brief A handle to some compiled code.
 *
 * Compile code generally contains one or more device function, and is specified by
 * the code type (e.g. SASS, PTX, LTO - \ref commondxCodeType_t) and the compute capability
 * (in the form of an integer, e.g. 800 for CC 8.0).
 *
 * Compile code can be genrated by a call to \ref cublasdxFinalizeCode,
 * \ref cufftdxFinalizeCode or \ref cusolverdxFinalizeCode.
 */
typedef long long int commondxCode;

/**
 * @brief The set of value types supported by the library.
 *
 * Note that, for complex numbers, this combines real and imaginary part,
 * and that all complex numbers are overaligned on their size.
 */
typedef enum commondxValueType_t {
    /** Equivalent to __nv_fp8_e5m2. Size: 1B, alignment: 1B */
    COMMONDX_R_8F_E5M2 = 0,
    /** Equivalent to 2x__nv_fp8_e5m2. Size: 2B, alignment: 2B (overaligned) */
    COMMONDX_C_8F_E5M2 = 1,
    /** Equivalent to __nv_fp8_e4m3. Size: 1B, alignment: 1B */
    COMMONDX_R_8F_E4M3 = 2,
    /** Equivalent to 2x__nv_fp8_e4m3. Size: 2B, alignment: 2B (overaligned) */
    COMMONDX_C_8F_E4M3 = 3,
    /** Equivalent to __nv_bfloat16. Size: 2B, alignment: 2B */
    COMMONDX_R_16BF = 4,
    /** Equivalent to 2x__nv_bfloat16. Size: 4B, alignment: 4B (overaligned) */
    COMMONDX_C_16BF = 5,
    /** Equivalent to __half2. Size: 4B, alignment: 4B */
    COMMONDX_R_16F2 = 6,
    /** Equivalent to __half. Size: 2B, alignment: 2B */
    COMMONDX_R_16F = 7,
    /** Equivalent to 2x__half. Size: 4B, alignment: 4B (overaligned) */
    COMMONDX_C_16F = 8,
    /** Equivalent to 2x__half2. Size: 8B, alignment: 8B (overaligned) */
    COMMONDX_C_16F2 = 9,
    /** Equivalent to tf32. Size: 4B, alignment: 4B */
    COMMONDX_R_32TF = 10,
    /** Equivalent to 2xtf32. Size: 8B, alignment: 8B (overaligned) */
    COMMONDX_C_32TF = 11,
    /** Equivalent to float. Size: 4B, alignment: 4B */
    COMMONDX_R_32F = 12,
    /** Equivalent to 2xfloat. Size: 8B, alignment: 8B (overaligned) */
    COMMONDX_C_32F = 13,
    /** Equivalent to double. Size: 8B, alignment: 8B */
    COMMONDX_R_64F = 14,
    /** Equivalent to 2xdouble. Size: 16B, alignment: 16B (overaligned) */
    COMMONDX_C_64F = 15,
} commondxValueType;

/**
 * @brief The set of status values that can be returned by APIs defined in the library
 */
typedef enum commondxStatusType_t {
    /** Success */
    COMMONDX_SUCCESS = 0,
    /** One of the input values is not in the allowed range or is otherwise invalid */
    COMMONDX_INVALID_VALUE = 1,
    /** Library internal error */
    COMMONDX_INTERNAL_ERROR = 2,
    /** Compilation did not complete successfully */
    COMMONDX_COMPILATION_ERROR = 3
} commondxStatusType;

/**
 * @brief The set of precisions supported by the library
 *
 * For the actual input and output value types, see \ref commondxValueType_t
 */
typedef enum commondxPrecision_t {
    /** Equivalent to __nv_fp8_e5m2 */
    COMMONDX_PRECISION_F8_E5M2 = 0,
    /** Equivalent to __nv_fp8_e4m3 */
    COMMONDX_PRECISION_F8_E4M3 = 1,
    /** Equivalent to __nv_bfloat16 */
    COMMONDX_PRECISION_BF16 = 2,
    /** Equivalent to __half */
    COMMONDX_PRECISION_F16 = 3,
    /** Equivalent to tfloat32 */
    COMMONDX_PRECISION_TF32 = 4,
    /** Equivalent to float */
    COMMONDX_PRECISION_F32 = 5,
    /** Equivalent to double */
    COMMONDX_PRECISION_F64 = 6,
} commondxPrecision;

/**
 * @brief Options to tweak code generation
 */
typedef enum commondxOption_t {
    /**
     * Symbol to wrap the device function in (default is autogenerated.
     * Associated value must be A C-string.
     */
    COMMONDX_OPTION_SYMBOL_NAME = 0,
    /**
     * Target SM.
     * Associated value must be an integer, e.g. 800 for SM80.
     * See \ref commondxSetCodeOptionInt64
     */
    COMMONDX_OPTION_TARGET_SM = 1,
    /**
     * Code type (e.g. PTX, LTO or Cubin (SASS)).
     * Associated value must be a value of \ref commondxCodeType_t
     */
    COMMONDX_OPTION_CODE_TYPE = 2,
    /**
     * Code ISA (e.g. 12.3 for LTO)
     * Associated value must be an integer, e.g. 12030 for 12.3
     */
    COMMONDX_OPTION_CODE_ISA = 3,
} commondxOption;

/**
 * @brief The set of execution modes supported by the library
 */
typedef enum commondxExecution_t {
    /**
     * Thread APIs.
     * All threads are independant, divergent control flow is allowed.
     */
    COMMONDX_EXECUTION_THREAD = 0,
    /**
     * Block APIs.
     * All threads in the block cooperate, and all must call the device function.
     */
    COMMONDX_EXECUTION_BLOCK = 1,
} commondxExecution;

/**
 * @brief The set of device code types supported by the library.
 * See \ref commondxOption_t::COMMONDX_OPTION_CODE_TYPE
 */
typedef enum commondxCodeType_t {
    /**
     * LTOIR, aka -lto with NVCC and NVRTC
     */
    COMMONDX_CODE_TYPE_LTOIR = 0,
} commondxCodeType;

/**
 * @brief Creates a code handle.
 *
 * @param[out] code A pointer to the output code handle.
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxCreateCode(commondxCode* code) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Set an option on a code handle
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[in] option The option to set the code to
 * @param[in] value A corresponding value for the selected option
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxSetCodeOptionInt64(commondxCode code,
                                                                           commondxOption option,
                                                                           long long int value) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Get option from a code handle
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[in] option The option to get
 * @param[out] value The option value.
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxGetCodeOptionInt64(commondxCode code,
                                                                           commondxOption option,
                                                                           long long int* value) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Get options (as an array) from a code handle, with one option per output code
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[in] option The option to get
 * @param[in] size The array size, as result from \ref commondxGetCodeNumLTOIRs
 * @param[out] array A pointer to the beginning of the output array. Must be a pointer to a buffer of at least `size`
 * elements.
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL
commondxGetCodeOptionsInt64s(commondxCode code, commondxOption option, size_t size, long long int* array)
    LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Extract the LTOIR size, in bytes.
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[out] size The LTOIR size, in bytes.
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxGetCodeLTOIRSize(commondxCode code,
                                                                         size_t* size) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Extract the LTOIR.
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[in] size The LTOIR size, as returned by \ref commondxGetCodeLTOIRSize
 * @param[out] out The LTOIR. Must be a pointer to a buffer of at least size byte.
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxGetCodeLTOIR(commondxCode code,
                                                                     size_t size,
                                                                     void* out) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Returns the number the LTOIR chunks.
 *
 * Some code produce more than one LTOIR.
 * In this case, this function must be used to retreive the number of LTOIR's.
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[out] size The number of LTOIR chunks.
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxGetCodeNumLTOIRs(commondxCode code,
                                                                         size_t* size) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Returns the size of all LTOIR chunks.
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[in] size The number of LTOIR chunks, as returned by \ref commondxGetCodeNumLTOIRs
 * @param[out] out On output, `out[i]` is the size, in byte, of the ith LTOIR chunk.
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxGetCodeLTOIRSizes(commondxCode code,
                                                                          size_t size,
                                                                          size_t* out) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Returns all LTOIR chunks.
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @param[in] size The number of LTOIR chunks, as returned by \ref commondxGetCodeNumLTOIRs
 * @param[out] out On output, `out[i]` is filled with the ith LTOIR chunk. `out[i]` must point to a buffer
 * of at least `size[i]` bytes, with `size` the output of \ref commondxGetCodeLTOIRSizes
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxGetCodeLTOIRs(commondxCode code,
                                                                      size_t size,
                                                                      void** out) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Destroys a code handle.
 *
 * @param[in] code A code handle from \ref commondxCreateCode
 * @return `COMMONDX_SUCCESS` on success, or an error.
 */
LIBMATHDX_API commondxStatusType LIBMATHDX_CALL commondxDestroyCode(commondxCode code) LIBMATHDX_API_NOEXCEPT;

/**
 * @brief Convert a status enum to a human readable C-string
 *
 * @param[in] status The status enum to convert
 * @return A short C-string describing the enum. This C-string should be not free'ed by the caller.
 */
LIBMATHDX_API const char* LIBMATHDX_CALL commondxStatusToStr(commondxStatusType status) LIBMATHDX_API_NOEXCEPT;

#if defined(__cplusplus)
} // extern "C"
#endif /* __cplusplus */

#endif // MATHDX_LIBCOMMONDX_H
